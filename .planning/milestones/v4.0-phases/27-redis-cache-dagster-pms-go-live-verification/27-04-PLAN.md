---
phase: 27-redis-cache-dagster-pms-go-live-verification
plan: 04
type: execute
wave: 2
depends_on:
  - "27-01"
  - "27-02"
  - "27-03"
files_modified:
  - scripts/verify_phase3.py
  - Makefile
autonomous: true
requirements:
  - PMS-VER-01

must_haves:
  truths:
    - "verify_phase3.py validates all system components from v1 through v4"
    - "Script produces formatted PASS/FAIL table matching verify_phase2.py style"
    - "All 20 etapas from PMS guide are covered by verification checks"
    - "Makefile has verify-pms, backup, and morning-pack targets"
    - "Exit code 0 if all pass, 1 if any fail"
  artifacts:
    - path: "scripts/verify_phase3.py"
      provides: "Comprehensive verification script for v4.0 PMS system"
      contains: "class.*Check\\|verify_phase3\\|PHASE 3"
    - path: "Makefile"
      provides: "Updated Makefile with PMS-specific targets"
      contains: "verify-pms"
  key_links:
    - from: "scripts/verify_phase3.py"
      to: "src/pms/__init__.py"
      via: "Import checks for all PMS services"
      pattern: "from src.pms"
    - from: "scripts/verify_phase3.py"
      to: "src/cache/pms_cache.py"
      via: "Import check for PMSCache"
      pattern: "from src.cache"
    - from: "scripts/verify_phase3.py"
      to: "src/orchestration/assets_pms.py"
      via: "Import check for Dagster PMS assets"
      pattern: "from src.orchestration"
    - from: "Makefile"
      to: "scripts/verify_phase3.py"
      via: "verify-pms target runs the script"
      pattern: "verify_phase3"
---

<objective>
Comprehensive verification script validating the full system (v1 through v4) and updated Makefile with PMS operational targets.

Purpose: The final gate before go-live. The verification script ensures nothing has regressed across all 27 phases and all 20 PMS etapas are functional. Follows the existing verify_phase2.py pattern (CheckResult namedtuple, ANSI colors, box-drawing table) for consistency.

Output: `scripts/verify_phase3.py` with 30+ checks covering v1-v4 components, updated `Makefile` with PMS targets.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@scripts/verify_phase2.py
@src/pms/__init__.py
@src/cache/pms_cache.py
@src/orchestration/definitions.py
@Makefile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Comprehensive verify_phase3.py covering v1-v4</name>
  <files>scripts/verify_phase3.py</files>
  <action>
Create `scripts/verify_phase3.py` following the exact pattern of `verify_phase2.py`:
- Same CheckResult namedtuple, ANSI color helpers (_green, _red, _bold, _supports_color)
- Same print_table function with box-drawing characters
- Same main() pattern returning exit code

Organize checks by component group (not by etapa number). The script validates the FULL system (v1 through v4) per the locked decision in CONTEXT.md.

**Group 1: v1.0 Data Infrastructure (4 checks)**
1. `verify_orm_models`: Import all ORM models from `src.core.models` -- should have 10+ models (Instrument, SeriesMetadata, MarketData, CurveData, FlowData, etc.)
2. `verify_connectors`: Import from `src.connectors` -- should have 11 connectors
3. `verify_transforms`: Import from `src.transforms` -- should have curve, returns, macro modules
4. `verify_api_health`: Import from `src.api.main` and check /health route exists

**Group 2: v2.0 Agents & Strategies (4 checks)**
5. `verify_agents`: AgentRegistry.EXECUTION_ORDER has 5 agents (same as verify_phase2.py)
6. `verify_strategy_registry`: StrategyRegistry.list_all() >= 24 strategies (same as verify_phase2.py)
7. `verify_backtesting`: Import BacktestEngine, check run and run_portfolio methods
8. `verify_signal_aggregation`: Import SignalAggregatorV2, check aggregate method

**Group 3: v3.0 Risk, Portfolio, Orchestration (5 checks)**
9. `verify_var_calculator`: Import VaRCalculator, compute historical VaR on sample data (same as verify_phase2.py)
10. `verify_stress_tester`: StressTester has 6+ scenarios (same as verify_phase2.py)
11. `verify_black_litterman`: BlackLitterman has optimize method (same as verify_phase2.py)
12. `verify_dagster_assets`: Count @asset decorators in src/orchestration/*.py >= 26 (22 + 4 PMS)
13. `verify_grafana_dashboards`: 4+ JSON files in monitoring/grafana/dashboards/

**Group 4: v4.0 PMS Services (6 checks)**
14. `verify_position_manager`: Import PositionManager, check open_position, close_position, mark_to_market, get_book methods
15. `verify_trade_workflow`: Import TradeWorkflowService, check generate_proposals_from_signals, approve_proposal, reject_proposal methods
16. `verify_morning_pack`: Import MorningPackService, check generate method
17. `verify_risk_monitor`: Import RiskMonitorService, check `compute_live_risk` method exists (actual method name per RiskMonitorService API — NOT `get_snapshot`)
18. `verify_attribution`: Import PerformanceAttributionEngine, check `compute_attribution` method exists (actual method name per PerformanceAttributionEngine API — NOT bare `compute`)
19. `verify_pms_cache`: Import PMSCache from src.cache, check get_book, set_book, invalidate_portfolio_data methods

**Group 5: v4.0 PMS API & Frontend (5 checks)**
20. `verify_pms_api_routes`: Import app from src.api.main, check 6 PMS routers registered (pms_portfolio, pms_trades, pms_journal, pms_briefing, pms_risk, pms_attribution). Note: 6 routers total, but only 5 have Redis caching — pms_journal is excluded from caching (see Plan 27-01). Count PMS routes >= 20.
21. `verify_pms_frontend_pages`: Check 7 PMS page JSX files exist in src/api/static/js/pms/pages/ (MorningPackPage, PositionBookPage, TradeBlotterPage, RiskMonitorPage, PerformanceAttributionPage, DecisionJournalPage, AgentIntelPage) plus ComplianceAuditPage
22. `verify_pms_design_system`: Check src/api/static/js/pms/theme.jsx and components.jsx exist
23. `verify_dashboard_html`: dashboard.html contains text/babel (same as verify_phase2.py)
24. `verify_websocket_channels`: ConnectionManager importable with connect/broadcast (same as verify_phase2.py)

**Group 6: v4.0 PMS Pipeline & Ops (5 checks)**
25. `verify_dagster_pms_assets`: Import 4 PMS assets from src.orchestration.assets_pms
26. `verify_dagster_pms_schedules`: Import defs from definitions, check 3 schedules registered
27. `verify_golive_docs`: Check docs/GOLIVE_CHECKLIST.md, docs/OPERATIONAL_RUNBOOK.md, docs/DR_PLAYBOOK.md exist
28. `verify_backup_scripts`: Check scripts/backup.sh and scripts/restore.sh exist and are executable
29. `verify_alert_rules`: AlertManager has 10+ rules (same as verify_phase2.py)

Title line: `"Macro Trading v4.0 -- Full System Verification (v1-v4)"`

Each check function follows the pattern:
```python
def verify_xxx() -> CheckResult:
    """Check N: description."""
    try:
        # ... verification logic ...
        return CheckResult("Description", "PASS", "detail")
    except Exception as exc:
        return CheckResult("Description", "FAIL", str(exc)[:60])
```

ALL_CHECKS list includes all 29 check functions.
  </action>
  <verify>
Run: `python scripts/verify_phase3.py` -- should produce formatted table. Expect most checks to PASS (some may FAIL if DB not running, which is acceptable for static import checks). Key: script runs without crashing and produces readable output.
  </verify>
  <done>verify_phase3.py exists with 29 checks across 6 groups (v1 infra, v2 agents, v3 risk/orch, v4 PMS services, v4 API/frontend, v4 pipeline/ops), produces formatted PASS/FAIL table, exits with 0 or 1</done>
</task>

<task type="auto">
  <name>Task 2: Makefile PMS targets</name>
  <files>Makefile</files>
  <action>
Append PMS-specific targets to the existing Makefile, after the existing Dagster section. Add a new section header comment.

```makefile
# ── PMS Operations ──────────────────────────────────────────────
# Verify all PMS components (v4.0)
verify-pms:
	python scripts/verify_phase3.py

# Full system verification (v1-v4)
verify-all:
	python scripts/verify_phase2.py && python scripts/verify_phase3.py

# Database backup
backup:
	bash scripts/backup.sh

# Database restore (usage: make restore FILE=backups/2026-02-25_1800/macro_trading_2026-02-25_1800.pgdump)
restore:
	bash scripts/restore.sh $(FILE)

# Generate morning pack manually
morning-pack:
	python -c "from src.pms.morning_pack import MorningPackService; from datetime import date; import asyncio; ms = MorningPackService(); print(asyncio.run(ms.generate(briefing_date=date.today())))"

# Start PMS development (API + Docker)
pms-dev:
	docker compose up -d
	uvicorn src.api.main:app --reload --host 0.0.0.0 --port 8000
```

Also update the .PHONY line at the top to include the new targets: `verify-pms verify-all backup restore morning-pack pms-dev`.
  </action>
  <verify>
Run: `grep -c 'verify-pms\|verify-all\|backup\|restore\|morning-pack\|pms-dev' Makefile` -- should return 6+ (target definitions).
  </verify>
  <done>Makefile has 6 new PMS targets (verify-pms, verify-all, backup, restore, morning-pack, pms-dev), all in .PHONY</done>
</task>

</tasks>

<verification>
1. `python scripts/verify_phase3.py` runs and produces formatted output (no crash)
2. `make verify-pms` works (runs verify_phase3.py)
3. Script covers all 6 component groups (v1 through v4)
4. Script has 29 checks total
5. Exit code is 0 when all pass, 1 when any fail
6. Makefile has all 6 new targets
</verification>

<success_criteria>
- verify_phase3.py validates full system (v1-v4) with 29 checks
- Output matches verify_phase2.py style (box-drawing, ANSI colors, PASS/FAIL)
- All 20 PMS etapas covered (DB models, position manager, trade workflow, morning pack, risk monitor, attribution, 7 frontend pages, cache, Dagster, docs)
- Makefile updated with 6 PMS operational targets
</success_criteria>

<output>
After completion, create `.planning/phases/27-redis-cache-dagster-pms-go-live-verification/27-04-SUMMARY.md`
</output>
