---
phase: 21-trade-workflow-pms-api
plan: 03
type: execute
wave: 3
depends_on: ["21-02"]
files_modified:
  - src/api/routes/pms_journal.py
  - src/api/main.py
  - tests/test_pms/test_pms_api.py
autonomous: true
requirements: [PMS-API-04, PMS-TW-04, PMS-TW-05]

must_haves:
  truths:
    - "PMS Journal router serves 4 endpoints: GET / (list entries), GET /{id} (detail), POST /{id}/outcome (record outcome), GET /stats/decision-analysis (statistics)"
    - "All 3 PMS routers (portfolio, trades, journal) are registered in main.py with /api/v1 prefix and PMS tags appear in Swagger"
    - "FastAPI TestClient integration tests verify end-to-end PMS API flows: open position, generate proposals, approve, reject, close, journal query"
  artifacts:
    - path: "src/api/routes/pms_journal.py"
      provides: "4 journal endpoints"
      contains: "router = APIRouter"
    - path: "src/api/main.py"
      provides: "Updated with 3 PMS router registrations"
      contains: "pms_portfolio"
    - path: "tests/test_pms/test_pms_api.py"
      provides: "Integration tests for PMS API"
      min_lines: 150
  key_links:
    - from: "src/api/main.py"
      to: "src/api/routes/pms_portfolio.py"
      via: "app.include_router with /api/v1 prefix"
      pattern: "pms_portfolio"
    - from: "src/api/main.py"
      to: "src/api/routes/pms_trades.py"
      via: "app.include_router with /api/v1 prefix"
      pattern: "pms_trades"
    - from: "src/api/main.py"
      to: "src/api/routes/pms_journal.py"
      via: "app.include_router with /api/v1 prefix"
      pattern: "pms_journal"
    - from: "tests/test_pms/test_pms_api.py"
      to: "src/api/main.py"
      via: "FastAPI TestClient"
      pattern: "TestClient"
---

<objective>
Complete the PMS API by adding the Decision Journal router, registering all 3 PMS routers in main.py, and creating FastAPI TestClient integration tests that validate the full PMS workflow end-to-end.

Purpose: Complete the 20+ endpoint PMS API surface and prove it works via automated tests. This makes the PMS API ready for frontend consumption (Phases 23-26).

Output: src/api/routes/pms_journal.py (4 endpoints), updated src/api/main.py (3 router registrations + 3 Swagger tags), tests/test_pms/test_pms_api.py (8+ integration tests)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-trade-workflow-pms-api/21-01-PLAN.md
@.planning/phases/21-trade-workflow-pms-api/21-02-PLAN.md
@src/api/main.py
@src/api/routes/pms_portfolio.py
@src/api/routes/pms_trades.py
@src/api/schemas/pms_schemas.py
@src/pms/trade_workflow.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PMS Journal router and register all PMS routers in main.py</name>
  <files>src/api/routes/pms_journal.py, src/api/main.py</files>
  <action>
**Step 1: Create src/api/routes/pms_journal.py**

Router with prefix="/pms/journal", tags=["PMS - Decision Journal"]:

Use same `_get_workflow()` lazy singleton pattern as pms_portfolio.py and pms_trades.py.

Endpoints:

1. **GET /** -> list[JournalEntryResponse]
   - Query params: entry_type (optional, filter by OPEN/CLOSE/REJECT/MODIFY/NOTE/SYSTEM_EVENT), position_id (optional int), instrument (optional str), start_date (optional date), end_date (optional date), limit (optional int, default 50), offset (optional int, default 0)
   - Read from `_get_workflow().position_manager._journal`
   - Apply filters: entry_type match, position_id match, instrument match, created_at date range
   - Apply pagination: sort by created_at descending, slice [offset:offset+limit]
   - Return filtered and paginated journal entries

2. **GET /{entry_id}** -> JournalEntryResponse
   - Find journal entry by id in position_manager._journal
   - Return full entry with context snapshots (market_snapshot, portfolio_snapshot)
   - HTTPException 404 if not found

3. **POST /{entry_id}/outcome** (body: OutcomeRequest) -> JournalEntryResponse
   - Find journal entry by id
   - Create a NEW NOTE-type journal entry that references the same position_id
   - The new entry has: entry_type="NOTE", manager_notes=outcome_notes, system_notes=f"Outcome assessment for entry #{entry_id}: {realized_pnl_assessment}", content_hash computed
   - Do NOT modify the original locked entry -- create a linked NOTE instead
   - HTTPException 404 if original entry not found

4. **GET /stats/decision-analysis** -> dict
   - Compute statistics from all journal entries:
     ```python
     {
         "total_entries": len(journal),
         "by_type": {"OPEN": N, "CLOSE": N, "REJECT": N, ...},
         "approval_rate": approved / (approved + rejected) if (approved + rejected) > 0 else 0.0,
         "avg_holding_days": avg days between OPEN and CLOSE for same position_id,
         "total_positions_opened": count of OPEN entries,
         "total_positions_closed": count of CLOSE entries,
         "total_rejections": count of REJECT entries,
     }
     ```
   - Return computed stats dict

**Step 2: Update src/api/main.py**

Add 3 PMS router registrations and 3 Swagger tags:

1. Add imports at the top (after existing route imports):
   ```python
   from src.api.routes.pms_portfolio import router as pms_portfolio_router
   from src.api.routes.pms_trades import router as pms_trades_router
   from src.api.routes.pms_journal import router as pms_journal_router
   ```

2. Add 3 new entries to `openapi_tags` list:
   ```python
   {"name": "PMS - Portfolio", "description": "Portfolio positions, P&L, and book management"},
   {"name": "PMS - Trade Blotter", "description": "Trade proposals and approval workflow"},
   {"name": "PMS - Decision Journal", "description": "Immutable decision audit log"},
   ```

3. Add router includes (before the dashboard router, after existing routers):
   ```python
   # PMS v4.0 endpoints
   app.include_router(pms_portfolio_router, prefix="/api/v1")
   app.include_router(pms_trades_router, prefix="/api/v1")
   app.include_router(pms_journal_router, prefix="/api/v1")
   ```

Keep the noop lifespan pattern from Phase 19 for test compatibility -- do NOT change the existing lifespan function.
  </action>
  <verify>cd /home/user/Macro_Trading && python -c "
from src.api.routes.pms_journal import router
print(f'Journal routes: {len(router.routes)}')
from src.api.main import app
routes = [r.path for r in app.routes if hasattr(r, 'path')]
pms_routes = [r for r in routes if '/pms' in r]
print(f'PMS routes in app: {len(pms_routes)}')
for r in sorted(pms_routes):
    print(f'  {r}')
"</verify>
  <done>
    - src/api/routes/pms_journal.py has 4 endpoints (list, detail, outcome, stats)
    - main.py includes all 3 PMS routers with /api/v1 prefix
    - openapi_tags includes PMS - Portfolio, PMS - Trade Blotter, PMS - Decision Journal
    - 20+ PMS routes visible in the FastAPI app
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI TestClient integration tests for the full PMS API workflow</name>
  <files>tests/test_pms/test_pms_api.py</files>
  <action>
Create `tests/test_pms/test_pms_api.py` with FastAPI TestClient integration tests.

**CRITICAL: Follow the noop lifespan pattern from Phase 19 (tests/test_api_integration.py)**
The tests must work WITHOUT a database. Use the Starlette TestClient approach:

```python
from starlette.testclient import TestClient
```

But instead of importing the real app (which triggers DB lifespan), create a test app:

```python
import pytest
from datetime import date
from fastapi import FastAPI
from fastapi.testclient import TestClient

# Create a minimal test app with just PMS routers (no DB lifespan)
from src.api.routes.pms_portfolio import router as pms_portfolio_router
from src.api.routes.pms_trades import router as pms_trades_router
from src.api.routes.pms_journal import router as pms_journal_router

def _create_test_app() -> FastAPI:
    """Create minimal FastAPI app with PMS routers only (no DB)."""
    app = FastAPI(title="PMS Test")
    app.include_router(pms_portfolio_router, prefix="/api/v1")
    app.include_router(pms_trades_router, prefix="/api/v1")
    app.include_router(pms_journal_router, prefix="/api/v1")
    return app

@pytest.fixture
def client():
    """Fresh TestClient with reset PMS state for each test."""
    # Reset the module-level workflow singleton between tests
    import src.api.routes.pms_portfolio as pms_mod
    import src.api.routes.pms_trades as trades_mod
    import src.api.routes.pms_journal as journal_mod

    # Create fresh workflow for isolation
    from src.pms import TradeWorkflowService
    fresh_workflow = TradeWorkflowService()

    pms_mod._workflow = fresh_workflow
    trades_mod._workflow = fresh_workflow
    journal_mod._workflow = fresh_workflow

    app = _create_test_app()
    with TestClient(app) as c:
        yield c

    # Cleanup
    pms_mod._workflow = None
    trades_mod._workflow = None
    journal_mod._workflow = None
```

**Tests (8+ integration tests):**

1. **test_get_book_empty** -- GET /api/v1/pms/book returns empty book with 0 positions
2. **test_open_discretionary_position** -- POST /api/v1/pms/book/positions/open with valid body returns 200, position in response
3. **test_open_position_validation_error** -- POST /api/v1/pms/book/positions/open with missing manager_thesis returns 422
4. **test_generate_and_list_proposals** -- POST /api/v1/pms/trades/proposals/generate with sample signals, then GET /api/v1/pms/trades/proposals returns them
5. **test_approve_proposal_flow** -- Generate proposal, then POST approve, verify position created, check GET /api/v1/pms/book shows position
6. **test_reject_proposal_flow** -- Generate proposal, then POST reject with notes, verify status=REJECTED
7. **test_reject_without_notes_fails** -- POST reject with notes too short returns 422
8. **test_close_position_flow** -- Open position, close it, verify realized P&L in response
9. **test_journal_entries** -- Open position, close it, GET /api/v1/pms/journal/ shows OPEN and CLOSE entries
10. **test_journal_stats** -- After several operations, GET /api/v1/pms/journal/stats/decision-analysis returns correct counts
11. **test_pnl_summary** -- After opening and MTM, GET /api/v1/pms/pnl/summary returns summary dict
12. **test_mtm_endpoint** -- POST /api/v1/pms/book/mtm updates positions

Each test uses the `client` fixture for isolation. Sample signal data for proposals:
```python
SAMPLE_SIGNALS = [
    {"instrument": "DI1_F27", "asset_class": "RATES", "direction": "LONG", "conviction": 0.75, "strategy_ids": ["RATES-01"], "signal_source": "aggregator"},
    {"instrument": "USDBRL", "asset_class": "FX", "direction": "SHORT", "conviction": 0.60, "strategy_ids": ["FX-01"], "signal_source": "aggregator"},
]
```
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_pms/test_pms_api.py -v --tb=short 2>&1 | tail -30</verify>
  <done>
    - 12+ integration tests pass in tests/test_pms/test_pms_api.py
    - Tests cover: empty book, open position, validation errors, proposal generation, approve/reject/modify, close, journal listing, journal stats, P&L summary, MTM
    - All tests use TestClient with in-memory PMS state (no DB)
    - Each test starts with clean state via fixture
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_pms/test_pms_api.py -v` -- all 12+ tests pass
2. `python -m pytest tests/test_pms/ -v` -- all PMS tests pass (workflow + models + API)
3. `python -c "from src.api.main import app; routes = [r.path for r in app.routes if hasattr(r, 'path')]; pms = [r for r in routes if '/pms' in r]; print(f'{len(pms)} PMS routes')"` -- shows 20+ PMS routes
4. Swagger tags include PMS - Portfolio, PMS - Trade Blotter, PMS - Decision Journal
</verification>

<success_criteria>
- 4 journal endpoints working with filtering, pagination, outcome recording, and decision statistics
- All 3 PMS routers registered in main.py with /api/v1 prefix
- 3 PMS Swagger tag groups visible
- 12+ FastAPI integration tests pass without DB dependency
- Total PMS route count: 20+ endpoints across 3 routers
</success_criteria>

<output>
After completion, create `.planning/phases/21-trade-workflow-pms-api/21-03-SUMMARY.md`
</output>
