---
phase: 21-trade-workflow-pms-api
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - src/pms/trade_workflow.py
  - tests/test_pms/test_trade_workflow.py
autonomous: true
requirements: [PMS-TW-01, PMS-TW-02, PMS-TW-03, PMS-TW-04, PMS-TW-05]

must_haves:
  truths:
    - "TradeWorkflowService.generate_proposals_from_signals() converts aggregated signals with conviction > 0.55 into proposal dicts with risk impact estimates and LLM-generated rationale (template fallback)"
    - "Manager can approve a proposal (with execution_price and execution_notional_brl), reject a proposal (with mandatory notes), or modify-and-approve a proposal -- each action creates an immutable DecisionJournal entry"
    - "Manager can open a discretionary trade via TradeWorkflowService.open_discretionary_trade() with mandatory manager_thesis field"
    - "Manager can close a position via TradeWorkflowService.close_position() with close_price, close_date, and optional notes"
    - "generate_proposals_from_signals enforces conviction_min=0.55, flip_threshold=0.60, max_proposals_per_day=5"
  artifacts:
    - path: "src/pms/trade_workflow.py"
      provides: "TradeWorkflowService with 9 methods"
      contains: "class TradeWorkflowService"
    - path: "tests/test_pms/test_trade_workflow.py"
      provides: "Comprehensive tests for all workflow methods"
      min_lines: 200
  key_links:
    - from: "src/pms/trade_workflow.py"
      to: "src/pms/position_manager.py"
      via: "PositionManager instance passed to __init__"
      pattern: "self\\.position_manager"
    - from: "src/pms/trade_workflow.py"
      to: "src/pms/trade_workflow.py"
      via: "_generate_trade_rationale uses template fallback when no Anthropic API key"
      pattern: "_generate_trade_rationale"
---

<objective>
Build the TradeWorkflowService that converts aggregated signals into trade proposals, provides a human-in-the-loop approval/reject/modify workflow, supports manager-initiated discretionary trades, and logs all decisions immutably in the DecisionJournal.

Purpose: This is the core decision engine of the PMS -- it bridges the automated signal generation pipeline (v3.0) with human portfolio management, ensuring every trade decision is captured with full context for audit and performance review.

Output: src/pms/trade_workflow.py (TradeWorkflowService class) + tests/test_pms/test_trade_workflow.py (10+ tests)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-pms-database-position-manager/20-02-SUMMARY.md
@src/pms/position_manager.py
@src/pms/__init__.py
@tests/test_pms/test_position_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TradeWorkflowService with signal-to-proposal pipeline and approval workflow</name>
  <files>src/pms/trade_workflow.py, tests/test_pms/test_trade_workflow.py</files>
  <action>
Create `src/pms/trade_workflow.py` with `TradeWorkflowService` class. This class orchestrates the PositionManager (from Phase 20) and adds the trade proposal lifecycle on top.

**Constructor:**
```python
def __init__(self, position_manager: PositionManager | None = None):
```
- Accept optional PositionManager instance (default creates new one)
- Maintain in-memory `_proposals: list[dict]` store (same pattern as PositionManager._positions)
- No DB dependency -- all stores are lists of dicts

**Method 1: generate_proposals_from_signals(signals: list[dict], as_of_date: date | None = None) -> list[dict]**
- Input: list of aggregated signal dicts, each with keys: `instrument`, `asset_class`, `direction` (LONG/SHORT), `conviction` (float 0-1), `strategy_ids` (list[str]), `signal_source` (str)
- Filter: only signals with conviction >= 0.55 (conviction_min)
- If conviction >= 0.60 AND a current open position exists in opposite direction (same instrument), mark as "flip" signal with elevated priority
- Limit: max 5 proposals per call (max_proposals_per_day). Sort by conviction descending, take top 5
- For each passing signal, create a proposal dict:
  ```python
  proposal = {
      "id": next_id,
      "created_at": datetime.utcnow(),
      "updated_at": datetime.utcnow(),
      "instrument": signal["instrument"],
      "asset_class": signal["asset_class"],
      "direction": signal["direction"],
      "suggested_notional_brl": signal.get("suggested_notional_brl", 10_000_000.0),
      "conviction": signal["conviction"],
      "signal_source": signal.get("signal_source", "aggregator"),
      "strategy_ids": signal.get("strategy_ids", []),
      "rationale": self._generate_trade_rationale(signal),
      "risk_impact": self._estimate_portfolio_impact(signal),
      "status": "PENDING",
      "reviewed_by": None,
      "reviewed_at": None,
      "execution_price": None,
      "execution_notional_brl": None,
      "position_id": None,
      "notes": None,
  }
  ```
- Append each proposal to `self._proposals`
- Return list of created proposals

**Method 2: get_pending_proposals(as_of_date: date | None = None) -> list[dict]**
- Return all proposals with status=="PENDING", sorted by conviction descending
- Optional date filter (created_at date matches as_of_date)

**Method 3: approve_proposal(proposal_id: int, execution_price: float, execution_notional_brl: float, manager_notes: str | None = None, manager_thesis: str | None = None, target_price: float | None = None, stop_loss: float | None = None, time_horizon: str | None = None) -> dict**
- Find proposal by id, raise ValueError if not found or not PENDING
- Update proposal: status="APPROVED", execution_price, execution_notional_brl, reviewed_at, notes=manager_notes
- Call self.position_manager.open_position() with the proposal data (instrument, asset_class, direction, execution_notional_brl, execution_price, entry_date=today)
- Store position_id on the proposal from the returned position
- Create journal entry via position_manager (already auto-created by open_position), but ALSO add proposal_id to the journal entry. Achieve this by: after open_position returns, find the last journal entry in position_manager._journal and update its proposal_id field.
- Store target_price, stop_loss, time_horizon in proposal's metadata_json dict if provided
- Return updated proposal dict

**Method 4: reject_proposal(proposal_id: int, manager_notes: str) -> dict**
- Find proposal by id, raise ValueError if not found or not PENDING
- manager_notes is MANDATORY (raise ValueError if empty/None)
- Update proposal: status="REJECTED", reviewed_at=now, notes=manager_notes
- Create a REJECT journal entry in self.position_manager._journal with entry_type="REJECT", instrument, direction, manager_notes, content_hash (use PositionManager._compute_content_hash)
- Return updated proposal

**Method 5: modify_and_approve_proposal(proposal_id: int, modified_direction: str | None = None, modified_notional_brl: float | None = None, execution_price: float | None = None, manager_notes: str | None = None, **kwargs) -> dict**
- Find proposal by id, raise ValueError if not found or not PENDING
- Override proposal fields if provided (direction, notional, execution_price)
- Set status="MODIFIED"
- Open position via position_manager with the modified values
- Link position_id and proposal_id as in approve_proposal
- Return updated proposal

**Method 6: open_discretionary_trade(instrument: str, asset_class: str, direction: str, notional_brl: float, execution_price: float, entry_date: date, manager_thesis: str, target_price: float | None = None, stop_loss: float | None = None, time_horizon: str | None = None, strategy_ids: list[str] | None = None) -> dict**
- manager_thesis is MANDATORY (raise ValueError if empty/None)
- Create a proposal with status="APPROVED" and signal_source="DISCRETIONARY"
- Call position_manager.open_position() with notes=manager_thesis
- Create both proposal dict and position, link them
- Return dict with both proposal and position data

**Method 7: close_position(position_id: int, close_price: float, close_date: date | datetime | None = None, manager_notes: str | None = None, outcome_notes: str | None = None) -> dict**
- Delegate to self.position_manager.close_position()
- If outcome_notes provided, create an additional NOTE journal entry recording the outcome assessment
- Return the closed position dict

**Method 8: _estimate_portfolio_impact(signal: dict) -> dict**
- Compute simple pre-trade analytics:
  ```python
  {
      "estimated_leverage_delta": signal.get("suggested_notional_brl", 10_000_000.0) / self.position_manager.aum,
      "current_open_positions": len([p for p in self.position_manager._positions if p["is_open"]]),
      "same_instrument_exposure": sum(p["notional_brl"] for p in self.position_manager._positions if p["is_open"] and p["instrument"] == signal["instrument"]),
      "asset_class_concentration": sum(p["notional_brl"] for p in self.position_manager._positions if p["is_open"] and p["asset_class"] == signal["asset_class"]) / self.position_manager.aum if self.position_manager.aum > 0 else 0.0,
  }
  ```

**Method 9: _generate_trade_rationale(signal: dict) -> str**
- Template-based fallback (always available, no LLM dependency):
  ```python
  f"Signal-generated {signal['direction']} proposal for {signal['instrument']} ({signal['asset_class']}) with {signal['conviction']:.0%} conviction from {signal.get('signal_source', 'aggregator')}. Strategies: {', '.join(signal.get('strategy_ids', []))}."
  ```
- If `ANTHROPIC_API_KEY` env var is set, attempt LLM narrative generation via httpx POST to Claude API. On any failure (timeout, HTTP error, missing key), fall back to template. Wrap in try/except.
- Use the same LLM pattern as Phase 16 (NarrativeGenerator): dictionary-based as primary, LLM as enhancement. Here the template IS the primary, LLM is optional enhancement.

**Tests (tests/test_pms/test_trade_workflow.py):**

Create 12+ tests, all using in-memory TradeWorkflowService (no DB):

1. `test_generate_proposals_filters_low_conviction` -- signals with conviction < 0.55 are excluded
2. `test_generate_proposals_respects_max_limit` -- max 5 proposals even with 8 qualifying signals
3. `test_generate_proposals_sorts_by_conviction` -- highest conviction first
4. `test_generate_proposals_creates_rationale_and_risk_impact` -- each proposal has non-empty rationale and risk_impact dict
5. `test_approve_proposal_creates_position` -- approve returns proposal with position_id set, and position exists in position_manager
6. `test_approve_proposal_not_pending_raises` -- approving already-approved proposal raises ValueError
7. `test_reject_proposal_requires_notes` -- reject with empty notes raises ValueError
8. `test_reject_proposal_creates_journal_entry` -- reject creates REJECT journal entry
9. `test_modify_and_approve_overrides_direction` -- modify changes direction before opening position
10. `test_open_discretionary_trade_requires_thesis` -- empty thesis raises ValueError
11. `test_open_discretionary_trade_creates_position_and_proposal` -- creates both with DISCRETIONARY source
12. `test_close_position_delegates_to_pm` -- close returns position with realized P&L
13. `test_close_position_with_outcome_notes` -- outcome_notes creates additional NOTE journal entry
14. `test_flip_signal_detection` -- signal with conviction >= 0.60 against existing opposite position is detected

All tests use pytest fixtures with fresh TradeWorkflowService instances. Follow the pattern from tests/test_pms/test_position_manager.py (import style, fixture approach, assertion style).
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_pms/test_trade_workflow.py -v --tb=short 2>&1 | tail -30</verify>
  <done>
    - TradeWorkflowService class exists in src/pms/trade_workflow.py with all 9 methods
    - 12+ tests pass in tests/test_pms/test_trade_workflow.py
    - generate_proposals_from_signals filters conviction < 0.55, limits to 5, sorts by conviction desc
    - approve/reject/modify each update proposal status and create appropriate journal entries
    - Discretionary trade requires manager_thesis and creates DISCRETIONARY-sourced proposal + position
    - Template-based rationale always generated (no LLM dependency for tests)
    - All tests run without DB dependency (in-memory stores only)
  </done>
</task>

<task type="auto">
  <name>Task 2: Update src/pms/__init__.py to export TradeWorkflowService</name>
  <files>src/pms/__init__.py</files>
  <action>
Add TradeWorkflowService to the PMS package exports:

1. Add import: `from src.pms.trade_workflow import TradeWorkflowService`
2. Add to __all__: `"TradeWorkflowService"`
3. Update module docstring to mention TradeWorkflowService

Verify the import works: `python -c "from src.pms import TradeWorkflowService; print('OK')"`
  </action>
  <verify>cd /home/user/Macro_Trading && python -c "from src.pms import TradeWorkflowService; print('TradeWorkflowService imported OK')"</verify>
  <done>
    - `from src.pms import TradeWorkflowService` works
    - __all__ contains "TradeWorkflowService"
    - Existing PositionManager and MarkToMarketService imports still work
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_pms/test_trade_workflow.py -v` -- all 12+ tests pass
2. `python -m pytest tests/test_pms/ -v` -- all PMS tests pass (existing 48 + new 12+)
3. `python -c "from src.pms import TradeWorkflowService, PositionManager, MarkToMarketService"` -- all exports work
4. TradeWorkflowService uses in-memory stores only (no DB, no async)
</verification>

<success_criteria>
- TradeWorkflowService fully implements signal-to-proposal pipeline with conviction filtering, approval/reject/modify workflow, discretionary trades, and position closing
- All decisions create immutable journal entries with content hashes
- 12+ tests pass without any database dependency
- Package exports work cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/21-trade-workflow-pms-api/21-01-SUMMARY.md`
</output>
