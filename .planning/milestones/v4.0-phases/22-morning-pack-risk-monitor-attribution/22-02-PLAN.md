---
phase: 22-morning-pack-risk-monitor-attribution
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pms/risk_monitor.py
  - src/pms/risk_limits_config.py
  - tests/test_pms/test_risk_monitor.py
autonomous: true
requirements:
  - PMS-RM-01
  - PMS-RM-02
  - PMS-RM-03

must_haves:
  truths:
    - "RiskMonitorService.compute_live_risk() returns complete risk snapshot with VaR (parametric + MC placeholder), stress tests, limit utilization, concentration, and alerts"
    - "Two-tier alert severity: WARNING at 80% utilization, BREACH at 100% -- matching RiskLimitsManager check_all_v2 pattern"
    - "All existing limits from RiskLimitsManager v2 are surfaced: daily loss, weekly loss, position size, concentration, gross exposure, risk budget"
    - "30-day trend history for VaR, stress test results, and limit utilization stored and retrievable"
    - "Concentration breakdown by asset class with limit and utilization percentage"
    - "Risk data computed as daily snapshot, not real-time streaming"
  artifacts:
    - path: "src/pms/risk_monitor.py"
      provides: "RiskMonitorService with compute_live_risk(), get_risk_trend(), generate_alerts()"
      contains: "class RiskMonitorService"
    - path: "src/pms/risk_limits_config.py"
      provides: "PMSRiskLimits dataclass with VaR, leverage, drawdown, concentration limits"
      contains: "class PMSRiskLimits"
    - path: "tests/test_pms/test_risk_monitor.py"
      provides: "Tests for RiskMonitorService"
      contains: "test_live_risk_structure"
  key_links:
    - from: "src/pms/risk_monitor.py"
      to: "src/risk/risk_limits_v2.py"
      via: "RiskLimitsManager.check_all_v2()"
      pattern: "check_all_v2"
    - from: "src/pms/risk_monitor.py"
      to: "src/risk/var_calculator.py"
      via: "VaRCalculator.calculate()"
      pattern: "VaRCalculator"
    - from: "src/pms/risk_monitor.py"
      to: "src/risk/stress_tester.py"
      via: "StressTester.run_all()"
      pattern: "StressTester"
    - from: "src/pms/risk_monitor.py"
      to: "src/pms/position_manager.py"
      via: "PositionManager.get_book()"
      pattern: "get_book|_positions"
---

<objective>
Create RiskMonitorService and PMSRiskLimits -- the real-time risk dashboard backend that surfaces all risk metrics, limit utilization, concentration, stress tests, and historical trends for the portfolio manager.

Purpose: This service bridges the existing v3.0 risk infrastructure (VaRCalculator, StressTester, RiskLimitsManager) with the PMS position book to provide daily risk snapshots powering the Risk Monitor frontend page (Phase 25).

Output: `src/pms/risk_monitor.py`, `src/pms/risk_limits_config.py`, and test suite.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/pms/position_manager.py
@src/pms/__init__.py
@src/risk/risk_limits_v2.py
@src/risk/risk_limits.py
@src/risk/var_calculator.py
@src/risk/stress_tester.py
@src/risk/drawdown_manager.py
@tests/test_pms/test_position_manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PMSRiskLimits config and RiskMonitorService with daily risk snapshots, alerts, and 30-day trend</name>
  <files>src/pms/risk_limits_config.py, src/pms/risk_monitor.py, tests/test_pms/test_risk_monitor.py</files>
  <action>
**Part A: Create `src/pms/risk_limits_config.py`**

Simple frozen dataclass `PMSRiskLimits` with configurable limits (per PMS guide Etapa 6):

```python
@dataclass(frozen=True)
class PMSRiskLimits:
    # VaR limits (% of AUM, positive numbers)
    var_95_limit_pct: float = 2.0       # 2%
    var_99_limit_pct: float = 3.0       # 3%
    # Leverage
    gross_leverage_limit: float = 4.0   # 4x
    net_leverage_limit: float = 2.0     # 2x
    # Drawdown
    drawdown_warning_pct: float = 5.0   # -5% warning
    drawdown_limit_pct: float = 10.0    # -10% hard limit
    # Concentration by asset class (% of gross notional)
    concentration_limits: dict = field(default_factory=lambda: {
        "RATES": 60.0, "FX": 40.0, "INFLATION": 30.0,
        "SOVEREIGN": 20.0, "CREDIT": 20.0, "EQUITY": 30.0,
    })
    # Warning threshold (% of limit before breach)
    warning_threshold_pct: float = 80.0  # 80% = WARNING
```

Include `from_env()` classmethod that reads PMS_RISK_* env vars with defaults.

**Part B: Create `src/pms/risk_monitor.py` with class `RiskMonitorService`**

Constructor accepts optional components (graceful degradation pattern):
- `position_manager: PositionManager | None`
- `risk_limits_manager: RiskLimitsManager | None` -- from src.risk.risk_limits_v2
- `var_calculator: VaRCalculator | None` -- from src.risk.var_calculator
- `stress_tester: StressTester | None` -- from src.risk.stress_tester
- `pms_limits: PMSRiskLimits | None` -- defaults to PMSRiskLimits()
- Internal `_risk_snapshots: list[dict]` for 30-day trend history (deque maxlen=30)

**compute_live_risk(as_of_date: date = None) -> dict:**
Main method. Computes complete risk snapshot. Structure matches PMS guide Etapa 6:

```python
{
    "as_of_date": date,
    "var": {
        "parametric_95": float,    # VaR 95% as % of AUM
        "parametric_99": float,    # VaR 99%
        "monte_carlo_95": float | None,  # MC VaR if returns_matrix available
        "monte_carlo_99": float | None,
        "limit_95_pct": float,     # From PMSRiskLimits
        "limit_99_pct": float,
        "utilization_95_pct": float,  # var_95 / limit * 100
        "utilization_99_pct": float,
    },
    "leverage": {
        "gross": float,            # sum(abs(notional)) / AUM
        "net": float,              # (long_notional - short_notional) / AUM
        "limit_gross": float,
        "limit_net": float,
        "utilization_gross_pct": float,
        "utilization_net_pct": float,
    },
    "drawdown": {
        "current_drawdown_pct": float,  # From P&L history
        "max_drawdown_pct": float,      # Historical max
        "limit_pct": float,
        "warning_pct": float,
        "days_in_drawdown": int,
    },
    "concentration": {
        "by_asset_class": {
            "<AC>": {
                "notional_pct": float,   # % of gross notional
                "limit_pct": float,
                "utilization_pct": float,
                "status": "OK"|"WARNING"|"BREACHED",
            }
        },
        "top_3_positions_pct": float,
    },
    "stress_tests": [
        {
            "scenario": str,
            "pnl_brl": float,
            "pnl_pct": float,
            "description": str,
        }
    ],
    "limits_summary": {
        "overall_status": "OK"|"WARNING"|"BREACHED",
        "checks": [
            {
                "limit_name": str,
                "current_value": float,
                "limit_value": float,
                "utilization_pct": float,
                "status": "OK"|"WARNING"|"BREACHED",
            }
        ],
    },
    "alerts": [
        {
            "type": str,        # e.g. "VAR_WARNING", "CONCENTRATION_BREACH"
            "severity": str,    # "WARNING" or "BREACH" (2-tier per user decision)
            "message": str,
            "value": float,
            "limit": float,
        }
    ],
}
```

Implementation details:
- **VaR**: If position_manager has open positions, compute parametric VaR from synthetic returns (simple: use daily P&L snapshots from _pnl_history as portfolio returns). If fewer than 20 observations, return 0.0 with a note. MC VaR only if sufficient data (>= 30 obs).
- **Leverage**: Compute from position_manager.get_book() summary.
- **Drawdown**: Compute from cumulative P&L in _pnl_history. HWM = max equity, drawdown = (current - HWM) / AUM.
- **Concentration**: From get_book().by_asset_class, compute each AC's % of total gross notional. Apply PMSRiskLimits.concentration_limits.
- **Stress tests**: If stress_tester available, run all DEFAULT_SCENARIOS against current positions (build simple positions list for stress_tester.run_all). Else return empty list.
- **Limits**: If risk_limits_manager available, call check_all_v2() with portfolio_state dict built from book. Include loss tracking results.
- **Alerts**: Two-tier severity generator. Scan all metrics. At 80% utilization -> WARNING. At 100% -> BREACH. Categories: VAR_WARNING, VAR_BREACH, LEVERAGE_WARNING, LEVERAGE_BREACH, DRAWDOWN_WARNING, DRAWDOWN_BREACH, CONCENTRATION_WARNING, CONCENTRATION_BREACH, LOSS_DAILY_WARNING, LOSS_DAILY_BREACH.

Auto-persist: Append snapshot summary (date, var_95, leverage, drawdown, alert_count) to _risk_snapshots deque.

**get_risk_trend(days: int = 30) -> list[dict]:**
Return last N snapshots from _risk_snapshots for VaR, stress test, and limit utilization trend charts.

**generate_alerts(risk_data: dict) -> list[dict]:**
Extract alerts from a risk snapshot. Shared logic used by compute_live_risk.

**Tests** in `tests/test_pms/test_risk_monitor.py`:
- test_live_risk_structure: Create RiskMonitorService with PositionManager (open 2 positions, run MTM). Call compute_live_risk(). Verify all top-level keys present: var, leverage, drawdown, concentration, stress_tests, limits_summary, alerts.
- test_two_tier_alerts: Set up positions to create high leverage (e.g., notional = 3.5x AUM with limit 4.0). Verify WARNING alert generated (87.5% utilization). Increase to 4.5x -> verify BREACH alert.
- test_concentration_by_asset_class: Open 3 positions in same asset class (RATES) totaling 65% of gross. With concentration limit 60%, verify BREACHED status.
- test_30_day_trend: Call compute_live_risk() 3 times (different dates). Verify get_risk_trend(30) returns 3 entries with correct dates.
- test_graceful_degradation: Create RiskMonitorService with only position_manager (all others None). compute_live_risk() should return valid structure with stress_tests=[] and limits_summary from PMSRiskLimits defaults.

Same code style: `from __future__ import annotations`, structlog, frozen dataclass for config, type hints.
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_pms/test_risk_monitor.py -v</verify>
  <done>RiskMonitorService.compute_live_risk() returns complete risk snapshot with VaR, leverage, drawdown, concentration, stress tests, limit checks, and 2-tier alerts. 30-day trend history stored and retrievable. PMSRiskLimits config provides all limit thresholds. 5 tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /home/user/Macro_Trading
python -m pytest tests/test_pms/test_risk_monitor.py -v
python -c "from src.pms.risk_monitor import RiskMonitorService; print('RiskMonitorService imported OK')"
python -c "from src.pms.risk_limits_config import PMSRiskLimits; print('PMSRiskLimits imported OK')"
```
</verification>

<success_criteria>
- RiskMonitorService.compute_live_risk() returns structured dict matching the guide specification
- Two-tier alerts (WARNING at 80%, BREACH at 100%) work correctly for all limit types
- All existing RiskLimitsManager v2 limits surfaced (daily loss, weekly loss, position size, concentration, gross exposure, risk budget)
- 30-day trend history accumulates and is retrievable via get_risk_trend()
- Concentration breakdown by asset class computed with proper utilization percentages
- Graceful degradation when optional components are None
- All 5 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-morning-pack-risk-monitor-attribution/22-02-SUMMARY.md`
</output>
