---
phase: 20-pms-database-position-manager
plan: 02
type: tdd
wave: 2
depends_on:
  - 20-01
files_modified:
  - src/pms/__init__.py
  - src/pms/position_manager.py
  - src/pms/mtm_service.py
  - src/pms/pricing.py
  - tests/test_pms/test_position_manager.py
  - tests/test_pms/__init__.py
autonomous: true
requirements:
  - PMS-PM-01
  - PMS-PM-02
  - PMS-PM-03
  - PMS-PM-04
  - PMS-MTM-01
  - PMS-MTM-02

must_haves:
  truths:
    - "PositionManager.open_position() creates PortfolioPosition with risk metrics and auto-creates DecisionJournal entry"
    - "PositionManager.close_position() calculates realized P&L (BRL + USD), marks position closed, and logs journal"
    - "PositionManager.mark_to_market() updates all open positions with current prices using instrument-aware pricing and persists snapshots"
    - "PositionManager.get_book() returns structured dict with summary (AUM, leverage, P&L today/MTD/YTD), positions list, and by_asset_class breakdown"
    - "MarkToMarketService uses instrument-aware pricing (DI rate-to-PU, NTN-B yield-to-price, FX spot, CDS spread-to-price)"
    - "P&L computed in both BRL and USD with entry FX rate for entry value and current FX rate for current value"
  artifacts:
    - path: "src/pms/__init__.py"
      provides: "PMS package with exports"
      contains: "PositionManager"
    - path: "src/pms/position_manager.py"
      provides: "PositionManager with open/close/MTM/book"
      contains: "class PositionManager"
    - path: "src/pms/mtm_service.py"
      provides: "MarkToMarketService with price sourcing and VaR"
      contains: "class MarkToMarketService"
    - path: "src/pms/pricing.py"
      provides: "Instrument-aware pricing functions"
      contains: "def rate_to_pu"
    - path: "tests/test_pms/test_position_manager.py"
      provides: "Comprehensive PositionManager tests"
      contains: "test_open_position"
  key_links:
    - from: "src/pms/position_manager.py"
      to: "src/core/models/pms_models.py"
      via: "model imports"
      pattern: "from src.core.models.pms_models import"
    - from: "src/pms/position_manager.py"
      to: "src/pms/mtm_service.py"
      via: "service composition"
      pattern: "MarkToMarketService"
    - from: "src/pms/mtm_service.py"
      to: "src/pms/pricing.py"
      via: "pricing functions"
      pattern: "from .pricing import"
    - from: "src/pms/position_manager.py"
      to: "src/backtesting/costs.py"
      via: "TransactionCostModel reuse"
      pattern: "TransactionCostModel"
---

<objective>
Build the PositionManager service (open/close/MTM/book operations) and MarkToMarketService (instrument-aware pricing, VaR contribution) that form the core position lifecycle management for the PMS.

Purpose: Delivers the operational core of the PMS -- the ability to open positions with risk metrics, close them with realized P&L, mark-to-market daily with instrument-specific pricing (B3 DI PU convention, NTN-B real yield, FX spot, CDS spread), and view the portfolio book with P&L breakdown.
Output: src/pms/ package with PositionManager, MarkToMarketService, pricing module, comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-pms-database-position-manager/20-CONTEXT.md
@.planning/phases/20-pms-database-position-manager/20-01-SUMMARY.md
@src/core/models/pms_models.py
@src/backtesting/costs.py
@src/risk/var_calculator.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pricing module and MarkToMarketService</name>
  <files>src/pms/__init__.py, src/pms/pricing.py, src/pms/mtm_service.py</files>
  <action>
**Create `src/pms/__init__.py`**:
Package init exporting PositionManager, MarkToMarketService, and pricing functions.

**Create `src/pms/pricing.py`** -- Pure computation module with instrument-aware pricing functions (no DB/IO). All functions are stateless.

1. `rate_to_pu(rate_pct: float, business_days: int) -> float`:
   B3 DI futures convention: `PU = 100_000 / (1 + rate_pct / 100) ** (business_days / 252)`
   Returns preço unitário (PU) from annual rate in percent.

2. `pu_to_rate(pu: float, business_days: int) -> float`:
   Inverse: `rate_pct = ((100_000 / pu) ** (252 / business_days) - 1) * 100`

3. `compute_dv01_from_pu(pu: float, rate_pct: float, business_days: int, notional_brl: float) -> float`:
   DV01 = change in PU for 1bp rate move * (notional / 100_000).
   Compute PU at rate and PU at (rate + 0.01), difference * contracts.
   `dv01 = abs(rate_to_pu(rate_pct + 0.01, business_days) - pu) * (notional_brl / 100_000)`

4. `ntnb_yield_to_price(real_yield_pct: float, coupon_rate: float, years_to_maturity: float) -> float`:
   Simplified NTN-B pricing: present value of semi-annual coupons + par, discounted at real yield.
   Semi-annual coupon = (1 + coupon_rate/100)^0.5 - 1 per period.
   Price per 1000 face = sum of discounted cashflows.

5. `cds_spread_to_price(spread_bps: float, recovery_rate: float, years: float, risk_free_rate: float) -> float`:
   Simplified CDS mark-to-market: risky annuity * (spread - par_spread). For MTM tracking, return spread_bps directly as the "price" (CDS is spread-quoted). The P&L comes from spread changes.

6. `compute_fx_delta(notional_brl: float, spot_rate: float) -> float`:
   FX delta = notional_brl / spot_rate (USD equivalent exposure).

7. `compute_pnl_brl(entry_price: float, current_price: float, notional_brl: float, direction: str, instrument: str, asset_class: str) -> float`:
   Instrument-aware P&L:
   - For RATES (DI): P&L = (current_pu - entry_pu) * quantity. Both prices are already PU. direction LONG = receive fixed (benefit from PU increase), SHORT = pay fixed.
   - For FX: P&L = notional_brl * (current_price / entry_price - 1) * direction_sign
   - For general: P&L = notional_brl * (current_price / entry_price - 1) * direction_sign
   direction_sign = +1 for LONG, -1 for SHORT.

8. `compute_pnl_usd(pnl_brl: float, current_fx_rate: float) -> float`:
   Simple conversion: `pnl_brl / current_fx_rate` if rate > 0, else 0.0.

**Create `src/pms/mtm_service.py`** -- MarkToMarketService class.

```python
class MarkToMarketService:
    """Service for mark-to-market pricing of portfolio positions.

    Handles instrument-aware price sourcing from DB with manual override support,
    staleness detection, and risk metric computation (DV01, delta, VaR contribution).
    """

    STALE_THRESHOLD_DAYS = 3  # Alert if price older than this

    def __init__(self, cost_model: TransactionCostModel | None = None):
        self.cost_model = cost_model or TransactionCostModel()

    def get_prices_for_positions(
        self,
        positions: list[dict],
        price_overrides: dict[str, float] | None = None,
        as_of_date: date | None = None,
    ) -> dict[str, dict]:
        """Get current prices for a list of positions.

        Returns dict keyed by instrument with:
        {price: float, source: str, date: date, is_stale: bool, staleness_days: int}

        Price resolution order:
        1. Manual override (if provided in price_overrides)
        2. DB lookup (placeholder -- returns entry_price as fallback in v4.0-P20)
        3. Carry-forward last known price with staleness alert

        Note: Actual DB price lookup will be wired in Phase 21/27 when MTM
        pipeline runs against live TimescaleDB. For now, uses entry_price
        or override as price source.
        """

    def compute_position_mtm(
        self,
        position: dict,
        current_price: float,
        current_fx_rate: float | None = None,
    ) -> dict:
        """Compute MTM for a single position.

        Returns dict with:
        - unrealized_pnl_brl, unrealized_pnl_usd
        - daily_pnl_brl, daily_pnl_usd (vs previous mark)
        - current_dv01 (for rates), current_delta (for FX)
        - mark_price, fx_rate
        """

    def compute_dv01(
        self,
        instrument: str,
        rate_pct: float,
        business_days: int,
        notional_brl: float,
    ) -> float:
        """Compute DV01 for a rates instrument. Delegates to pricing.compute_dv01_from_pu."""

    def compute_var_contributions(
        self,
        positions: list[dict],
        total_var: float | None = None,
    ) -> dict[str, float]:
        """Compute per-position VaR contribution.

        If total_var not provided, uses a simplified proportional allocation
        based on position notional weights. Full Component VaR from Phase 17
        risk engine will be integrated in Phase 22.

        Returns dict of {position_id: var_contribution}.
        """
```

Import TransactionCostModel from `src.backtesting.costs`. Use structlog for logging.
  </action>
  <verify>
Run: `python -c "from src.pms import MarkToMarketService; from src.pms.pricing import rate_to_pu, pu_to_rate, compute_dv01_from_pu; print('PMS pricing imports OK')"` succeeds. Verify rate_to_pu(10.0, 252) returns approximately 90909.09 (100000 / 1.10).
  </verify>
  <done>
src/pms/ package created with pricing.py (8 pure functions for instrument-aware pricing following B3 conventions) and mtm_service.py (MarkToMarketService with price sourcing, MTM computation, DV01 calculation, and VaR contribution allocation).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create PositionManager service with open/close/MTM/book and comprehensive tests</name>
  <files>src/pms/position_manager.py, tests/test_pms/__init__.py, tests/test_pms/test_position_manager.py</files>
  <action>
**Create `src/pms/position_manager.py`** -- The core PMS service managing the full position lifecycle.

```python
import hashlib
import json
from datetime import date, datetime
from typing import Any

import structlog

from src.backtesting.costs import TransactionCostModel
from src.core.models.pms_models import (
    DecisionJournal,
    PortfolioPosition,
    PositionPnLHistory,
)
from src.pms.mtm_service import MarkToMarketService
from src.pms.pricing import (
    compute_dv01_from_pu,
    compute_fx_delta,
    compute_pnl_brl,
    compute_pnl_usd,
    rate_to_pu,
)

logger = structlog.get_logger(__name__)


class PositionManager:
    """Core position management service for the Portfolio Management System.

    Manages position lifecycle: open, close, mark-to-market, and book reporting.
    All position changes are journaled automatically in the DecisionJournal.

    This class operates on dicts representing positions (not ORM objects directly)
    to decouple from SQLAlchemy sessions. The caller (API layer or Dagster pipeline)
    is responsible for session management and persistence.
    """

    def __init__(
        self,
        mtm_service: MarkToMarketService | None = None,
        cost_model: TransactionCostModel | None = None,
        aum: float = 100_000_000.0,  # Default 100M BRL AUM
    ):
        self.mtm_service = mtm_service or MarkToMarketService()
        self.cost_model = cost_model or TransactionCostModel()
        self.aum = aum
        self._positions: list[dict] = []  # In-memory position store (DB wiring in Phase 21)
        self._journal: list[dict] = []    # In-memory journal store
        self._pnl_history: list[dict] = [] # In-memory P&L snapshots
```

**Methods to implement:**

1. **`open_position(self, instrument, asset_class, direction, notional_brl, entry_price, entry_date=None, quantity=None, entry_fx_rate=None, strategy_ids=None, strategy_weights=None, notes=None, rate_pct=None, business_days=None, **kwargs) -> dict`**:
   - Creates position dict with all fields from PortfolioPosition
   - Assigns auto-increment id (len(self._positions) + 1)
   - Computes risk metrics at entry:
     - If asset_class == "RATES" and rate_pct provided: compute entry_dv01 via compute_dv01_from_pu, entry PU via rate_to_pu
     - If asset_class == "FX": compute entry_delta via compute_fx_delta
     - Store entry_convexity, entry_var_contribution, entry_spread_duration from kwargs if provided
   - Computes transaction cost via self.cost_model.get_cost(instrument, notional_brl)
   - Creates DecisionJournal entry dict:
     - entry_type="OPEN"
     - Populates market_snapshot and portfolio_snapshot (pass as kwargs or generate placeholder)
     - Computes content_hash = SHA256 of JSON-serialized content fields (entry_type, instrument, direction, notional_brl, entry_price, manager_notes, system_notes)
   - Appends position to self._positions, journal entry to self._journal
   - Returns complete position dict

2. **`close_position(self, position_id: int, close_price: float, close_date: datetime | None = None, current_fx_rate: float | None = None, notes: str | None = None) -> dict`**:
   - Finds position by id in self._positions (raise ValueError if not found or already closed)
   - Calculates realized P&L:
     - realized_pnl_brl = compute_pnl_brl(entry_price, close_price, notional_brl, direction, instrument, asset_class)
     - realized_pnl_usd = compute_pnl_usd(realized_pnl_brl, current_fx_rate or entry_fx_rate or 5.0)
   - Subtracts transaction cost (exit cost)
   - Sets is_open=False, closed_at=close_date or now, close_price
   - Creates CLOSE journal entry with content_hash, includes realized P&L in system_notes
   - Returns updated position dict

3. **`mark_to_market(self, price_overrides: dict[str, float] | None = None, current_fx_rate: float | None = None, as_of_date: date | None = None, persist_snapshot: bool = True) -> list[dict]`**:
   - Gets all open positions (is_open=True)
   - Uses self.mtm_service.get_prices_for_positions for prices
   - For each open position:
     - Get price (override or DB or carry-forward)
     - Compute unrealized_pnl_brl and unrealized_pnl_usd via pricing functions
     - If RATES: recompute DV01 at current rate
     - If FX: recompute delta at current spot
     - Update position dict with new marks
   - If persist_snapshot: create PositionPnLHistory dict for each position (snapshot_date, mark_price, pnl values)
   - Append snapshots to self._pnl_history
   - Return list of MTM'd position dicts

4. **`get_book(self, as_of_date: date | None = None) -> dict`**:
   Returns structured book dict:
   ```python
   {
       "summary": {
           "aum": float,
           "total_notional_brl": float,
           "leverage": float,  # total_notional / aum
           "open_positions": int,
           "pnl_today_brl": float,
           "pnl_mtd_brl": float,
           "pnl_ytd_brl": float,
           "pnl_today_usd": float,
           "pnl_mtd_usd": float,
           "pnl_ytd_usd": float,
           "total_unrealized_pnl_brl": float,
           "total_realized_pnl_brl": float,
       },
       "positions": [...],  # list of open position dicts
       "by_asset_class": {
           "RATES": {"count": int, "notional_brl": float, "unrealized_pnl_brl": float},
           "FX": {...},
           ...
       },
       "closed_today": [...],  # positions closed on as_of_date
   }
   ```
   - leverage = sum of abs(notional_brl) of open positions / AUM
   - P&L today = sum of daily_pnl from latest MTM (from _pnl_history for today)
   - P&L MTD/YTD computed from _pnl_history entries in the relevant period
   - by_asset_class groups open positions and sums notional/pnl per group

5. **`get_pnl_timeseries(self, position_id: int | None = None, start_date: date | None = None, end_date: date | None = None) -> list[dict]`**:
   - Returns P&L history from self._pnl_history filtered by position_id and date range
   - If position_id is None, returns portfolio-level daily P&L (aggregated across positions)

6. **`_compute_content_hash(self, **fields) -> str`** (private helper):
   - Serialize fields to JSON (sorted keys, default=str for datetime)
   - Return hashlib.sha256(json_bytes).hexdigest()

**Create `tests/test_pms/__init__.py`** (empty).

**Create `tests/test_pms/test_position_manager.py`** with comprehensive tests:

TDD approach -- write tests first, then verify implementation passes.

```python
# Test categories:

# --- open_position tests ---
# test_open_position_basic: open a RATES position, verify returned dict has all required fields
# test_open_position_creates_journal_entry: verify journal entry created with OPEN type
# test_open_position_computes_dv01_for_rates: provide rate_pct + business_days, verify entry_dv01 > 0
# test_open_position_computes_delta_for_fx: FX position, verify entry_delta computed
# test_open_position_dual_notional: provide entry_fx_rate, verify notional_usd = notional_brl / fx_rate
# test_open_position_records_transaction_cost: verify transaction_cost_brl > 0
# test_open_position_content_hash: verify journal entry has valid SHA256 hex (64 chars)
# test_open_position_strategy_attribution: pass strategy_ids and strategy_weights, verify stored

# --- close_position tests ---
# test_close_position_basic: close an open position, verify is_open=False
# test_close_position_realized_pnl_long: LONG position, close higher -> positive P&L
# test_close_position_realized_pnl_short: SHORT position, close lower -> positive P&L
# test_close_position_creates_journal: verify CLOSE journal entry created
# test_close_position_not_found: raise ValueError for non-existent id
# test_close_position_already_closed: raise ValueError for already closed position
# test_close_position_pnl_usd: verify USD P&L computed when fx_rate provided

# --- mark_to_market tests ---
# test_mtm_updates_open_positions: open 2 positions, MTM with price overrides, verify updated
# test_mtm_creates_pnl_snapshot: verify _pnl_history has entries after MTM
# test_mtm_skips_closed_positions: close one, MTM, verify only open ones updated
# test_mtm_with_manual_override: pass price_overrides, verify override price used
# test_mtm_rate_position_dv01_recomputed: rates position gets DV01 updated

# --- get_book tests ---
# test_get_book_empty: no positions -> summary with zeros
# test_get_book_with_positions: open 3 positions across 2 asset classes, verify structure
# test_get_book_leverage_calculation: verify leverage = total_notional / aum
# test_get_book_by_asset_class_breakdown: verify grouping and sums
# test_get_book_closed_today: close a position, verify it appears in closed_today

# --- get_pnl_timeseries tests ---
# test_pnl_timeseries_single_position: MTM a position, get timeseries for it
# test_pnl_timeseries_portfolio_level: MTM multiple positions, get aggregate

# --- pricing module tests ---
# test_rate_to_pu_known_value: rate=10%, 252 days -> ~90909.09
# test_pu_to_rate_inverse: verify round-trip rate -> PU -> rate
# test_compute_dv01_positive: DV01 should be positive for any valid inputs
# test_compute_fx_delta: verify delta = notional / spot
# test_compute_pnl_brl_long_profit: long, price up -> positive P&L
# test_compute_pnl_brl_short_profit: short, price down -> positive P&L
```

All tests use pure in-memory PositionManager (no DB). Instantiate with default parameters.
  </action>
  <verify>
Run: `cd /home/user/Macro_Trading && python -m pytest tests/test_pms/test_position_manager.py -v` -- all tests pass. Run: `python -c "from src.pms import PositionManager; pm = PositionManager(); print('PositionManager instantiates OK')"` succeeds.
  </verify>
  <done>
PositionManager fully implements open_position (with risk metrics, journal, content hash), close_position (realized P&L in BRL+USD, journal), mark_to_market (instrument-aware pricing, DV01 recomputation, P&L snapshots), and get_book (AUM/leverage/P&L summary, positions list, by_asset_class breakdown). MarkToMarketService handles price sourcing with manual overrides and staleness detection. 30+ comprehensive tests pass covering all methods and edge cases.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.pms import PositionManager, MarkToMarketService"` succeeds
2. `python -c "from src.pms.pricing import rate_to_pu; assert abs(rate_to_pu(10.0, 252) - 90909.09) < 1.0"` passes
3. `python -m pytest tests/test_pms/ -v` all green (30+ tests)
4. PositionManager.open_position returns dict with entry_dv01 for RATES positions
5. PositionManager.close_position returns dict with realized_pnl_brl and realized_pnl_usd
6. PositionManager.mark_to_market returns list of updated position dicts with unrealized P&L
7. PositionManager.get_book returns dict with summary.leverage, summary.pnl_today_brl, positions, by_asset_class
8. DecisionJournal entries have valid SHA256 content_hash (64 hex chars)
9. TransactionCostModel from Phase 14 reused for cost computation
</verification>

<success_criteria>
- PositionManager with 4 core methods (open, close, MTM, book) plus get_pnl_timeseries
- MarkToMarketService with instrument-aware pricing and VaR contribution
- Pricing module with B3 DI PU convention (rate_to_pu, pu_to_rate, compute_dv01_from_pu)
- SHA256 content hash on all journal entries
- P&L in both BRL and USD throughout
- 30+ tests passing without DB dependency
</success_criteria>

<output>
After completion, create `.planning/phases/20-pms-database-position-manager/20-02-SUMMARY.md`
</output>
