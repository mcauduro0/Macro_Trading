---
phase: 14-backtesting-engine-v2-strategy-framework
plan: 02
type: execute
wave: 2
depends_on:
  - 14-01
files_modified:
  - src/backtesting/engine.py
  - src/backtesting/costs.py
  - src/backtesting/__init__.py
  - tests/test_backtesting_v2.py
autonomous: true
requirements:
  - BTST-01
  - BTST-02
  - BTST-04

must_haves:
  truths:
    - "User can call engine.run_portfolio(strategies, weights) and get a combined BacktestResult with per-strategy attribution"
    - "User can run walk-forward validation that splits period into train/test windows and reports out-of-sample performance"
    - "TransactionCostModel applies per-instrument costs for all 12 instruments (DI1, DDI, DOL, NDF, NTN-B, LTN, UST, ZN, ZF, ES, CDS_BR, IBOV_FUT)"
    - "Existing BacktestEngine.run(strategy) continues to work for single-strategy backtests"
  artifacts:
    - path: "src/backtesting/engine.py"
      provides: "BacktestEngine v2 with run_portfolio and walk_forward_validation methods"
      contains: "def run_portfolio"
    - path: "src/backtesting/costs.py"
      provides: "TransactionCostModel with COST_TABLE for 12 instruments"
      exports: ["TransactionCostModel"]
    - path: "tests/test_backtesting_v2.py"
      provides: "Tests for portfolio backtesting, walk-forward, and transaction costs"
      min_lines: 80
  key_links:
    - from: "src/backtesting/engine.py"
      to: "src/backtesting/costs.py"
      via: "BacktestEngine uses TransactionCostModel for per-instrument costs"
      pattern: "TransactionCostModel"
    - from: "src/backtesting/engine.py"
      to: "src/strategies/base.py"
      via: "run_portfolio accepts list of BaseStrategy instances"
      pattern: "BaseStrategy|StrategyProtocol"
    - from: "src/backtesting/engine.py"
      to: "src/backtesting/metrics.py"
      via: "compute_metrics called for each strategy and portfolio aggregate"
      pattern: "compute_metrics"
---

<objective>
BacktestEngine v2 with portfolio-level backtesting, walk-forward validation, and TransactionCostModel with per-instrument cost tables.

Purpose: Enable multi-strategy portfolio backtesting (run_portfolio) that aggregates multiple strategies with risk allocation, walk-forward validation to detect overfitting, and realistic transaction cost modeling with per-instrument cost schedules. This upgrades the existing single-strategy BacktestEngine to support portfolio-level analysis needed by Phase 15's 16 new strategies.

Output: Enhanced engine.py with run_portfolio and walk_forward_validation, new costs.py with TransactionCostModel, and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-backtesting-engine-v2-strategy-framework/14-01-SUMMARY.md
@src/backtesting/engine.py
@src/backtesting/metrics.py
@src/backtesting/portfolio.py
@src/backtesting/__init__.py
@src/strategies/base.py
@docs/GUIA_COMPLETO_CLAUDE_CODE_Fase2.md (lines 284-462 for Etapa 2 specs)
</context>

<tasks>

<task type="auto">
  <name>Task 1: TransactionCostModel and BacktestEngine v2 with run_portfolio and walk_forward_validation</name>
  <files>
    src/backtesting/costs.py
    src/backtesting/engine.py
    src/backtesting/portfolio.py
    src/backtesting/__init__.py
  </files>
  <action>
1. **Create src/backtesting/costs.py** (per BTST-04): TransactionCostModel class with per-instrument cost table.

   ```python
   class TransactionCostModel:
       COST_TABLE = {
           "DI1": {"spread": 0.5, "commission": 0.3, "exchange_fee": 0.2},
           "DDI": {"spread": 1.0, "commission": 0.3, "exchange_fee": 0.2},
           "DOL": {"spread": 0.3, "commission": 0.3, "exchange_fee": 0.2},
           "NDF": {"spread": 2.0, "commission": 0.0, "exchange_fee": 0.0},
           "NTN_B": {"spread": 3.0, "commission": 0.0, "exchange_fee": 0.0},
           "LTN": {"spread": 1.5, "commission": 0.0, "exchange_fee": 0.0},
           "UST": {"spread": 0.5, "commission": 0.1, "exchange_fee": 0.0},
           "ZN": {"spread": 0.3, "commission": 0.5, "exchange_fee": 0.3},
           "ZF": {"spread": 0.3, "commission": 0.5, "exchange_fee": 0.3},
           "ES": {"spread": 0.2, "commission": 0.5, "exchange_fee": 0.3},
           "CDS_BR": {"spread": 5.0, "commission": 0.0, "exchange_fee": 0.0},
           "IBOV_FUT": {"spread": 1.0, "commission": 0.3, "exchange_fee": 0.2},
       }
   ```

   Methods:
   - `get_cost_bps(instrument: str) -> float`: Returns sum of spread + commission + exchange_fee for instrument. If instrument not in COST_TABLE, match by prefix (e.g., "DI_PRE_365" matches "DI1" via a TICKER_MAPPING dict that maps common ticker prefixes to cost table keys: {"DI_PRE": "DI1", "DI1_": "DI1", "DDI_": "DDI", "DOL_": "DOL", "USDBRL": "NDF", "NTN_B": "NTN_B", "LTN_": "LTN", "UST_": "UST", etc.}). If still not found, return a default of 2.0 bps.
   - `get_cost(instrument: str, notional: float, is_entry: bool = True) -> float`: Returns cost in USD = abs(notional) * get_cost_bps(instrument) / 10_000.
   - `get_round_trip_bps(instrument: str) -> float`: Returns 2 * get_cost_bps(instrument).

2. **Enhance src/backtesting/engine.py** (per BTST-01 and BTST-02): Add run_portfolio and walk_forward_validation to BacktestEngine. Keep existing run() method untouched.

   Update BacktestConfig: Add new optional fields (defaults preserve backward compat):
   - `walk_forward: bool = False`
   - `walk_forward_train_months: int = 60`
   - `walk_forward_test_months: int = 12`
   - `funding_rate: float = 0.05`
   - `point_in_time: bool = True`
   - `cost_model: Optional[TransactionCostModel] = None` (field with default_factory would break frozen -- use Optional instead)

   NOTE: BacktestConfig is frozen=True, so use field(default=None) for cost_model. The cost_model can be passed separately or set in config.

   Add to BacktestEngine:
   - `run_portfolio(strategies: list, weights: dict[str, float] | None = None) -> dict`:
     a. If weights is None, equal-weight: {s.strategy_id: 1.0/len(strategies) for s in strategies}
     b. Run self.run(strategy) for each strategy individually, collecting BacktestResult per strategy
     c. Combine daily equity curves: for each date, portfolio_equity = sum(strategy_equity[date] * weight)
     d. Compute correlation matrix between strategy returns
     e. Build combined BacktestResult: Create a synthetic Portfolio from the combined equity curve daily returns, then use compute_metrics to produce the combined BacktestResult. Set total_trades = sum of individual total_trades, win_rate and profit_factor as weighted averages. Alternatively, if compute_metrics requires a Portfolio object, compute all metrics directly from the combined daily returns using numpy (mean, std, max_drawdown from cumulative returns, etc.).
     f. Return dict with keys: "portfolio_result" (BacktestResult for combined), "individual_results" (dict of strategy_id -> BacktestResult), "weights" (the weights used), "correlation_matrix" (dict of {(id_a, id_b): corr}), "attribution" (dict of strategy_id -> contribution_pct)

   - `walk_forward_validation(strategy, param_grid: dict[str, list] | None = None) -> list[dict]`:
     a. Generate windows: slide [train_start, train_end, test_start, test_end] across the full period. train_end = train_start + train_months, test_start = train_end, test_end = test_start + test_months. Advance by test_months each step.
     b. For each window: run backtest on train period (in-sample), run backtest on test period (out-of-sample)
     c. If param_grid provided: for each param combination, run train backtest, pick best Sharpe, use those params for test. If no param_grid: just run with current params on both periods.
     d. Return list of dicts, one per window: {"window": i, "train_start", "train_end", "test_start", "test_end", "in_sample_sharpe", "out_of_sample_sharpe", "in_sample_result": BacktestResult, "out_of_sample_result": BacktestResult, "params_used": dict}
     e. Log overfit ratio: mean(oos_sharpe) / mean(is_sharpe) -- ratio < 0.5 suggests overfitting

3. **Update src/backtesting/__init__.py**: Add TransactionCostModel to imports and __all__.
  </action>
  <verify>
    Run: `cd /home/user/Macro_Trading && python -c "
from src.backtesting import BacktestEngine, BacktestConfig, TransactionCostModel
from src.backtesting.costs import TransactionCostModel as TCM

# Verify TransactionCostModel
tcm = TCM()
assert tcm.get_cost_bps('DI1') == 1.0  # 0.5+0.3+0.2
assert tcm.get_cost_bps('DOL') == 0.8  # 0.3+0.3+0.2
assert tcm.get_cost_bps('CDS_BR') == 5.0
assert tcm.get_cost('DI1', 1_000_000) == 100.0  # 1M * 1.0/10000
assert len(TCM.COST_TABLE) == 12

# Verify BacktestConfig backward compat
cfg = BacktestConfig(start_date=None, end_date=None, initial_capital=1e6)
assert cfg.transaction_cost_bps == 5.0

# Verify new methods exist
engine = BacktestEngine(cfg, loader=None)
assert hasattr(engine, 'run_portfolio')
assert hasattr(engine, 'walk_forward_validation')
assert hasattr(engine, 'run')  # existing method preserved

print('ALL CHECKS PASSED')
"`
  </verify>
  <done>TransactionCostModel has COST_TABLE with 12 instruments and get_cost/get_cost_bps/get_round_trip_bps methods. BacktestEngine has run_portfolio for multi-strategy backtesting with weights, attribution, and correlation, and walk_forward_validation for train/test window splitting with overfit detection. Existing run() method unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Tests for BacktestEngine v2 portfolio backtesting, walk-forward, and TransactionCostModel</name>
  <files>
    tests/test_backtesting_v2.py
  </files>
  <action>
Create tests/test_backtesting_v2.py with comprehensive tests:

1. **TransactionCostModel tests**:
   - `test_cost_table_has_12_instruments`: Assert len(COST_TABLE) == 12, assert all 12 keys present.
   - `test_get_cost_bps_known_instrument`: DI1 -> 1.0, CDS_BR -> 5.0, ES -> 1.0.
   - `test_get_cost_bps_unknown_returns_default`: "UNKNOWN_TICKER" -> 2.0 (default).
   - `test_get_cost_bps_prefix_matching`: "DI_PRE_365" should match DI1 -> 1.0.
   - `test_get_cost_notional`: 1M notional on DI1 -> 100.0 USD.
   - `test_get_round_trip_bps`: DI1 -> 2.0 (2x one-way).

2. **BacktestEngine.run_portfolio tests** (use mock strategies):
   Create a MockStrategy class that implements the StrategyProtocol:
   ```python
   class MockStrategy:
       def __init__(self, strategy_id, fixed_weights):
           self.strategy_id = strategy_id
           self._weights = fixed_weights
       def generate_signals(self, as_of_date):
           return self._weights
   ```

   - `test_run_portfolio_equal_weights`: Create 2 mock strategies. Pass to run_portfolio without weights (should default to equal). Assert result dict has "portfolio_result", "individual_results", "weights", "correlation_matrix", "attribution". Assert weights are {id1: 0.5, id2: 0.5}.
   - `test_run_portfolio_custom_weights`: Pass weights={id1: 0.7, id2: 0.3}. Assert weights match.

   NOTE: Since run() requires a PointInTimeDataLoader, use `unittest.mock.MagicMock` for the loader. Mock `loader.get_market_data` to return a DataFrame with a "close" column. Use short date ranges (2 months) to keep tests fast.

3. **Walk-forward validation tests**:
   - `test_walk_forward_window_generation`: Test that with a 24-month period, train=12 months, test=6 months, we get the correct number of windows.
   - `test_walk_forward_returns_list_of_dicts`: Run walk_forward_validation with a MockStrategy. Assert result is a list, each element has required keys.

4. **BacktestConfig backward compat**:
   - `test_backtest_config_defaults`: Assert default values match v1 (transaction_cost_bps=5.0, slippage_bps=2.0).
   - `test_backtest_config_new_fields`: Assert walk_forward defaults to False, walk_forward_train_months=60.

Use `@pytest.fixture` for common setup (config, mock loader, mock strategies).
  </action>
  <verify>
    Run: `cd /home/user/Macro_Trading && python -m pytest tests/test_backtesting_v2.py -v --tb=short 2>&1 | tail -30`
  </verify>
  <done>All tests pass. TransactionCostModel tests verify 12-instrument cost table, prefix matching, and cost calculations. Portfolio backtest tests verify equal/custom weights, result structure. Walk-forward tests verify window generation and output format. BacktestConfig backward compatibility confirmed.</done>
</task>

</tasks>

<verification>
1. `python -c "from src.backtesting.costs import TransactionCostModel; print(len(TransactionCostModel.COST_TABLE))"` outputs 12
2. `python -c "from src.backtesting import BacktestEngine; print(hasattr(BacktestEngine, 'run_portfolio'))"` outputs True
3. `python -m pytest tests/test_backtesting_v2.py -v` -- all pass
4. Existing `python -m pytest tests/test_backtesting.py -v` still passes (no regressions)
</verification>

<success_criteria>
- BacktestEngine.run_portfolio accepts strategies + weights, returns combined result with attribution and correlation
- Walk-forward validation splits period into train/test windows, reports in-sample vs out-of-sample Sharpe, and logs overfit ratio
- TransactionCostModel has 12 instruments in COST_TABLE with get_cost, get_cost_bps, get_round_trip_bps
- Existing BacktestEngine.run() method unchanged and backward compatible
- All new and existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/14-backtesting-engine-v2-strategy-framework/14-02-SUMMARY.md`
</output>
