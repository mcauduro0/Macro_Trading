---
phase: 19-dashboard-v2-api-expansion-testing-verification
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/api/static/dashboard.html
  - src/api/static/js/App.jsx
  - src/api/static/js/Sidebar.jsx
  - src/api/static/js/hooks.jsx
  - src/api/routes/dashboard.py
autonomous: true
requirements:
  - DSHV-06

must_haves:
  truths:
    - "GET /dashboard serves the shell HTML that loads all .jsx scripts via Babel standalone"
    - "HashRouter renders a sidebar + content area layout with 5 navigation links"
    - "Clicking a sidebar item navigates to the corresponding page hash route"
    - "Sidebar collapses to icon-only mode via a toggle button at the bottom"
    - "useFetch hook polls an API endpoint at 30-second intervals and returns data/loading/error"
    - "useWebSocket hook connects to a ws:// URL with exponential backoff reconnection"
  artifacts:
    - path: "src/api/static/dashboard.html"
      provides: "Shell HTML loading React 18, Tailwind, Recharts, ReactRouterDOM, Babel from CDN"
      contains: "text/babel"
    - path: "src/api/static/js/App.jsx"
      provides: "HashRouter with routes for 5 pages and layout wrapper"
      min_lines: 40
    - path: "src/api/static/js/Sidebar.jsx"
      provides: "Collapsible sidebar with icons, labels, active highlight, badge count"
      min_lines: 60
    - path: "src/api/static/js/hooks.jsx"
      provides: "useFetch and useWebSocket custom hooks with polling and reconnection"
      min_lines: 50
    - path: "src/api/routes/dashboard.py"
      provides: "Static file serving for dashboard.html and js/ directory"
      contains: "StaticFiles"
  key_links:
    - from: "src/api/static/dashboard.html"
      to: "src/api/static/js/App.jsx"
      via: "script tag with type=text/babel"
      pattern: "App\\.jsx"
    - from: "src/api/static/js/App.jsx"
      to: "src/api/static/js/Sidebar.jsx"
      via: "component reference in JSX"
      pattern: "Sidebar"
    - from: "src/api/routes/dashboard.py"
      to: "src/api/static/"
      via: "StaticFiles mount or FileResponse"
      pattern: "static"
---

<objective>
Create the React dashboard shell: a new multi-page `dashboard.html` loading split `.jsx` files via CDN Babel, with HashRouter navigation, a collapsible sidebar, and reusable data-fetching hooks (useFetch with 30s polling, useWebSocket with exponential backoff reconnect).

Purpose: Establishes the dashboard infrastructure (routing, layout, data layer) that all 5 page components will plug into in Plan 19-02.
Output: Working shell at GET /dashboard with sidebar navigation rendering placeholder pages.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/19-dashboard-v2-api-expansion-testing-verification/19-CONTEXT.md
@src/api/routes/dashboard.py
@src/api/static/dashboard.html
@src/api/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Shell HTML, App.jsx with HashRouter, Sidebar.jsx, and hooks.jsx</name>
  <files>
    src/api/static/dashboard.html
    src/api/static/js/App.jsx
    src/api/static/js/Sidebar.jsx
    src/api/static/js/hooks.jsx
  </files>
  <action>
**dashboard.html** — Replace the existing single-file dashboard with a shell HTML file that:
- Loads CDN scripts: React 18 (react.production.min.js + react-dom.production.min.js), Babel Standalone, Tailwind CSS (cdn.tailwindcss.com), Recharts 2 (window.Recharts), ReactRouterDOM (window.ReactRouterDOM)
- Has a single `<div id="root"></div>` mount point
- Loads .jsx files in order via `<script type="text/babel" src="/static/js/hooks.jsx"></script>`, then Sidebar.jsx, then page placeholders, then App.jsx last (depends on all others)
- Each page .jsx file will be added in Plan 19-02; for now, define inline placeholder components for StrategiesPage, SignalsPage, RiskPage, PortfolioPage, AgentsPage that render `<div>Page Name — Coming Soon</div>`
- Final script block: `ReactDOM.createRoot(document.getElementById('root')).render(React.createElement(App))`

**App.jsx** — Create the main application component:
- Destructure from window.ReactRouterDOM: HashRouter, Routes, Route, Navigate
- Import Sidebar from window (Babel standalone makes top-level components global)
- Layout: flex container (h-screen), Sidebar on left, main content area with `<Routes>` on right
- Routes: `/strategies` (default redirect from `/`), `/signals`, `/risk`, `/portfolio`, `/agents`
- Each route renders the corresponding page component (global from window scope)
- Wrap everything in HashRouter
- Add a ToastContainer component at the bottom-right for WebSocket alerts (renders a list of toast objects from React.useState)
- Expose `window.App = App`

**Sidebar.jsx** — Create a collapsible sidebar navigation:
- State: `collapsed` (boolean, default false)
- 5 nav items: Strategies (chart-bar icon), Signals (activity icon), Risk (shield icon), Portfolio (briefcase icon), Agents (cpu icon) — use simple SVG inline icons or Unicode characters
- Each item uses ReactRouterDOM.NavLink with `to` prop matching the route
- Active item gets highlighted background (bg-blue-600)
- When collapsed: only show icons (w-16), when expanded: show icons + labels (w-56)
- Bottom toggle button with chevron icon to collapse/expand
- Fixed left position, full height, dark background (bg-gray-900 text-white)
- Badge count on Risk item: accept `alertCount` prop, show red circle with number when > 0
- Expose `window.Sidebar = Sidebar`

**hooks.jsx** — Create reusable data hooks:
- `useFetch(url, intervalMs = 30000)`: Uses React.useState for {data, loading, error}. React.useEffect fetches on mount and sets up setInterval for polling. Clears interval on unmount. Returns {data, loading, error, refetch}. Handles fetch errors gracefully.
- `useWebSocket(url)`: Uses React.useRef for WebSocket instance. React.useState for {connected, lastMessage}. On mount: create WebSocket, onopen sets connected=true, onmessage updates lastMessage, onclose/onerror triggers reconnect with exponential backoff (delays: 1s, 2s, 4s, 8s, 16s, 30s cap). Cleanup closes socket on unmount. Returns {connected, lastMessage, send}.
- Expose `window.useFetch = useFetch` and `window.useWebSocket = useWebSocket`
  </action>
  <verify>
Run `python -c "import pathlib; files = ['src/api/static/dashboard.html', 'src/api/static/js/App.jsx', 'src/api/static/js/Sidebar.jsx', 'src/api/static/js/hooks.jsx']; [print(f'{f}: {pathlib.Path(f).stat().st_size} bytes') for f in files]"` to confirm all files exist and have content.
Verify dashboard.html contains `text/babel` script tags for each .jsx file.
Verify App.jsx contains HashRouter and 5 Route elements.
Verify Sidebar.jsx has collapsed state and 5 NavLink items.
Verify hooks.jsx has useFetch and useWebSocket functions.
  </verify>
  <done>
Four files created: dashboard.html (shell with CDN scripts + jsx loaders), App.jsx (HashRouter with 5 routes + layout), Sidebar.jsx (collapsible nav with 5 items + alert badge), hooks.jsx (useFetch with 30s polling + useWebSocket with exponential backoff). All components exposed on window scope for CDN/Babel compatibility.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update dashboard route to serve static .jsx files</name>
  <files>
    src/api/routes/dashboard.py
    src/api/main.py
  </files>
  <action>
**dashboard.py** — Update the dashboard route module to serve the new multi-file structure:
- Keep GET /dashboard returning the shell HTML via FileResponse
- Add StaticFiles mount for the js/ directory so that `/static/js/App.jsx` etc. are served correctly
- Import `from fastapi.staticfiles import StaticFiles`
- The static directory path: `Path(__file__).resolve().parent.parent / "static"` (same as current pattern)
- Ensure the .jsx files are served with correct content-type (text/javascript or application/javascript — StaticFiles handles this)

**main.py** — Mount the static files directory on the app:
- Add `from fastapi.staticfiles import StaticFiles`
- Add `app.mount("/static", StaticFiles(directory=str(Path(__file__).resolve().parent / "static")), name="static")` AFTER all router includes but BEFORE any catch-all
- This ensures /static/js/App.jsx, /static/js/hooks.jsx etc. are served
- Keep existing dashboard.router include for GET /dashboard
- Do NOT change any existing router includes — those remain unchanged
  </action>
  <verify>
Run: `cd /home/user/Macro_Trading && python -c "from src.api.main import app; routes = [r.path for r in app.routes]; print([r for r in routes if 'static' in r or 'dashboard' in r])"`
Confirm both /dashboard route and /static mount are present.
  </verify>
  <done>
Dashboard route serves shell HTML at GET /dashboard and main.py mounts /static directory so all .jsx files are accessible via /static/js/*.jsx URLs. The CDN-loaded Babel transpiler can fetch and compile each .jsx file at runtime.
  </done>
</task>

</tasks>

<verification>
1. All 4 new files exist: dashboard.html, App.jsx, Sidebar.jsx, hooks.jsx
2. dashboard.py serves GET /dashboard with the shell HTML
3. main.py mounts /static for .jsx file serving
4. dashboard.html loads CDN libs (React 18, Tailwind, Recharts, ReactRouterDOM, Babel)
5. App.jsx defines HashRouter with 5 routes
6. Sidebar.jsx has collapsible navigation with 5 items and alert badge
7. hooks.jsx exports useFetch (30s polling) and useWebSocket (exponential backoff)
</verification>

<success_criteria>
- GET /dashboard returns 200 with HTML containing script tags for all .jsx files
- App.jsx renders a sidebar + content layout with HashRouter
- Sidebar toggles between expanded (icons + labels) and collapsed (icons only) modes
- useFetch polls at 30s intervals and returns {data, loading, error, refetch}
- useWebSocket reconnects with 1s, 2s, 4s, 8s, 16s, 30s exponential backoff
</success_criteria>

<output>
After completion, create `.planning/phases/19-dashboard-v2-api-expansion-testing-verification/19-01-SUMMARY.md`
</output>
