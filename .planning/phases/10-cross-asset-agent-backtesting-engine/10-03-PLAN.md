---
phase: 10-cross-asset-agent-backtesting-engine
plan: "03"
type: execute
wave: 2
depends_on:
  - "10-02"
files_modified:
  - src/backtesting/metrics.py
  - src/backtesting/report.py
  - src/backtesting/__init__.py
  - pyproject.toml
  - tests/test_backtesting.py
autonomous: true
requirements:
  - BACK-04
  - BACK-06
  - BACK-07
  - TESTV2-03

must_haves:
  truths:
    - "compute_metrics(portfolio, config, strategy_id) returns BacktestResult dataclass with all 10 metrics populated"
    - "Sharpe ratio is positive for monotonically increasing equity curve; max_drawdown is 0.0 for monotonic equity"
    - "Monthly returns dict uses YYYY-MM keys and pct values; empty dict returned for backtests shorter than 2 months"
    - "generate_report(result) returns formatted text string with all metrics; generate_equity_chart(result) saves PNG to path using Agg backend"
    - "persist_result(result, session_factory) inserts one BacktestResultRecord row with equity_curve and monthly_returns as JSONB"
    - "All TESTV2-03 unit tests pass without database connection"
    - "matplotlib added to pyproject.toml dependencies"
  artifacts:
    - path: "src/backtesting/metrics.py"
      provides: "BacktestResult dataclass, compute_metrics(), BacktestResultPersistence.save()"
      exports: ["BacktestResult", "compute_metrics"]
      min_lines: 100
    - path: "src/backtesting/report.py"
      provides: "generate_report() for text output, generate_equity_chart() for PNG"
      exports: ["generate_report", "generate_equity_chart"]
    - path: "tests/test_backtesting.py"
      provides: "TESTV2-03 unit tests: portfolio MtM, rebalance with costs, metrics computation"
      min_lines: 100
  key_links:
    - from: "src/backtesting/metrics.py"
      to: "src/backtesting/portfolio.py"
      via: "compute_metrics() reads portfolio.equity_curve and portfolio.trade_log"
      pattern: "portfolio\\.equity_curve"
    - from: "src/backtesting/metrics.py"
      to: "src/core/models/backtest_results.py"
      via: "BacktestResultPersistence.save() creates BacktestResultRecord and inserts via sync session"
      pattern: "BacktestResultRecord"
    - from: "src/backtesting/report.py"
      to: "src/backtesting/metrics.py"
      via: "generate_report() and generate_equity_chart() receive BacktestResult"
      pattern: "BacktestResult"
---

<objective>
Complete the backtesting system: metrics computation (all 10 financial metrics), formatted text report, equity curve chart (matplotlib PNG), result persistence to backtest_results table, and all TESTV2-03 unit tests.

Purpose: Plan 10-02 built the engine scaffold; this plan adds the analytical layer that turns raw equity curves into meaningful strategy evaluation reports.
Output: src/backtesting/metrics.py, src/backtesting/report.py, updated src/backtesting/__init__.py, matplotlib added to pyproject.toml, tests/test_backtesting.py
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-cross-asset-agent-backtesting-engine/10-RESEARCH.md
@.planning/phases/10-cross-asset-agent-backtesting-engine/10-02-SUMMARY.md

# Structural references — read for patterns
@src/backtesting/portfolio.py
@src/backtesting/engine.py
@src/core/models/backtest_results.py
@src/core/models/agent_reports.py
@tests/test_fx_agent.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: BacktestResult dataclass, compute_metrics(), persistence, and pyproject.toml matplotlib addition</name>
  <files>
    src/backtesting/metrics.py
    src/backtesting/__init__.py
    pyproject.toml
  </files>
  <action>
**Step 0: Add matplotlib to pyproject.toml**

Read `pyproject.toml` and find the `[project]` → `dependencies` list. Add `"matplotlib>=3.8"` to the list. Also run:
```bash
pip install "matplotlib>=3.8"
```

**File 1: `src/backtesting/metrics.py`**

```python
"""Metrics computation for backtest results.

All metrics computed using numpy and pandas only — no external library.
BacktestResult is a dataclass (NOT frozen — allows optional field population).
Persistence uses the same sync session pattern as AgentReportRecord.
"""
from __future__ import annotations

import json
import logging
from dataclasses import dataclass, field
from datetime import date, datetime
from typing import Any, Optional

import numpy as np
import pandas as pd

logger = logging.getLogger(__name__)


@dataclass
class BacktestResult:
    """Complete backtest result with all financial metrics.

    All percentage values stored as % (e.g., 12.5 means 12.5%, not 0.125).
    max_drawdown is a negative % (e.g., -15.3 means -15.3% drawdown).
    """
    strategy_id: str
    start_date: date
    end_date: date
    initial_capital: float
    final_equity: float

    # Return metrics
    total_return: float          # %
    annualized_return: float     # %
    annualized_volatility: float # %

    # Risk-adjusted metrics
    sharpe_ratio: float
    sortino_ratio: float
    calmar_ratio: float

    # Drawdown
    max_drawdown: float          # negative % (e.g., -15.3)

    # Trade statistics
    win_rate: float              # fraction [0, 1]
    profit_factor: float         # gross_profit / abs(gross_loss); 0.0 if no losses
    total_trades: int

    # Time series
    monthly_returns: dict        # {"YYYY-MM": return_pct}
    equity_curve: list[tuple[date, float]]  # [(date, equity)]


def compute_metrics(portfolio: Any, config: Any, strategy_id: str) -> BacktestResult:
    """Compute all financial metrics from portfolio equity curve and trade log.

    Args:
        portfolio: Portfolio instance from Plan 10-02 (has equity_curve, trade_log).
        config: BacktestConfig instance (has start_date, end_date, initial_capital).
        strategy_id: Identifier string for the strategy.

    Returns:
        BacktestResult with all 10 metrics populated.
    """
    equity_data = portfolio.equity_curve  # list of (date, float)

    if len(equity_data) < 2:
        # Degenerate case: no meaningful run
        return BacktestResult(
            strategy_id=strategy_id,
            start_date=config.start_date,
            end_date=config.end_date,
            initial_capital=config.initial_capital,
            final_equity=config.initial_capital,
            total_return=0.0,
            annualized_return=0.0,
            annualized_volatility=0.0,
            sharpe_ratio=0.0,
            sortino_ratio=0.0,
            calmar_ratio=0.0,
            max_drawdown=0.0,
            win_rate=0.0,
            profit_factor=0.0,
            total_trades=0,
            monthly_returns={},
            equity_curve=equity_data,
        )

    # Build equity Series with DatetimeIndex
    dates = [pd.Timestamp(d) for d, _ in equity_data]
    equities = [e for _, e in equity_data]
    equity = pd.Series(equities, index=dates)
    equity = equity[equity > 0]  # guard against zero/negative equity

    if len(equity) < 2:
        return _empty_result(strategy_id, config, equity_data)

    # --- Core return metrics ---
    n_years = max(
        (config.end_date - config.start_date).days / 365.25, 1 / 365.25
    )
    total_return_pct = (equity.iloc[-1] / equity.iloc[0] - 1) * 100
    ann_return_pct = ((1 + total_return_pct / 100) ** (1 / n_years) - 1) * 100

    # Daily/periodic returns
    returns = equity.pct_change().dropna()
    # Infer annualization factor from rebalance frequency
    if config.rebalance_frequency == "daily":
        ann_factor = 252
    elif config.rebalance_frequency == "weekly":
        ann_factor = 52
    else:  # monthly
        ann_factor = 12

    ann_vol_pct = float(returns.std() * np.sqrt(ann_factor) * 100) if len(returns) > 1 else 0.0

    # --- Sharpe (risk-free = 0 for simplicity) ---
    sharpe = (ann_return_pct / ann_vol_pct) if ann_vol_pct > 1e-8 else 0.0

    # --- Sortino (downside deviation only) ---
    downside = returns[returns < 0]
    if len(downside) > 1:
        sortino_denom = float(downside.std() * np.sqrt(ann_factor) * 100)
        sortino = (ann_return_pct / sortino_denom) if sortino_denom > 1e-8 else 0.0
    else:
        sortino = sharpe  # no downside → use Sharpe as proxy

    # --- Max drawdown ---
    rolling_max = equity.expanding().max()
    drawdown_series = equity / rolling_max - 1
    max_dd_pct = float(drawdown_series.min()) * 100  # negative number
    # Guard: monotonically increasing equity → drawdown = 0
    if max_dd_pct > 0:
        max_dd_pct = 0.0

    # --- Calmar ---
    calmar = (ann_return_pct / abs(max_dd_pct)) if max_dd_pct < -1e-8 else 0.0

    # --- Monthly returns ---
    try:
        monthly = equity.resample("ME").last().pct_change().dropna()
        if len(monthly) < 2:
            monthly_dict: dict = {}
        else:
            monthly_dict = {
                str(d.date())[:7]: round(float(v) * 100, 4)
                for d, v in monthly.items()
            }
    except Exception:
        monthly_dict = {}

    # --- Trade statistics from trade_log ---
    trade_pnls = [t.get("pnl", 0.0) for t in portfolio.trade_log if "pnl" in t]
    wins = [p for p in trade_pnls if p > 0]
    losses = [p for p in trade_pnls if p <= 0]
    total_trades = len(trade_pnls)
    win_rate = len(wins) / total_trades if total_trades > 0 else 0.0
    gross_loss = abs(sum(losses))
    profit_factor = (sum(wins) / gross_loss) if gross_loss > 1e-8 else 0.0

    return BacktestResult(
        strategy_id=strategy_id,
        start_date=config.start_date,
        end_date=config.end_date,
        initial_capital=config.initial_capital,
        final_equity=float(equity.iloc[-1]),
        total_return=round(float(total_return_pct), 4),
        annualized_return=round(float(ann_return_pct), 4),
        annualized_volatility=round(float(ann_vol_pct), 4),
        sharpe_ratio=round(float(sharpe), 4),
        sortino_ratio=round(float(sortino), 4),
        calmar_ratio=round(float(calmar), 4),
        max_drawdown=round(float(max_dd_pct), 4),
        win_rate=round(float(win_rate), 4),
        profit_factor=round(float(profit_factor), 4),
        total_trades=total_trades,
        monthly_returns=monthly_dict,
        equity_curve=equity_data,
    )


def _empty_result(strategy_id: str, config: Any, equity_data: list) -> BacktestResult:
    return BacktestResult(
        strategy_id=strategy_id,
        start_date=config.start_date,
        end_date=config.end_date,
        initial_capital=config.initial_capital,
        final_equity=config.initial_capital,
        total_return=0.0, annualized_return=0.0, annualized_volatility=0.0,
        sharpe_ratio=0.0, sortino_ratio=0.0, calmar_ratio=0.0,
        max_drawdown=0.0, win_rate=0.0, profit_factor=0.0,
        total_trades=0, monthly_returns={}, equity_curve=equity_data,
    )


def persist_result(result: BacktestResult, sync_session_factory: Any) -> None:
    """Persist a BacktestResult to the backtest_results table.

    Uses the same sync session pattern as AgentReportRecord persistence.
    ON CONFLICT DO NOTHING not applicable here (no unique constraint);
    each call inserts a new row.

    Args:
        result: Computed BacktestResult from compute_metrics().
        sync_session_factory: SQLAlchemy sync sessionmaker factory.
    """
    from src.core.models.backtest_results import BacktestResultRecord

    # Serialize equity curve to JSON-safe list of [date_str, equity] pairs
    equity_curve_json = [
        [str(d), round(e, 2)] for d, e in result.equity_curve
    ]
    config_json = {
        "start_date": str(result.start_date),
        "end_date": str(result.end_date),
        "initial_capital": result.initial_capital,
    }

    record = BacktestResultRecord(
        strategy_id=result.strategy_id,
        start_date=result.start_date,
        end_date=result.end_date,
        initial_capital=result.initial_capital,
        final_equity=result.final_equity,
        total_return=result.total_return,
        annualized_return=result.annualized_return,
        annualized_volatility=result.annualized_volatility,
        sharpe_ratio=result.sharpe_ratio,
        sortino_ratio=result.sortino_ratio,
        calmar_ratio=result.calmar_ratio,
        max_drawdown=result.max_drawdown,
        win_rate=result.win_rate,
        profit_factor=result.profit_factor,
        total_trades=result.total_trades,
        equity_curve=equity_curve_json,
        monthly_returns=result.monthly_returns,
        config_json=config_json,
    )

    with sync_session_factory() as session:
        try:
            session.add(record)
            session.commit()
            logger.info(
                "backtest_result_persisted",
                strategy_id=result.strategy_id,
                sharpe=result.sharpe_ratio,
            )
        except Exception as exc:
            session.rollback()
            logger.error("backtest_result_persist_failed", error=str(exc))
            raise
```

**Update `src/backtesting/__init__.py`** — add metrics imports:
```python
from src.backtesting.metrics import BacktestResult, compute_metrics, persist_result

__all__ = ["BacktestConfig", "BacktestEngine", "Portfolio", "BacktestResult", "compute_metrics", "persist_result"]
```

**Update `BacktestEngine.run()` in `src/backtesting/engine.py`** — replace the `BacktestRawResult` namedtuple return with a call to `compute_metrics()`:
```python
# At end of run(), after the loop:
from src.backtesting.metrics import compute_metrics
return compute_metrics(portfolio, self.config, strategy.strategy_id)
```
Remove the `BacktestRawResult` namedtuple. Import `compute_metrics` at the top of `engine.py` (import at top, not inside method, to avoid repeated imports — but guard with TYPE_CHECKING if needed to avoid circular import; metrics.py imports from portfolio.py, not engine.py, so no circular import exists).
  </action>
  <verify>
```python
from datetime import date, timedelta
from src.backtesting.metrics import BacktestResult, compute_metrics
from src.backtesting.portfolio import Portfolio
from src.backtesting.engine import BacktestConfig

# Build a portfolio with monotonically increasing equity
p = Portfolio(initial_capital=1_000_000.0)
start = date(2024, 1, 31)
equity = 1_000_000.0
for i in range(12):
    d = date(2024, 1 + i if i < 11 else 12, 28)
    equity *= 1.01  # 1% monthly return
    p.equity_curve.append((d, equity))

config = BacktestConfig(
    start_date=date(2024, 1, 1),
    end_date=date(2024, 12, 31),
    initial_capital=1_000_000.0,
    rebalance_frequency="monthly"
)
result = compute_metrics(p, config, "TEST")
assert result.sharpe_ratio > 0, f"Expected positive Sharpe, got {result.sharpe_ratio}"
assert result.max_drawdown == 0.0, f"Expected 0.0 drawdown, got {result.max_drawdown}"
assert result.total_return > 0, f"Expected positive return, got {result.total_return}"
assert isinstance(result.monthly_returns, dict)
print(f"compute_metrics OK: Sharpe={result.sharpe_ratio:.2f}, Return={result.total_return:.2f}%")
```
  </verify>
  <done>
- `src/backtesting/metrics.py` exists and exports BacktestResult, compute_metrics, persist_result
- `compute_metrics(portfolio, config, strategy_id)` returns BacktestResult with all fields populated
- Sharpe > 0 for monotonically increasing equity; max_drawdown == 0.0 for same
- monthly_returns is `{}` when equity_curve has fewer than 2 months
- `pyproject.toml` includes `"matplotlib>=3.8"` in dependencies
- `BacktestEngine.run()` now returns BacktestResult (not BacktestRawResult namedtuple)
  </done>
</task>

<task type="auto">
  <name>Task 2: Text report, equity chart (matplotlib Agg), and TESTV2-03 unit tests</name>
  <files>
    src/backtesting/report.py
    tests/test_backtesting.py
  </files>
  <action>
**File 1: `src/backtesting/report.py`**

```python
"""Backtest reporting: text summary and equity curve chart.

Uses matplotlib Agg backend for headless PNG generation.
matplotlib.use("Agg") MUST be called before importing pyplot.
"""
from __future__ import annotations

import logging
import os
from pathlib import Path
from typing import Optional

import matplotlib
matplotlib.use("Agg")  # Non-interactive backend; MUST be before pyplot import
import matplotlib.pyplot as plt
import matplotlib.dates as mdates

from src.backtesting.metrics import BacktestResult

logger = logging.getLogger(__name__)

_REPORT_TEMPLATE = """
╔══════════════════════════════════════════════════════════════════════╗
║  BACKTEST REPORT: {strategy_id:<48} ║
╠══════════════════════════════════════════════════════════════════════╣
║  Period:          {start_date} → {end_date:<39} ║
║  Initial Capital: {initial_capital:>15,.0f}                              ║
║  Final Equity:    {final_equity:>15,.0f}                              ║
╠══════════════════════════════════════════════════════════════════════╣
║  RETURN METRICS                                                      ║
║    Total Return:          {total_return:>8.2f}%                           ║
║    Annualized Return:     {annualized_return:>8.2f}%                           ║
║    Annualized Volatility: {annualized_volatility:>8.2f}%                           ║
╠══════════════════════════════════════════════════════════════════════╣
║  RISK METRICS                                                        ║
║    Sharpe Ratio:          {sharpe_ratio:>8.4f}                              ║
║    Sortino Ratio:         {sortino_ratio:>8.4f}                              ║
║    Calmar Ratio:          {calmar_ratio:>8.4f}                              ║
║    Max Drawdown:          {max_drawdown:>8.2f}%                           ║
╠══════════════════════════════════════════════════════════════════════╣
║  TRADE STATISTICS                                                    ║
║    Total Trades:          {total_trades:>8d}                              ║
║    Win Rate:              {win_rate_pct:>8.2f}%                           ║
║    Profit Factor:         {profit_factor:>8.4f}                              ║
╚══════════════════════════════════════════════════════════════════════╝
"""


def generate_report(result: BacktestResult) -> str:
    """Generate a formatted text backtest report.

    Args:
        result: BacktestResult from compute_metrics().

    Returns:
        Multi-line string with tabular metrics. Suitable for logging or stdout.
    """
    return _REPORT_TEMPLATE.format(
        strategy_id=result.strategy_id,
        start_date=str(result.start_date),
        end_date=str(result.end_date),
        initial_capital=result.initial_capital,
        final_equity=result.final_equity,
        total_return=result.total_return,
        annualized_return=result.annualized_return,
        annualized_volatility=result.annualized_volatility,
        sharpe_ratio=result.sharpe_ratio,
        sortino_ratio=result.sortino_ratio,
        calmar_ratio=result.calmar_ratio,
        max_drawdown=result.max_drawdown,
        total_trades=result.total_trades,
        win_rate_pct=result.win_rate * 100,
        profit_factor=result.profit_factor,
    )


def generate_equity_chart(
    result: BacktestResult,
    output_path: Optional[str] = None,
    show_drawdown: bool = True,
) -> str:
    """Generate equity curve PNG chart and save to file.

    Uses matplotlib Agg backend (non-interactive, headless-safe).

    Args:
        result: BacktestResult from compute_metrics().
        output_path: Path to save PNG. Defaults to /tmp/{strategy_id}_equity.png.
        show_drawdown: If True, add a drawdown subplot below the equity curve.

    Returns:
        Absolute path to saved PNG file.
    """
    if output_path is None:
        output_path = f"/tmp/{result.strategy_id}_equity.png"

    output_path = str(Path(output_path).resolve())

    # Build equity series
    if not result.equity_curve:
        logger.warning("generate_equity_chart: empty equity curve, skipping chart")
        return output_path

    import pandas as pd
    dates = [pd.Timestamp(d) for d, _ in result.equity_curve]
    equities = [e for _, e in result.equity_curve]
    equity_series = pd.Series(equities, index=dates)

    if show_drawdown and len(equity_series) > 1:
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(12, 8), gridspec_kw={"height_ratios": [3, 1]})
    else:
        fig, ax1 = plt.subplots(1, 1, figsize=(12, 5))
        ax2 = None

    # Equity curve
    ax1.plot(equity_series.index, equity_series.values, color="#2196F3", linewidth=1.5, label="Portfolio Equity")
    ax1.axhline(y=result.initial_capital, color="#9E9E9E", linestyle="--", linewidth=0.8, alpha=0.7, label="Initial Capital")
    ax1.set_title(
        f"{result.strategy_id} — Equity Curve\n"
        f"Return: {result.total_return:.1f}% | Sharpe: {result.sharpe_ratio:.2f} | "
        f"Max DD: {result.max_drawdown:.1f}%",
        fontsize=12,
    )
    ax1.set_ylabel("Portfolio Value")
    ax1.legend(loc="upper left", fontsize=9)
    ax1.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m"))
    ax1.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
    plt.setp(ax1.xaxis.get_majorticklabels(), rotation=30, ha="right")
    ax1.grid(True, alpha=0.3)
    ax1.yaxis.set_major_formatter(plt.FuncFormatter(lambda x, _: f"{x:,.0f}"))

    # Drawdown subplot
    if ax2 is not None:
        rolling_max = equity_series.expanding().max()
        drawdown = (equity_series / rolling_max - 1) * 100
        ax2.fill_between(drawdown.index, drawdown.values, 0, color="#F44336", alpha=0.4, label="Drawdown")
        ax2.plot(drawdown.index, drawdown.values, color="#F44336", linewidth=0.8)
        ax2.set_ylabel("Drawdown %")
        ax2.set_xlabel("Date")
        ax2.xaxis.set_major_formatter(mdates.DateFormatter("%Y-%m"))
        ax2.xaxis.set_major_locator(mdates.MonthLocator(interval=3))
        plt.setp(ax2.xaxis.get_majorticklabels(), rotation=30, ha="right")
        ax2.grid(True, alpha=0.3)
        ax2.legend(loc="lower left", fontsize=9)

    plt.tight_layout()
    plt.savefig(output_path, dpi=150, bbox_inches="tight")
    plt.close(fig)

    logger.info("equity_chart_saved", path=output_path)
    return output_path
```

**File 2: `tests/test_backtesting.py`** — TESTV2-03 unit tests.

All tests use synthetic data; no DB connection required. Mirror pattern from `tests/test_fx_agent.py`.

```python
"""Unit tests for backtesting engine — TESTV2-03.

Tests cover:
- Portfolio: mark-to-market, rebalance with costs, total_equity
- BacktestConfig: frozen dataclass, defaults
- compute_metrics: Sharpe, Sortino, Calmar, max drawdown, win rate, profit factor
- Edge cases: empty equity curve, single month, no trades
"""
from __future__ import annotations

from datetime import date, timedelta

import numpy as np
import pandas as pd
import pytest

from src.backtesting.engine import BacktestConfig
from src.backtesting.metrics import BacktestResult, compute_metrics
from src.backtesting.portfolio import Portfolio

AS_OF = date(2024, 1, 31)
CONFIG = BacktestConfig(
    start_date=date(2024, 1, 1),
    end_date=date(2024, 12, 31),
    initial_capital=1_000_000.0,
    rebalance_frequency="monthly",
    transaction_cost_bps=5.0,
    slippage_bps=2.0,
)


def make_equity_curve(
    n_months: int = 12, monthly_return: float = 0.01, start: date = date(2024, 1, 31)
) -> list[tuple[date, float]]:
    """Build a synthetic equity curve with constant monthly returns."""
    curve = []
    equity = 1_000_000.0
    for i in range(n_months):
        equity *= (1 + monthly_return)
        d = date(start.year, start.month, 28) if i == 0 else date(
            start.year + (start.month + i - 1) // 12,
            (start.month + i - 1) % 12 + 1,
            28,
        )
        curve.append((d, equity))
    return curve


# ---------------------------------------------------------------------------
# Portfolio tests
# ---------------------------------------------------------------------------
class TestPortfolio:
    def test_initial_equity_equals_capital(self):
        p = Portfolio(1_000_000.0)
        assert abs(p.total_equity - 1_000_000.0) < 0.01

    def test_positions_empty_on_init(self):
        p = Portfolio(500_000.0)
        assert p.positions == {}
        assert p.equity_curve == []
        assert p.trade_log == []

    def test_total_equity_is_cash_plus_positions(self):
        p = Portfolio(1_000_000.0)
        p.cash = 600_000.0
        p.positions = {"IBOVESPA": 400_000.0}
        assert abs(p.total_equity - 1_000_000.0) < 0.01

    def test_rebalance_deducts_transaction_costs(self):
        p = Portfolio(1_000_000.0)
        p._rebalance_date = AS_OF
        prices = {"IBOVESPA": 100_000.0}
        p.rebalance({"IBOVESPA": 0.5}, prices, CONFIG)
        expected_notional = 500_000.0
        expected_cost = expected_notional * (5.0 + 2.0) / 10_000  # 7bps = 350
        assert abs(p.positions["IBOVESPA"] - expected_notional) < 1.0
        assert abs(p.cash - (1_000_000.0 - expected_notional - expected_cost)) < 1.0

    def test_rebalance_logs_to_trade_log(self):
        p = Portfolio(1_000_000.0)
        p._rebalance_date = AS_OF
        p.rebalance({"IBOVESPA": 0.5}, {"IBOVESPA": 100_000.0}, CONFIG)
        assert len(p.trade_log) == 1
        assert p.trade_log[0]["ticker"] == "IBOVESPA"
        assert p.trade_log[0]["direction"] == "BUY"
        assert p.trade_log[0]["cost"] > 0

    def test_rebalance_enforces_max_leverage(self):
        """Total weight 2.0 with max_leverage=1.0 → weights scaled to 0.5 each."""
        p = Portfolio(1_000_000.0)
        p._rebalance_date = AS_OF
        config_2x = BacktestConfig(
            start_date=date(2024, 1, 1), end_date=date(2024, 12, 31),
            initial_capital=1_000_000.0, max_leverage=1.0
        )
        # weights sum to 2.0 — should be scaled to 1.0
        p.rebalance({"A": 1.0, "B": 1.0}, {"A": 1.0, "B": 1.0}, config_2x)
        total_notional = sum(abs(v) for v in p.positions.values())
        assert total_notional <= 1_000_000.0 * 1.01  # within 1% of max_leverage * equity

    def test_rebalance_exits_removed_tickers(self):
        """Ticker in positions but not in target_weights → position zeroed."""
        p = Portfolio(1_000_000.0)
        p.positions = {"OLD_TICKER": 200_000.0}
        p.cash = 800_000.0
        p._rebalance_date = AS_OF
        # New rebalance doesn't include OLD_TICKER
        p.rebalance({"IBOVESPA": 0.3}, {"IBOVESPA": 100_000.0, "OLD_TICKER": 100_000.0}, CONFIG)
        assert p.positions.get("OLD_TICKER", 0.0) == 0.0

    def test_mark_to_market_updates_position_value(self):
        """Position doubles when price doubles."""
        p = Portfolio(1_000_000.0)
        p.cash = 500_000.0
        p.positions = {"IBOVESPA": 500_000.0}
        p._entry_prices = {"IBOVESPA": 100_000.0}
        p.mark_to_market({"IBOVESPA": 200_000.0})  # price doubled
        # Position notional should double
        assert abs(p.positions["IBOVESPA"] - 1_000_000.0) < 1.0


# ---------------------------------------------------------------------------
# BacktestConfig tests
# ---------------------------------------------------------------------------
class TestBacktestConfig:
    def test_default_costs(self):
        c = BacktestConfig(date(2024, 1, 1), date(2024, 12, 31), 1e6)
        assert c.transaction_cost_bps == 5.0
        assert c.slippage_bps == 2.0
        assert c.max_leverage == 1.0
        assert c.rebalance_frequency == "monthly"

    def test_frozen_dataclass(self):
        c = BacktestConfig(date(2024, 1, 1), date(2024, 12, 31), 1e6)
        with pytest.raises((AttributeError, TypeError)):
            c.initial_capital = 2e6  # type: ignore[misc]


# ---------------------------------------------------------------------------
# compute_metrics tests
# ---------------------------------------------------------------------------
class TestComputeMetrics:
    def _make_portfolio_with_curve(self, n: int = 12, ret: float = 0.01) -> Portfolio:
        p = Portfolio(1_000_000.0)
        p.equity_curve = make_equity_curve(n, ret)
        return p

    def test_positive_sharpe_for_positive_returns(self):
        p = self._make_portfolio_with_curve(12, 0.01)
        result = compute_metrics(p, CONFIG, "TEST")
        assert result.sharpe_ratio > 0, f"Sharpe={result.sharpe_ratio}"

    def test_zero_drawdown_for_monotonic_equity(self):
        p = self._make_portfolio_with_curve(12, 0.01)
        result = compute_metrics(p, CONFIG, "TEST")
        assert result.max_drawdown == 0.0, f"Max DD={result.max_drawdown}"

    def test_negative_drawdown_for_declining_equity(self):
        p = Portfolio(1_000_000.0)
        # Equity peaks then drops
        p.equity_curve = [
            (date(2024, 1, 31), 1_100_000.0),
            (date(2024, 2, 29), 1_000_000.0),  # -9.1% drawdown
            (date(2024, 3, 31), 1_050_000.0),
        ]
        result = compute_metrics(p, CONFIG, "TEST")
        assert result.max_drawdown < 0, f"Expected negative max_dd, got {result.max_drawdown}"

    def test_total_return_positive_for_positive_curve(self):
        p = self._make_portfolio_with_curve(12, 0.02)
        result = compute_metrics(p, CONFIG, "TEST")
        assert result.total_return > 0

    def test_empty_equity_curve_returns_zeros(self):
        p = Portfolio(1_000_000.0)
        result = compute_metrics(p, CONFIG, "TEST")
        assert result.sharpe_ratio == 0.0
        assert result.total_return == 0.0

    def test_monthly_returns_dict_keys_format(self):
        p = self._make_portfolio_with_curve(12, 0.01)
        result = compute_metrics(p, CONFIG, "TEST")
        for k in result.monthly_returns:
            assert len(k) == 7 and "-" in k, f"Bad key format: {k}"

    def test_short_backtest_empty_monthly_returns(self):
        """Single equity point → empty monthly_returns."""
        p = Portfolio(1_000_000.0)
        p.equity_curve = [(date(2024, 1, 31), 1_010_000.0)]
        result = compute_metrics(p, CONFIG, "TEST")
        assert result.monthly_returns == {}

    def test_win_rate_from_trade_log(self):
        p = Portfolio(1_000_000.0)
        p.equity_curve = make_equity_curve(12, 0.005)
        p.trade_log = [
            {"pnl": 1000.0},
            {"pnl": 2000.0},
            {"pnl": -500.0},
            {"pnl": 1500.0},
        ]
        result = compute_metrics(p, CONFIG, "TEST")
        assert abs(result.win_rate - 0.75) < 0.01  # 3 wins out of 4

    def test_profit_factor_from_trade_log(self):
        p = Portfolio(1_000_000.0)
        p.equity_curve = make_equity_curve(12, 0.005)
        p.trade_log = [{"pnl": 4500.0}, {"pnl": -1500.0}]  # PF = 4500/1500 = 3.0
        result = compute_metrics(p, CONFIG, "TEST")
        assert abs(result.profit_factor - 3.0) < 0.01

    def test_zero_profit_factor_when_no_losses(self):
        p = Portfolio(1_000_000.0)
        p.equity_curve = make_equity_curve(12, 0.01)
        p.trade_log = [{"pnl": 1000.0}, {"pnl": 2000.0}]  # no losses
        result = compute_metrics(p, CONFIG, "TEST")
        assert result.profit_factor == 0.0  # no gross_loss → 0.0

    def test_backtest_result_strategy_id(self):
        p = self._make_portfolio_with_curve()
        result = compute_metrics(p, CONFIG, "MY_STRATEGY")
        assert result.strategy_id == "MY_STRATEGY"

    def test_annualized_return_reasonable(self):
        """12 months at 1%/month → ~12.7% annualized."""
        p = self._make_portfolio_with_curve(12, 0.01)
        result = compute_metrics(p, CONFIG, "TEST")
        assert 10.0 < result.annualized_return < 16.0, f"Ann return: {result.annualized_return}"
```
  </action>
  <verify>
```bash
# matplotlib import with Agg backend
python -c "
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
print('matplotlib Agg OK')
"

# Report generation
python -c "
from datetime import date
from src.backtesting.metrics import BacktestResult, compute_metrics
from src.backtesting.portfolio import Portfolio
from src.backtesting.engine import BacktestConfig
from src.backtesting.report import generate_report, generate_equity_chart

p = Portfolio(1_000_000.0)
equity = 1_000_000.0
for i in range(12):
    equity *= 1.01
    p.equity_curve.append((date(2024, (i % 12) + 1, 28), equity))

config = BacktestConfig(date(2024,1,1), date(2024,12,31), 1_000_000.0)
result = compute_metrics(p, config, 'TEST_STRAT')
report = generate_report(result)
assert 'TEST_STRAT' in report
assert 'Sharpe' in report

chart_path = generate_equity_chart(result, '/tmp/test_equity.png')
import os
assert os.path.exists(chart_path)
print(f'Report and chart OK. Chart saved to {chart_path}')
"

# All unit tests
python -m pytest tests/test_backtesting.py -v 2>&1 | tail -25
```
  </verify>
  <done>
- `src/backtesting/report.py` exists with generate_report() and generate_equity_chart()
- generate_report() returns multi-line string containing strategy_id, all 10 metrics
- generate_equity_chart() saves a PNG file using Agg backend; returns file path
- All TESTV2-03 unit tests pass: `python -m pytest tests/test_backtesting.py -v` shows 15+ passed
- Tests verify: portfolio MtM, rebalance with costs, Sharpe positive, max_drawdown 0 for monotonic, win rate 0.75 for 3/4 wins, profit factor 3.0 for 4500/1500
  </done>
</task>

</tasks>

<verification>
```bash
# Full module import chain
python -c "
from src.backtesting import BacktestConfig, BacktestEngine, Portfolio, BacktestResult, compute_metrics, persist_result
from src.backtesting.report import generate_report, generate_equity_chart
print('Full backtesting module imports OK')
"

# End-to-end metrics verification
python -c "
from datetime import date
from src.backtesting.metrics import compute_metrics
from src.backtesting.portfolio import Portfolio
from src.backtesting.engine import BacktestConfig

p = Portfolio(1_000_000.0)
# Build drawdown scenario: up then down
p.equity_curve = [
    (date(2024, 1, 31), 1_100_000.0),  # +10%
    (date(2024, 2, 29), 950_000.0),    # drops below initial
    (date(2024, 3, 31), 1_050_000.0),
]
p.trade_log = [{'pnl': 500.0}, {'pnl': -200.0}, {'pnl': 300.0}]
config = BacktestConfig(date(2024,1,1), date(2024,12,31), 1_000_000.0)
result = compute_metrics(p, config, 'VERIFY')
assert result.max_drawdown < 0, 'Expected negative drawdown'
assert result.win_rate > 0.5, f'Expected >50% win rate, got {result.win_rate}'
assert result.profit_factor > 0, f'Expected positive profit factor, got {result.profit_factor}'
print(f'End-to-end OK: DD={result.max_drawdown:.2f}%, WR={result.win_rate:.1%}, PF={result.profit_factor:.2f}')
"

# Unit tests
python -m pytest tests/test_backtesting.py -v

# matplotlib chart (headless)
python -c "
from datetime import date
from src.backtesting.metrics import BacktestResult
from src.backtesting.report import generate_equity_chart
import os

# Minimal result
result = BacktestResult(
    strategy_id='TEST', start_date=date(2024,1,1), end_date=date(2024,12,31),
    initial_capital=1e6, final_equity=1.1e6, total_return=10.0, annualized_return=10.0,
    annualized_volatility=5.0, sharpe_ratio=2.0, sortino_ratio=2.5, calmar_ratio=1.5,
    max_drawdown=-3.0, win_rate=0.6, profit_factor=2.0, total_trades=12,
    monthly_returns={'2024-01': 0.8}, equity_curve=[(date(2024, i, 28), 1e6 * (1 + i*0.01)) for i in range(1, 13)]
)
path = generate_equity_chart(result, '/tmp/verify_equity.png')
assert os.path.exists(path)
print(f'Chart OK: {path}')
"
```
</verification>

<success_criteria>
- `compute_metrics(portfolio, config, strategy_id)` returns BacktestResult with 10 metrics: total_return, annualized_return, annualized_volatility, sharpe_ratio, sortino_ratio, calmar_ratio, max_drawdown, win_rate, profit_factor, total_trades
- Sharpe > 0 for positive returns; max_drawdown < 0 for any decline; max_drawdown == 0.0 for monotonic growth
- monthly_returns dict has "YYYY-MM" keys; empty dict for < 2 months of data
- win_rate = wins / total_trades; profit_factor = sum(wins) / abs(sum(losses)); 0.0 when no losses
- generate_report() returns string with all metrics; strategy_id visible in report
- generate_equity_chart() saves valid PNG to /tmp/ using matplotlib Agg backend
- persist_result() creates BacktestResultRecord with equity_curve and monthly_returns as JSONB
- 15+ TESTV2-03 unit tests pass without database connection
- pyproject.toml includes "matplotlib>=3.8"
</success_criteria>

<output>
After completion, create `.planning/phases/10-cross-asset-agent-backtesting-engine/10-03-SUMMARY.md`
</output>
