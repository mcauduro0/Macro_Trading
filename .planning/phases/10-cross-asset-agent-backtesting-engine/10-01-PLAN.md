---
phase: 10-cross-asset-agent-backtesting-engine
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/features/cross_asset_features.py
  - src/agents/cross_asset_agent.py
  - src/agents/features/__init__.py
  - tests/test_cross_asset_agent.py
autonomous: true
requirements:
  - CRSA-01
  - CRSA-02
  - CRSA-03

must_haves:
  truths:
    - "CrossAssetAgent.run(as_of_date) returns exactly 3 AgentSignal objects: CROSSASSET_REGIME, CROSSASSET_CORRELATION, CROSSASSET_SENTIMENT"
    - "CROSSASSET_REGIME signal value is clipped to [-1.0, +1.0] with LONG direction for score > 0.2 and SHORT for score < -0.2"
    - "CROSSASSET_CORRELATION signal has strength STRONG or MODERATE (not NO_SIGNAL) when any pair shows |z| > 2.0; direction is always NEUTRAL (regime-neutral alert, not directional)"
    - "CROSSASSET_SENTIMENT signal value is in [0, 100] with 6 weighted components per RiskSentimentIndex.WEIGHTS"
    - "Unit tests pass without a database connection using synthetic feature dicts"
    - "cross_asset_agent is registered last in AgentRegistry.EXECUTION_ORDER and features/__init__.py exports CrossAssetFeatureEngine"
  artifacts:
    - path: "src/agents/features/cross_asset_features.py"
      provides: "CrossAssetFeatureEngine with compute() returning _regime_components, _correlation_pairs, _sentiment_components private keys"
      exports: ["CrossAssetFeatureEngine"]
    - path: "src/agents/cross_asset_agent.py"
      provides: "CrossAssetAgent, RegimeDetectionModel, CorrelationAnalysis, RiskSentimentIndex"
      exports: ["CrossAssetAgent", "RegimeDetectionModel", "CorrelationAnalysis", "RiskSentimentIndex"]
    - path: "tests/test_cross_asset_agent.py"
      provides: "Unit tests for all 3 models and the feature engine"
      min_lines: 120
  key_links:
    - from: "src/agents/cross_asset_agent.py"
      to: "src/agents/features/cross_asset_features.py"
      via: "CrossAssetAgent.compute_features() delegates to CrossAssetFeatureEngine.compute()"
      pattern: "CrossAssetFeatureEngine"
    - from: "src/agents/cross_asset_agent.py"
      to: "src/agents/base.py"
      via: "class CrossAssetAgent(BaseAgent)"
      pattern: "class CrossAssetAgent\\(BaseAgent\\)"
    - from: "src/agents/features/__init__.py"
      to: "src/agents/features/cross_asset_features.py"
      via: "conditional try/except import"
      pattern: "CrossAssetFeatureEngine"
---

<objective>
Build CrossAssetAgent — the 5th and final analytical agent — with CrossAssetFeatureEngine and 3 quantitative model classes (RegimeDetectionModel, CorrelationAnalysis, RiskSentimentIndex).

Purpose: Complete the 5-agent pipeline that feeds into Phase 11 trading strategies. CrossAssetAgent provides the global risk regime context (risk-on/risk-off) that all strategies use to scale positions.
Output: cross_asset_features.py, cross_asset_agent.py, updated features/__init__.py, test_cross_asset_agent.py
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-cross-asset-agent-backtesting-engine/10-RESEARCH.md

# Structural references — read to maintain exact patterns
@src/agents/fx_agent.py
@src/agents/features/fx_features.py
@src/agents/features/__init__.py
@src/agents/registry.py
@src/agents/base.py
@tests/test_fx_agent.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: CrossAssetFeatureEngine and cross_asset_features.py</name>
  <files>src/agents/features/cross_asset_features.py</files>
  <action>
Create `src/agents/features/cross_asset_features.py` with `CrossAssetFeatureEngine` class. Mirror `FxFeatureEngine` structure exactly: stateless class, single `compute(data: dict, as_of_date: date) -> dict[str, Any]` method, all sub-computations in private methods, all errors caught with `try/except` returning `np.nan`.

**Data keys in `data` dict** (passed from CrossAssetAgent.load_data()):
- `data["vix"]` — DataFrame with `close` column (VIX level, daily, 756 lookback)
- `data["dxy"]` — DataFrame with `close` column (DXY index, daily)
- `data["ibovespa"]` — DataFrame with `close` column (IBOVESPA, daily)
- `data["sp500"]` — DataFrame with `close` column (SP500, daily)
- `data["oil_wti"]` — DataFrame with `close` column (WTI crude oil, daily)
- `data["hy_oas"]` — DataFrame with `value` column (US HY OAS in bps, from FRED-BAMLH0A0HYM2)
- `data["ust_2y"]` — DataFrame with `value` column (UST 2Y yield, from FRED-DGS2)
- `data["ust_10y"]` — DataFrame with `value` column (UST 10Y yield, from FRED-DGS10)
- `data["cftc_brl"]` — DataFrame with `value` column (CFTC_6L_LEVERAGED_NET)
- `data["bcb_flow"]` — DataFrame with `value` column (BR_FX_FLOW_COMMERCIAL)
- `data["di_curve"]` — dict returned by loader.get_curve("DI", as_of_date)
- `data["ust_5y"]` — DataFrame with `value` column (FRED-DGS5, for CDS proxy)
- `data["_as_of_date"]` — date

**Scalar features to compute** (stored at top level of features dict):
- `vix_level` — latest VIX close
- `vix_zscore_252d` — z-score of VIX vs trailing 252-day history
- `hy_oas_bps` — latest HY OAS value
- `hy_oas_zscore_252d` — z-score vs trailing 252-day history
- `dxy_level` — latest DXY close
- `dxy_zscore_252d` — z-score vs trailing 252-day history
- `ust_slope_bps` — (10Y - 2Y) in bps from ust_10y.value - ust_2y.value latest values
- `ust_slope_zscore_252d` — z-score of slope vs trailing 252-day history (inverted: slope inversion = risk-off)
- `cftc_brl_net` — latest CFTC_6L_LEVERAGED_NET value
- `cftc_brl_zscore` — z-score of CFTC positioning vs 52-week history
- `bcb_flow_net` — latest BCB FX commercial flow value
- `bcb_flow_zscore` — z-score vs 52-week history
- `di_5y_rate` — 5Y tenor from di_curve dict (key `1825` or nearest), in pct
- `ust_5y_rate` — latest UST 5Y value from data["ust_5y"]
- `credit_proxy_bps` — (di_5y_rate - ust_5y_rate) * 100 as sovereign credit spread proxy; np.nan if either unavailable

**Private keys for model classes:**

`_regime_components` — dict[str, float] mapping factor name to z-score (normalized, direction-corrected so that higher z = more risk-off). Keys:
- `"vix"` — vix_zscore_252d (already risk-off when high)
- `"hy_oas"` — hy_oas_zscore_252d (risk-off when high)
- `"dxy"` — dxy_zscore_252d (risk-off when high USD)
- `"em_flows"` — negative of bcb_flow_zscore (outflows = risk-off = positive z in this context)
- `"ust_slope"` — negative of ust_slope_zscore_252d (inversion = risk-off = positive z in this context)
- `"br_fiscal"` — hy_oas_zscore_252d * 0.3 (use as proxy; placeholder for fiscal dominance; set to np.nan if no data)

Set any component to `np.nan` if data unavailable. `RegimeDetectionModel` handles `np.nanmean`.

`_correlation_pairs` — dict[str, tuple[pd.Series, pd.Series]] for 5 pairs. Each value is (series_x, series_y) aligned daily close series. Pairs:
- `"USDBRL_DXY"` — (usdbrl close, dxy close) from data["vix"] table approach: use IBOVESPA for USDBRL proxy since USDBRL_PTAX not loaded; NOTE: CrossAssetAgent.load_data() should also load USDBRL_PTAX — document this in the load_data action below. For now build pairs from available data: if usdbrl_ptax not in data, return empty dict for this pair.
- `"DI_UST"` — (di_5y as daily Series via get_curve_history, ust_2y close) — use ust_2y value Series as proxy
- `"IBOV_SP500"` — (ibovespa close, sp500 close)
- `"USDBRL_VIX"` — (usdbrl_ptax close, vix close)
- `"OIL_BRL"` — (oil_wti close, usdbrl_ptax close) — inverted pair

For pairs depending on usdbrl_ptax: store `None` if `data.get("usdbrl_ptax")` is None/empty.

`_sentiment_components` — dict[str, float] with 6 subscores each mapped to [0, 100]:
- `"vix"` — linear_scale(vix_level, lo=10, hi=40, invert=True): vix=10 → 100, vix=40 → 0
- `"hy_oas"` — linear_scale(hy_oas_bps, lo=300, hi=1000, invert=True): 300bps → 100, 1000bps → 0
- `"dxy"` — linear_scale(dxy_level, lo=90, hi=115, invert=True): 90 → 100, 115 → 0
- `"cftc_brl"` — linear_scale(cftc_brl_zscore, lo=-2, hi=2): z=-2 → 0, z=+2 → 100 (long positioning = greed)
- `"em_flows"` — linear_scale(bcb_flow_zscore, lo=-2, hi=2): z=-2 → 0, z=+2 → 100
- `"credit_proxy"` — linear_scale(credit_proxy_bps, lo=100, hi=600, invert=True): 100bps → 100, 600bps → 0

Helper: `def _linear_scale(val, lo, hi, invert=False) -> float` — clamps to [lo, hi], maps to [0, 100], inverts if specified. Returns `np.nan` if val is NaN.

Set any subscore to `np.nan` if the underlying data unavailable. `RiskSentimentIndex` computes weighted mean skipping NaN.
  </action>
  <verify>
```python
from datetime import date
import numpy as np
import pandas as pd
from src.agents.features.cross_asset_features import CrossAssetFeatureEngine

engine = CrossAssetFeatureEngine()
# Build minimal synthetic data
idx = pd.date_range("2022-01-01", periods=400, freq="B")
data = {
    "vix": pd.DataFrame({"close": [20.0] * 400}, index=idx),
    "dxy": pd.DataFrame({"close": [100.0] * 400}, index=idx),
    "ibovespa": pd.DataFrame({"close": [120000.0] * 400}, index=idx),
    "sp500": pd.DataFrame({"close": [4000.0] * 400}, index=idx),
    "oil_wti": pd.DataFrame({"close": [80.0] * 400}, index=idx),
    "hy_oas": pd.DataFrame({"value": [400.0] * 400}, index=idx),
    "ust_2y": pd.DataFrame({"value": [4.0] * 400}, index=idx),
    "ust_10y": pd.DataFrame({"value": [4.5] * 400}, index=idx),
    "cftc_brl": pd.DataFrame({"value": [0.0] * 400}, index=idx),
    "bcb_flow": pd.DataFrame({"value": [0.0] * 400}, index=idx),
    "ust_5y": pd.DataFrame({"value": [4.2] * 400}, index=idx),
    "usdbrl_ptax": pd.DataFrame({"close": [5.0] * 400}, index=idx),
    "di_curve": {},
    "_as_of_date": date(2023, 7, 31),
}
features = engine.compute(data, date(2023, 7, 31))
assert "vix_level" in features
assert "_regime_components" in features
assert "_correlation_pairs" in features
assert "_sentiment_components" in features
assert isinstance(features["_sentiment_components"]["vix"], float)
print("CrossAssetFeatureEngine OK")
```
  </verify>
  <done>
- `src/agents/features/cross_asset_features.py` exists and imports cleanly
- `CrossAssetFeatureEngine().compute(data, as_of_date)` returns dict with all scalar features and 3 private keys
- All errors caught — no exceptions raised on NaN/None/empty inputs
- `_sentiment_components` values in [0, 100] or np.nan
- `_regime_components` values are z-scores (float or np.nan)
  </done>
</task>

<task type="auto">
  <name>Task 2: CrossAssetAgent, RegimeDetectionModel, CorrelationAnalysis, RiskSentimentIndex, features/__init__.py update, and unit tests</name>
  <files>
    src/agents/cross_asset_agent.py
    src/agents/features/__init__.py
    tests/test_cross_asset_agent.py
  </files>
  <action>
**File 1: `src/agents/cross_asset_agent.py`**

Mirror `src/agents/fx_agent.py` structure exactly. Module docstring explains the 3 signals.

**`RegimeDetectionModel`:**
- `SIGNAL_ID = "CROSSASSET_REGIME"`
- `run(features, as_of_date) -> AgentSignal`
- Reads `features["_regime_components"]` — dict[str, float] of factor z-scores
- Computes `composite = np.nanmean(list(raw.values()))` (skips NaN factors)
- Score = `float(np.clip(composite / 2.0, -1.0, 1.0))` — note: positive composite means risk-OFF factors are elevated, so score maps: large positive composite = risk-off → `direction = SHORT` (risk assets), large negative = risk-on → `direction = LONG`
- Direction thresholds: score > 0.2 → SHORT (risk-off); score < -0.2 → LONG (risk-on); else NEUTRAL
- `confidence = min(1.0, abs(score) * 2.0)` — full confidence at ±0.5
- `value = round(score, 4)` — the [-1, +1] composite
- `horizon_days = 63`
- Metadata: `{"regime_score": score, "n_factors": count of non-NaN components, "components": {k: round(v,4) for k,v in raw.items() if not np.isnan(v)}}`
- NO_SIGNAL if _regime_components is None or all values are NaN

**`CorrelationAnalysis`:**
- `SIGNAL_ID = "CROSSASSET_CORRELATION"`
- `WINDOW = 63`, `BREAK_Z = 2.0`, `MIN_OBS = 130`
- `run(features, as_of_date) -> AgentSignal`
- Reads `features["_correlation_pairs"]` — dict[str, tuple[pd.Series, pd.Series] | None]
- For each non-None pair, call `_compute_corr_break(series_x, series_y)`:
  ```python
  def _compute_corr_break(self, sx, sy):
      aligned = pd.concat([sx, sy], axis=1).dropna()
      if len(aligned) < self.MIN_OBS:
          return float("nan"), float("nan"), False
      x, y = aligned.iloc[:, 0], aligned.iloc[:, 1]
      roll_corr = x.rolling(self.WINDOW).corr(y).dropna()
      if len(roll_corr) < self.WINDOW:
          return float("nan"), float("nan"), False
      current = float(roll_corr.iloc[-1])
      hist = roll_corr.iloc[-self.WINDOW-1:-1]
      hist_mean, hist_std = float(hist.mean()), float(hist.std())
      z = (current - hist_mean) / hist_std if hist_std > 1e-8 else 0.0
      return current, z, abs(z) > self.BREAK_Z
  ```
- Break detected if any pair has `is_break=True`
- `value` = max |z| across all pairs (float); if no pairs have data → NO_SIGNAL
- `direction`: if break detected → NEUTRAL (correlation breaks are regime-neutral alerts, not directional)
- `strength`: STRONG if max_z > 3.0, MODERATE if > 2.0, WEAK if > 1.5, NO_SIGNAL if < BREAK_Z
- `confidence = min(1.0, max_z / 4.0)`
- Metadata: `{"pairs_checked": N, "breaks_detected": [pair_names], "max_z": max_z, "correlations": {pair: round(current, 4)}}`
- NO_SIGNAL if _correlation_pairs is None/empty or no pairs have sufficient data

**`RiskSentimentIndex`:**
- `SIGNAL_ID = "CROSSASSET_SENTIMENT"`
- `WEIGHTS = {"vix": 0.25, "hy_oas": 0.20, "dxy": 0.15, "cftc_brl": 0.15, "em_flows": 0.15, "credit_proxy": 0.10}`
- `run(features, as_of_date) -> AgentSignal`
- Reads `features["_sentiment_components"]` — dict[str, float] with subscores in [0, 100]
- Compute weighted mean skipping NaN components (renormalize weights over available components)
- `composite_score = weighted_mean` in [0, 100]
- `direction`: score < 30 → SHORT (fear = risk-off = short risk assets); score > 70 → LONG (greed = risk-on); else NEUTRAL
- `confidence = abs(composite_score - 50) / 50` — distance from neutral 50 maps to [0, 1]
- `value = round(composite_score, 2)` — the 0-100 composite
- `horizon_days = 21`
- Metadata: `{"composite_score": composite_score, "components": {k: round(v, 2) for k,v in components.items() if not np.isnan(v)}, "n_components": count}`
- NO_SIGNAL if _sentiment_components is None or all NaN

**`CrossAssetAgent`:**
- `AGENT_ID = "cross_asset_agent"`, `AGENT_NAME = "Cross-Asset Agent"`
- Constructor: `__init__(self, loader: PointInTimeDataLoader)` — stores loader, creates feature engine and 3 model instances
- `load_data(self, as_of_date: date) -> dict[str, Any]`:
  Use `_safe_load` pattern from FxEquilibriumAgent. Load:
  ```python
  _safe_load("vix", loader.get_market_data, "VIX", as_of_date, lookback_days=756)
  _safe_load("dxy", loader.get_market_data, "DXY", as_of_date, lookback_days=756)
  _safe_load("ibovespa", loader.get_market_data, "IBOVESPA", as_of_date, lookback_days=756)
  _safe_load("sp500", loader.get_market_data, "SP500", as_of_date, lookback_days=756)
  _safe_load("oil_wti", loader.get_market_data, "OIL_WTI", as_of_date, lookback_days=756)
  _safe_load("usdbrl_ptax", loader.get_market_data, "USDBRL_PTAX", as_of_date, lookback_days=756)
  _safe_load("hy_oas", loader.get_macro_series, "FRED-BAMLH0A0HYM2", as_of_date, lookback_days=756)
  _safe_load("ust_2y", loader.get_macro_series, "FRED-DGS2", as_of_date, lookback_days=756)
  _safe_load("ust_10y", loader.get_macro_series, "FRED-DGS10", as_of_date, lookback_days=756)
  _safe_load("ust_5y", loader.get_macro_series, "FRED-DGS5", as_of_date, lookback_days=756)
  _safe_load("cftc_brl", loader.get_flow_data, "CFTC_6L_LEVERAGED_NET", as_of_date, lookback_days=756)
  _safe_load("bcb_flow", loader.get_flow_data, "BR_FX_FLOW_COMMERCIAL", as_of_date, lookback_days=365)
  # DI curve for credit proxy
  try:
      data["di_curve"] = loader.get_curve("DI", as_of_date)
  except Exception as exc:
      self.log.warning("di_curve_load_failed", error=str(exc))
      data["di_curve"] = {}
  data["_as_of_date"] = as_of_date
  ```
- `compute_features(self, data)` — delegates to `self.feature_engine.compute(data, data["_as_of_date"])`
- `run_models(self, features) -> list[AgentSignal]`:
  ```python
  as_of_date = features["_as_of_date"]
  signals = []
  signals.append(self.regime_model.run(features, as_of_date))
  signals.append(self.correlation_model.run(features, as_of_date))
  signals.append(self.sentiment_model.run(features, as_of_date))
  return signals
  ```
- `generate_narrative(self, signals, features) -> str`:
  Return f-string: `"Cross-Asset Assessment ({as_of}): Regime={regime_dir} ({regime_score:.2f}). Sentiment={sentiment_score:.0f}/100 ({sentiment_dir}). Correlation breaks={n_breaks}."`

**File 2: `src/agents/features/__init__.py`** — Add conditional import for CrossAssetFeatureEngine at the end, following the exact pattern of FxFeatureEngine:
```python
# CrossAssetFeatureEngine is added in plan 10-01; import conditionally
try:
    from src.agents.features.cross_asset_features import CrossAssetFeatureEngine  # type: ignore[import]
    __all__ = [*__all__, "CrossAssetFeatureEngine"]
except ImportError:
    pass
```

**File 3: `tests/test_cross_asset_agent.py`** — 15+ unit tests, no DB required. Mirror `tests/test_fx_agent.py` pattern:
- `AS_OF = date(2024, 6, 30)`
- Helper `make_price_series(n, val, freq="B")` — builds DataFrame with `close` column
- Helper `make_value_series(n, val)` — builds DataFrame with `value` column
- Helper `make_regime_components(vix_z, hy_z, dxy_z, ...)` — dict of z-scores

Tests to include:
1. `test_feature_engine_returns_all_keys` — compute with full data, assert all scalar keys and private keys present
2. `test_feature_engine_handles_none_data` — pass all None values, assert returns dict without raising
3. `test_regime_model_risk_off_direction` — large positive z-scores in components → SHORT direction
4. `test_regime_model_risk_on_direction` — large negative z-scores → LONG direction
5. `test_regime_model_neutral_zone` — z-scores near zero → NEUTRAL
6. `test_regime_model_no_signal_empty_components` — None components → NO_SIGNAL
7. `test_regime_model_value_clipped_to_bounds` — extreme components → score in [-1, 1]
8. `test_correlation_no_signal_insufficient_history` — short series (< 130 obs) → NO_SIGNAL
9. `test_correlation_break_detected` — series with clear correlation shift → break detected
10. `test_correlation_no_break_stable_pairs` — stable correlated series → NEUTRAL or weak signal
11. `test_sentiment_fear_extreme` — all components near 0 → score < 30, SHORT direction
12. `test_sentiment_greed_extreme` — all components near 100 → score > 70, LONG direction
13. `test_sentiment_handles_partial_nan` — some NaN components → computes weighted mean from available
14. `test_sentiment_no_signal_all_nan` — all components NaN → NO_SIGNAL
15. `test_cross_asset_agent_run_models_returns_three_signals` — mock loader, verify 3 signals returned with correct signal_ids
  </action>
  <verify>
```bash
# Imports work
python -c "from src.agents.cross_asset_agent import CrossAssetAgent, RegimeDetectionModel, CorrelationAnalysis, RiskSentimentIndex; print('imports OK')"
# Features init exports
python -c "from src.agents.features import CrossAssetFeatureEngine; print('features init OK')"
# Tests pass
python -m pytest tests/test_cross_asset_agent.py -v 2>&1 | tail -20
```
  </verify>
  <done>
- `src/agents/cross_asset_agent.py` exports CrossAssetAgent, RegimeDetectionModel, CorrelationAnalysis, RiskSentimentIndex
- CrossAssetAgent.AGENT_ID == "cross_asset_agent" (matches registry EXECUTION_ORDER entry at position 5)
- RegimeDetectionModel.SIGNAL_ID == "CROSSASSET_REGIME", score value in [-1, 1]
- CorrelationAnalysis.SIGNAL_ID == "CROSSASSET_CORRELATION", fires on |z| > 2.0 breaks
- RiskSentimentIndex.SIGNAL_ID == "CROSSASSET_SENTIMENT", value in [0, 100]
- `src/agents/features/__init__.py` conditionally exports CrossAssetFeatureEngine
- All 15+ unit tests pass with `python -m pytest tests/test_cross_asset_agent.py -v`
  </done>
</task>

</tasks>

<verification>
```bash
# All cross-asset imports
python -c "
from src.agents.cross_asset_agent import CrossAssetAgent, RegimeDetectionModel, CorrelationAnalysis, RiskSentimentIndex
from src.agents.features.cross_asset_features import CrossAssetFeatureEngine
from src.agents.features import CrossAssetFeatureEngine as CE2
from src.agents.registry import AgentRegistry
assert 'cross_asset_agent' in AgentRegistry.EXECUTION_ORDER
assert AgentRegistry.EXECUTION_ORDER[-1] == 'cross_asset_agent'
print('All assertions passed')
"

# Unit tests
python -m pytest tests/test_cross_asset_agent.py -v

# Signal IDs are correct
python -c "
from src.agents.cross_asset_agent import RegimeDetectionModel, CorrelationAnalysis, RiskSentimentIndex
assert RegimeDetectionModel.SIGNAL_ID == 'CROSSASSET_REGIME'
assert CorrelationAnalysis.SIGNAL_ID == 'CROSSASSET_CORRELATION'
assert RiskSentimentIndex.SIGNAL_ID == 'CROSSASSET_SENTIMENT'
print('Signal IDs OK')
"
```
</verification>

<success_criteria>
- CrossAssetFeatureEngine.compute() returns dict with vix_level, hy_oas_bps, dxy_level, ust_slope_bps, cftc_brl_net, bcb_flow_net, credit_proxy_bps, plus _regime_components, _correlation_pairs, _sentiment_components
- RegimeDetectionModel returns AgentSignal with CROSSASSET_REGIME, value in [-1.0, +1.0], LONG/SHORT/NEUTRAL direction
- CorrelationAnalysis detects |z| > 2.0 breaks across 5 asset pairs (USDBRL/DXY, DI/UST, IBOV/SP500, USDBRL/VIX, Oil/BRL)
- RiskSentimentIndex returns AgentSignal with CROSSASSET_SENTIMENT, value in [0, 100]
- 15+ unit tests pass without database connection
- `from src.agents.features import CrossAssetFeatureEngine` succeeds
- cross_asset_agent is last entry in AgentRegistry.EXECUTION_ORDER
</success_criteria>

<output>
After completion, create `.planning/phases/10-cross-asset-agent-backtesting-engine/10-01-SUMMARY.md`
</output>
