---
phase: 10-cross-asset-agent-backtesting-engine
plan: "02"
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backtesting/__init__.py
  - src/backtesting/engine.py
  - src/backtesting/portfolio.py
  - src/core/models/backtest_results.py
  - src/core/models/__init__.py
  - alembic/versions/004_add_strategy_signals_backtest.py
autonomous: true
requirements:
  - BACK-01
  - BACK-02
  - BACK-03
  - BACK-05
  - BACK-08

must_haves:
  truths:
    - "BacktestConfig is a frozen dataclass with start_date, end_date, initial_capital, rebalance_frequency, transaction_cost_bps=5.0, slippage_bps=2.0, max_leverage=1.0"
    - "BacktestEngine.run(strategy) iterates rebalance dates, calls strategy.generate_signals(as_of_date), applies portfolio.rebalance(), and appends to equity_curve"
    - "Portfolio.total_equity == cash + sum(positions.values()) at all times; positions stored as notional values not shares"
    - "Portfolio.rebalance() deducts transaction costs from cash: cost = abs(trade_notional) * (tc_bps + slip_bps) / 10_000"
    - "BacktestEngine enforces PIT: strategy receives as_of_date and must query PointInTimeDataLoader which enforces release_time <= as_of_date"
    - "Alembic migration 004 creates strategy_signals hypertable and backtest_results regular table; runs successfully against live DB"
    - "BacktestResultRecord ORM model exists and is exported from src/core/models/__init__.py"
  artifacts:
    - path: "src/backtesting/__init__.py"
      provides: "Package init re-exporting BacktestEngine, BacktestConfig, Portfolio"
      exports: ["BacktestEngine", "BacktestConfig", "Portfolio"]
    - path: "src/backtesting/engine.py"
      provides: "BacktestConfig frozen dataclass, BacktestEngine class with run() method"
      exports: ["BacktestConfig", "BacktestEngine"]
    - path: "src/backtesting/portfolio.py"
      provides: "Portfolio class with positions, cash, equity_curve, trade_log, mark_to_market(), rebalance()"
      exports: ["Portfolio"]
    - path: "src/core/models/backtest_results.py"
      provides: "BacktestResultRecord ORM model for backtest_results table"
      exports: ["BacktestResultRecord"]
    - path: "alembic/versions/004_add_strategy_signals_backtest.py"
      provides: "Alembic migration creating strategy_signals hypertable and backtest_results table"
  key_links:
    - from: "src/backtesting/engine.py"
      to: "src/backtesting/portfolio.py"
      via: "BacktestEngine.run() instantiates Portfolio and calls portfolio.rebalance()"
      pattern: "Portfolio\\(initial_capital"
    - from: "src/backtesting/engine.py"
      to: "src/agents/data_loader.py"
      via: "BacktestEngine stores loader reference; PIT enforcement comes from PointInTimeDataLoader"
      pattern: "PointInTimeDataLoader"
    - from: "src/core/models/__init__.py"
      to: "src/core/models/backtest_results.py"
      via: "import BacktestResultRecord for Alembic autogenerate"
      pattern: "BacktestResultRecord"
    - from: "alembic/versions/004_add_strategy_signals_backtest.py"
      to: "alembic/versions/003_add_agent_reports_table.py"
      via: "down_revision = 'c3d4e5f6g7h8'"
      pattern: "down_revision.*c3d4e5f6g7h8"
---

<objective>
Build the core backtesting engine infrastructure: BacktestConfig, BacktestEngine event loop, Portfolio class with position tracking and rebalancing, BacktestResultRecord ORM, and the Alembic migration creating strategy_signals and backtest_results tables.

Purpose: Provides the execution scaffold that Plan 10-03 will extend with metrics computation, reporting, and persistence. BacktestEngine is the primary consumer of PointInTimeDataLoader in a backtesting context.
Output: src/backtesting/ package (engine.py, portfolio.py, __init__.py), src/core/models/backtest_results.py, alembic migration 004
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/10-cross-asset-agent-backtesting-engine/10-RESEARCH.md

# Structural references — read these for exact patterns
@src/core/models/agent_reports.py
@src/core/models/__init__.py
@alembic/versions/003_add_agent_reports_table.py
@alembic/versions/001_initial_schema.py
@src/agents/data_loader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: BacktestConfig, BacktestEngine, and Portfolio class</name>
  <files>
    src/backtesting/__init__.py
    src/backtesting/engine.py
    src/backtesting/portfolio.py
  </files>
  <action>
Create `src/backtesting/` as a new Python package with 3 files.

**`src/backtesting/portfolio.py`:**

```python
"""Portfolio state tracking for the backtesting engine.

Positions are stored as notional values (not shares) to simplify
rebalancing — no price lookup required during position access.
Portfolio never accesses the database directly; BacktestEngine passes
prices from PointInTimeDataLoader.
"""
from __future__ import annotations
from datetime import date
from typing import Any


class Portfolio:
    """Mutable in-memory portfolio state.

    Attributes:
        cash: Available cash (USD/BRL equivalent).
        positions: {ticker: current_notional_value}. Notional, not shares.
        equity_curve: [(date, total_equity)] appended each rebalance period.
        trade_log: [{date, ticker, direction, trade_notional, cost, entry_price, pnl}]
        _entry_prices: {ticker: avg_entry_price} for PnL computation.
        _last_prices: {ticker: last_known_price} for mark-to-market.
    """

    def __init__(self, initial_capital: float) -> None:
        self.cash: float = initial_capital
        self.positions: dict[str, float] = {}       # ticker -> notional value
        self.equity_curve: list[tuple[date, float]] = []
        self.trade_log: list[dict[str, Any]] = []
        self._entry_prices: dict[str, float] = {}   # ticker -> price at entry
        self._last_prices: dict[str, float] = {}    # ticker -> last known price

    @property
    def total_equity(self) -> float:
        """Cash plus sum of all position notional values."""
        return self.cash + sum(self.positions.values())

    def mark_to_market(self, prices: dict[str, float]) -> None:
        """Update position notional values based on new prices.

        For notional-based positions, mark-to-market adjusts the notional
        by the price return since last known price.

        Args:
            prices: {ticker: current_price}. Tickers missing from prices
                are unchanged (uses last known value — handles gaps).
        """
        for ticker, current_price in prices.items():
            if current_price <= 0:
                continue
            self._last_prices[ticker] = current_price
            if ticker in self.positions and self.positions[ticker] != 0:
                last_price = self._entry_prices.get(ticker, current_price)
                if last_price > 0:
                    price_return = current_price / last_price
                    self.positions[ticker] = self.positions[ticker] * price_return
                    self._entry_prices[ticker] = current_price

    def rebalance(
        self,
        target_weights: dict[str, float],
        prices: dict[str, float],
        config: Any,  # BacktestConfig (forward ref)
    ) -> None:
        """Apply target weights, compute trades, deduct transaction costs.

        Position limit enforcement: total absolute weight capped at
        config.max_leverage before computing trades.

        Steps:
        1. Enforce max_leverage: scale weights if sum(abs(w)) > max_leverage
        2. For each ticker in target_weights, compute target notional
        3. Compute trade_notional = target_notional - current_notional
        4. cost = abs(trade_notional) * (tc_bps + slip_bps) / 10_000
        5. Deduct cost from cash
        6. Set positions[ticker] = target_notional (skip if price unknown)
        7. Log trade to trade_log with estimated PnL for closed/reduced positions

        Args:
            target_weights: {ticker: weight} where weight in [-1, max_leverage].
            prices: {ticker: current_price}. Tickers without prices are skipped.
            config: BacktestConfig instance with cost parameters.
        """
        total_equity = self.total_equity
        if total_equity <= 0:
            return

        # Step 1: Enforce max_leverage
        total_abs_weight = sum(abs(w) for w in target_weights.values())
        if total_abs_weight > config.max_leverage and total_abs_weight > 0:
            scale = config.max_leverage / total_abs_weight
            target_weights = {k: v * scale for k, v in target_weights.items()}

        # Step 2-7: Apply rebalance per ticker
        rebalance_date = config.start_date  # placeholder; caller sets actual date
        # Note: BacktestEngine sets portfolio._rebalance_date before calling rebalance()
        rebalance_date = getattr(self, "_rebalance_date", date.today())

        for ticker, weight in target_weights.items():
            if ticker not in prices or prices[ticker] <= 0:
                continue

            target_notional = total_equity * weight
            current_notional = self.positions.get(ticker, 0.0)
            trade_notional = target_notional - current_notional

            if abs(trade_notional) < 1.0:  # skip trivial trades
                continue

            # Transaction cost + slippage
            cost = abs(trade_notional) * (
                config.transaction_cost_bps + config.slippage_bps
            ) / 10_000
            self.cash -= cost

            # PnL for reduced/closed positions (round-trip tracking)
            pnl = 0.0
            if current_notional != 0 and abs(trade_notional) > 0:
                entry_price = self._entry_prices.get(ticker, prices[ticker])
                current_price = prices[ticker]
                if entry_price > 0:
                    pnl = (current_price / entry_price - 1) * abs(current_notional)
                    # Only count PnL for the portion being closed
                    if abs(trade_notional) < abs(current_notional):
                        fraction = abs(trade_notional) / abs(current_notional)
                        pnl *= fraction

            # Log trade
            direction = "BUY" if trade_notional > 0 else "SELL"
            self.trade_log.append({
                "date": rebalance_date,
                "ticker": ticker,
                "direction": direction,
                "trade_notional": round(trade_notional, 2),
                "cost": round(cost, 2),
                "price": prices[ticker],
                "pnl": round(pnl, 2),
            })

            # Update position and entry price
            self.positions[ticker] = target_notional
            if trade_notional != 0:
                self._entry_prices[ticker] = prices[ticker]

        # Zero out tickers in positions but not in target_weights (full exit)
        for ticker in list(self.positions.keys()):
            if ticker not in target_weights:
                current_notional = self.positions[ticker]
                if abs(current_notional) > 1.0:
                    cost = abs(current_notional) * (
                        config.transaction_cost_bps + config.slippage_bps
                    ) / 10_000
                    self.cash -= cost
                    entry_price = self._entry_prices.get(ticker, prices.get(ticker, 1.0))
                    current_price = prices.get(ticker, entry_price)
                    pnl = (current_price / entry_price - 1) * abs(current_notional) if entry_price > 0 else 0.0
                    self.trade_log.append({
                        "date": rebalance_date,
                        "ticker": ticker,
                        "direction": "EXIT",
                        "trade_notional": round(-current_notional, 2),
                        "cost": round(cost, 2),
                        "price": current_price,
                        "pnl": round(pnl, 2),
                    })
                self.positions[ticker] = 0.0
                self._entry_prices.pop(ticker, None)
```

**`src/backtesting/engine.py`:**

```python
"""BacktestEngine and BacktestConfig for event-driven backtesting.

Point-in-time correctness is enforced by PointInTimeDataLoader:
strategy.generate_signals(as_of_date) calls loader.get_*() methods
which filter by release_time <= as_of_date. BacktestEngine passes
as_of_date to strategy — no future data can leak in.
"""
from __future__ import annotations
import logging
from dataclasses import dataclass, field
from datetime import date
from typing import Any, Optional, Protocol

import pandas as pd

from src.backtesting.portfolio import Portfolio
from src.agents.data_loader import PointInTimeDataLoader

logger = logging.getLogger(__name__)


@dataclass(frozen=True)
class BacktestConfig:
    """Immutable configuration for a backtest run."""
    start_date: date
    end_date: date
    initial_capital: float
    rebalance_frequency: str = "monthly"    # "daily", "weekly", "monthly"
    transaction_cost_bps: float = 5.0       # bps round-trip per trade
    slippage_bps: float = 2.0               # bps per trade
    max_leverage: float = 1.0               # max sum(abs(weights))


class StrategyProtocol(Protocol):
    """Protocol that all strategies must satisfy for BacktestEngine."""
    strategy_id: str

    def generate_signals(self, as_of_date: date) -> dict[str, float]:
        """Return {ticker: target_weight} for the given as_of_date.

        Only data with release_time <= as_of_date may be accessed.
        """
        ...


class BacktestEngine:
    """Event-driven backtesting engine with PIT enforcement.

    Iterates business-day rebalance dates from config.start_date to
    config.end_date, calling strategy.generate_signals(as_of_date) at
    each step. PIT correctness is guaranteed by PointInTimeDataLoader
    enforcing release_time <= as_of_date in all database queries.

    Usage:
        config = BacktestConfig(start_date=..., end_date=..., initial_capital=1_000_000.0)
        engine = BacktestEngine(config, loader)
        result = engine.run(strategy)
    """

    def __init__(self, config: BacktestConfig, loader: PointInTimeDataLoader) -> None:
        self.config = config
        self.loader = loader
        self._last_known_prices: dict[str, float] = {}  # price cache for gap filling

    def run(self, strategy: StrategyProtocol) -> "BacktestResult":
        """Execute the full backtest for a strategy.

        Returns BacktestResult with equity curve. Metrics are computed
        by calling compute_metrics() from src.backtesting.metrics — but
        BacktestEngine.run() returns a BacktestResult with equity_curve and
        trade_log populated; metrics are computed in Plan 10-03.

        For Plan 10-02, return a dict containing portfolio and config so
        Plan 10-03 can add compute_metrics(). Define a simple BacktestRawResult
        namedtuple here:

        BacktestRawResult(strategy_id, config, portfolio, rebalance_dates)

        Plan 10-03 replaces this with the full BacktestResult dataclass.
        """
        from collections import namedtuple
        BacktestRawResult = namedtuple(
            "BacktestRawResult", ["strategy_id", "config", "portfolio", "rebalance_dates"]
        )

        portfolio = Portfolio(initial_capital=self.config.initial_capital)
        rebalance_dates = self._get_rebalance_dates()

        logger.info(
            "backtest_starting",
            strategy_id=strategy.strategy_id,
            start=str(self.config.start_date),
            end=str(self.config.end_date),
            n_rebalance_dates=len(rebalance_dates),
        )

        for as_of_date in rebalance_dates:
            try:
                # PIT: strategy sees only data with release_time <= as_of_date
                # (enforced inside strategy.generate_signals via PointInTimeDataLoader)
                target_weights = strategy.generate_signals(as_of_date)

                # Get current prices (PIT enforced by loader)
                prices = self._get_prices(as_of_date, list(target_weights.keys()))

                # Mark-to-market at current prices
                if prices:
                    portfolio.mark_to_market(prices)

                # Apply rebalance with costs (sets _rebalance_date on portfolio)
                portfolio._rebalance_date = as_of_date
                portfolio.rebalance(target_weights, prices, self.config)

                # Record equity
                portfolio.equity_curve.append((as_of_date, portfolio.total_equity))

            except Exception as exc:
                logger.warning(
                    "backtest_step_failed",
                    as_of_date=str(as_of_date),
                    error=str(exc),
                )

        logger.info(
            "backtest_complete",
            strategy_id=strategy.strategy_id,
            n_equity_points=len(portfolio.equity_curve),
            final_equity=portfolio.equity_curve[-1][1] if portfolio.equity_curve else 0.0,
        )

        return BacktestRawResult(
            strategy_id=strategy.strategy_id,
            config=self.config,
            portfolio=portfolio,
            rebalance_dates=rebalance_dates,
        )

    def _get_rebalance_dates(self) -> list[date]:
        """Generate rebalance dates based on config.rebalance_frequency."""
        all_bdays = pd.bdate_range(
            start=self.config.start_date, end=self.config.end_date, freq="B"
        )
        if self.config.rebalance_frequency == "daily":
            return [d.date() for d in all_bdays]
        elif self.config.rebalance_frequency == "weekly":
            weekly = all_bdays.to_frame().resample("W").last()
            return [d.date() for d in weekly.index]
        elif self.config.rebalance_frequency == "monthly":
            monthly = all_bdays.to_frame().resample("ME").last()
            return [d.date() for d in monthly.index]
        else:
            raise ValueError(
                f"Unknown rebalance_frequency: {self.config.rebalance_frequency!r}. "
                "Use 'daily', 'weekly', or 'monthly'."
            )

    def _get_prices(self, as_of_date: date, tickers: list[str]) -> dict[str, float]:
        """Fetch PIT prices for tickers, falling back to last known price on gaps.

        Args:
            as_of_date: Reference date (PIT enforced by loader).
            tickers: List of ticker strings.

        Returns:
            {ticker: price} dict. Missing tickers use last known price if available.
        """
        prices: dict[str, float] = {}
        for ticker in tickers:
            try:
                df = self.loader.get_market_data(ticker, as_of_date, lookback_days=5)
                if df is not None and not df.empty and "close" in df.columns:
                    last_price = float(df["close"].dropna().iloc[-1])
                    if last_price > 0:
                        prices[ticker] = last_price
                        self._last_known_prices[ticker] = last_price
                elif ticker in self._last_known_prices:
                    prices[ticker] = self._last_known_prices[ticker]
            except Exception:
                if ticker in self._last_known_prices:
                    prices[ticker] = self._last_known_prices[ticker]
        return prices
```

**`src/backtesting/__init__.py`:**
```python
"""Backtesting engine for strategy validation with point-in-time correctness."""
from src.backtesting.engine import BacktestConfig, BacktestEngine
from src.backtesting.portfolio import Portfolio

__all__ = ["BacktestConfig", "BacktestEngine", "Portfolio"]
```
  </action>
  <verify>
```python
from datetime import date
from src.backtesting import BacktestConfig, BacktestEngine, Portfolio

# Portfolio tracks equity correctly
p = Portfolio(initial_capital=1_000_000.0)
assert abs(p.total_equity - 1_000_000.0) < 0.01

# BacktestConfig is frozen
config = BacktestConfig(
    start_date=date(2024, 1, 1), end_date=date(2024, 12, 31),
    initial_capital=1_000_000.0, rebalance_frequency="monthly"
)
assert config.transaction_cost_bps == 5.0
assert config.slippage_bps == 2.0
assert config.max_leverage == 1.0

# Rebalance deducts costs
p._rebalance_date = date(2024, 1, 31)
p.rebalance({"IBOVESPA": 0.5}, {"IBOVESPA": 100_000.0}, config)
assert p.cash < 1_000_000.0  # costs deducted
assert abs(p.positions.get("IBOVESPA", 0) - 500_000.0) < 1.0

# Date iteration
engine_dates = BacktestEngine.__new__(BacktestEngine)
engine_dates.config = config
dates = engine_dates._get_rebalance_dates()
assert len(dates) == 12  # 12 monthly dates in 2024
print("BacktestEngine and Portfolio OK")
```
  </verify>
  <done>
- `src/backtesting/__init__.py` exists and exports BacktestConfig, BacktestEngine, Portfolio
- `Portfolio(initial_capital=1_000_000.0).total_equity == 1_000_000.0`
- `Portfolio.rebalance()` deducts `abs(trade_notional) * (tc_bps + slip_bps) / 10_000` from cash
- `BacktestConfig` is a frozen dataclass with correct defaults
- `BacktestEngine._get_rebalance_dates()` returns 12 dates for monthly frequency over 2024
- `BacktestEngine._get_prices()` falls back to `_last_known_prices` when loader returns empty
- Positions stored as notional values (verified by rebalance test above)
  </done>
</task>

<task type="auto">
  <name>Task 2: BacktestResultRecord ORM, src/core/models/__init__.py update, and Alembic migration 004</name>
  <files>
    src/core/models/backtest_results.py
    src/core/models/__init__.py
    alembic/versions/004_add_strategy_signals_backtest.py
  </files>
  <action>
**File 1: `src/core/models/backtest_results.py`**

Mirror `src/core/models/agent_reports.py` structure exactly.

```python
"""Backtest results table — stores full backtest run results.

Regular PostgreSQL table (NOT a hypertable — low volume: one row per backtest run).
Equity curve and monthly returns stored as JSONB for flexible querying.
"""
from __future__ import annotations
from datetime import date, datetime
from typing import Optional

from sqlalchemy import Date, DateTime, Float, Integer, String, func
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.orm import Mapped, mapped_column

from .base import Base


class BacktestResultRecord(Base):
    """ORM model for the backtest_results table.

    Named BacktestResultRecord (not BacktestResult) to avoid collision
    with the BacktestResult dataclass in src.backtesting.metrics.
    """
    __tablename__ = "backtest_results"

    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True)
    strategy_id: Mapped[str] = mapped_column(String(50), nullable=False, index=True)
    start_date: Mapped[date] = mapped_column(Date, nullable=False)
    end_date: Mapped[date] = mapped_column(Date, nullable=False)
    initial_capital: Mapped[float] = mapped_column(Float, nullable=False)
    final_equity: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    total_return: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    annualized_return: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    annualized_volatility: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    sharpe_ratio: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    sortino_ratio: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    calmar_ratio: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    max_drawdown: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    win_rate: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    profit_factor: Mapped[Optional[float]] = mapped_column(Float, nullable=True)
    total_trades: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    equity_curve: Mapped[Optional[list]] = mapped_column(JSONB, nullable=True)
    monthly_returns: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)
    config_json: Mapped[Optional[dict]] = mapped_column(JSONB, nullable=True)
    created_at: Mapped[datetime] = mapped_column(
        DateTime(timezone=True), server_default=func.now()
    )

    def __repr__(self) -> str:
        return (
            f"<BacktestResultRecord("
            f"strategy_id={self.strategy_id!r}, "
            f"start_date={self.start_date}, "
            f"sharpe_ratio={self.sharpe_ratio})>"
        )
```

**File 2: `src/core/models/__init__.py`** — Add BacktestResultRecord import and __all__ entry. Append after AgentReportRecord line:
```python
from .backtest_results import BacktestResultRecord
```
And add `"BacktestResultRecord"` to `__all__` list.

**File 3: `alembic/versions/004_add_strategy_signals_backtest.py`**

Mirror `alembic/versions/003_add_agent_reports_table.py`. The `down_revision` MUST be `"c3d4e5f6g7h8"` (the revision ID of migration 003).

```python
"""add strategy_signals hypertable and backtest_results table

Revision ID: d4e5f6g7h8i9
Revises: c3d4e5f6g7h8
Create Date: 2026-02-21
"""
from typing import Sequence, Union

import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import JSONB
from alembic import op

revision: str = "d4e5f6g7h8i9"
down_revision: Union[str, None] = "c3d4e5f6g7h8"
branch_labels: Union[str, Sequence[str], None] = None
depends_on: Union[str, Sequence[str], None] = None


def upgrade() -> None:
    # -- strategy_signals: hypertable for per-strategy signal persistence --
    # (Schema only; signal writes added in Phase 11 when strategies are built)
    op.create_table(
        "strategy_signals",
        sa.Column("id", sa.BigInteger(), autoincrement=True, nullable=False),
        sa.Column("strategy_id", sa.String(50), nullable=False),
        sa.Column("signal_date", sa.Date(), nullable=False),
        sa.Column("ticker", sa.String(50), nullable=False),
        sa.Column("weight", sa.Float(), nullable=False),
        sa.Column("confidence", sa.Float(), nullable=True),
        sa.Column("metadata_json", sa.Text(), nullable=True),
        sa.PrimaryKeyConstraint("id", "signal_date", name="pk_strategy_signals"),
    )
    op.execute(
        "SELECT create_hypertable('strategy_signals', 'signal_date', "
        "chunk_time_interval => INTERVAL '1 year', if_not_exists => TRUE);"
    )
    op.create_index(
        "ix_strategy_signals_strategy_date",
        "strategy_signals",
        ["strategy_id", "signal_date"],
    )

    # -- backtest_results: regular table (low volume, one row per backtest run) --
    op.create_table(
        "backtest_results",
        sa.Column("id", sa.Integer(), autoincrement=True, nullable=False),
        sa.Column("strategy_id", sa.String(50), nullable=False),
        sa.Column("start_date", sa.Date(), nullable=False),
        sa.Column("end_date", sa.Date(), nullable=False),
        sa.Column("initial_capital", sa.Float(), nullable=False),
        sa.Column("final_equity", sa.Float(), nullable=True),
        sa.Column("total_return", sa.Float(), nullable=True),
        sa.Column("annualized_return", sa.Float(), nullable=True),
        sa.Column("annualized_volatility", sa.Float(), nullable=True),
        sa.Column("sharpe_ratio", sa.Float(), nullable=True),
        sa.Column("sortino_ratio", sa.Float(), nullable=True),
        sa.Column("calmar_ratio", sa.Float(), nullable=True),
        sa.Column("max_drawdown", sa.Float(), nullable=True),
        sa.Column("win_rate", sa.Float(), nullable=True),
        sa.Column("profit_factor", sa.Float(), nullable=True),
        sa.Column("total_trades", sa.Integer(), nullable=True),
        sa.Column("equity_curve", JSONB(), nullable=True),
        sa.Column("monthly_returns", JSONB(), nullable=True),
        sa.Column("config_json", JSONB(), nullable=True),
        sa.Column(
            "created_at",
            sa.DateTime(timezone=True),
            server_default=sa.func.now(),
        ),
        sa.PrimaryKeyConstraint("id", name="pk_backtest_results"),
    )
    op.create_index(
        "ix_backtest_results_strategy_id",
        "backtest_results",
        ["strategy_id"],
    )


def downgrade() -> None:
    op.drop_index("ix_backtest_results_strategy_id")
    op.drop_table("backtest_results")
    op.drop_index("ix_strategy_signals_strategy_date")
    op.drop_table("strategy_signals")
```

**Run the migration after writing the file:**
```bash
cd /home/user/Macro_Trading && alembic upgrade head
```
If migration fails due to DB connection (expected in some environments), document the failure in the summary and note the migration will run during execute-phase when DB is available.
  </action>
  <verify>
```bash
# ORM import
python -c "
from src.core.models import BacktestResultRecord
from src.core.models.backtest_results import BacktestResultRecord as BR2
assert BR2.__tablename__ == 'backtest_results'
print('ORM import OK')
"

# Migration file exists and has correct revision chain
python -c "
content = open('/home/user/Macro_Trading/alembic/versions/004_add_strategy_signals_backtest.py').read()
assert 'down_revision' in content and 'c3d4e5f6g7h8' in content
assert 'strategy_signals' in content
assert 'backtest_results' in content
assert 'create_hypertable' in content
print('Migration file OK')
"

# Run migration (if DB available)
cd /home/user/Macro_Trading && alembic upgrade head 2>&1 | tail -5
```
  </verify>
  <done>
- `src/core/models/backtest_results.py` exists with BacktestResultRecord ORM, `__tablename__ == "backtest_results"`
- `from src.core.models import BacktestResultRecord` succeeds
- `alembic/versions/004_add_strategy_signals_backtest.py` exists with `down_revision = "c3d4e5f6g7h8"`, creates both `strategy_signals` hypertable and `backtest_results` regular table
- `alembic upgrade head` succeeds (or failure documented if DB unavailable in this environment)
  </done>
</task>

</tasks>

<verification>
```bash
# Full import chain
python -c "
from src.backtesting import BacktestConfig, BacktestEngine, Portfolio
from src.core.models import BacktestResultRecord
print('All imports OK')
"

# BacktestConfig fields and defaults
python -c "
from datetime import date
from src.backtesting import BacktestConfig
c = BacktestConfig(start_date=date(2024,1,1), end_date=date(2024,12,31), initial_capital=1e6)
assert c.transaction_cost_bps == 5.0
assert c.slippage_bps == 2.0
assert c.max_leverage == 1.0
assert c.rebalance_frequency == 'monthly'
print('BacktestConfig defaults OK')
"

# Portfolio PIT isolation (engine passes as_of_date to strategy)
python -c "
from datetime import date
from src.backtesting import Portfolio, BacktestConfig
p = Portfolio(1_000_000.0)
config = BacktestConfig(date(2024,1,1), date(2024,12,31), 1_000_000.0)
p._rebalance_date = date(2024, 1, 31)
prices = {'IBOVESPA': 100_000.0}
p.rebalance({'IBOVESPA': 1.0}, prices, config)
assert abs(p.positions['IBOVESPA'] - 1_000_000.0) < 100  # within costs
total_cost = 1_000_000.0 * (5.0 + 2.0) / 10_000
assert abs(p.cash - (-total_cost)) < 1.0  # cash = 0 - cost
print('Portfolio rebalance PIT OK')
"
```
</verification>

<success_criteria>
- `src/backtesting/` package exists with engine.py, portfolio.py, __init__.py
- BacktestConfig is a frozen dataclass: `BacktestConfig(start_date, end_date, initial_capital)` works with defaults
- Portfolio.total_equity == cash + sum(positions.values()) at all times
- Portfolio.rebalance() correctly deducts transaction costs + slippage and logs to trade_log
- BacktestEngine._get_rebalance_dates() returns correct counts: 12 for monthly/2024, 52 for weekly
- BacktestEngine._get_prices() forward-fills with _last_known_prices on empty returns
- BacktestResultRecord ORM importable from src.core.models with correct __tablename__
- Migration 004 exists with correct down_revision chain and creates both tables
</success_criteria>

<output>
After completion, create `.planning/phases/10-cross-asset-agent-backtesting-engine/10-02-SUMMARY.md`
</output>
