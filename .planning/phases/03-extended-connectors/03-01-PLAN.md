---
phase: 03-extended-connectors
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/connectors/bcb_fx_flow.py
  - tests/connectors/test_bcb_fx_flow.py
  - tests/fixtures/bcb_fx_flow_sample.json
  - src/connectors/stn_fiscal.py
  - tests/connectors/test_stn_fiscal.py
  - tests/fixtures/stn_fiscal_sample.json
autonomous: true
requirements:
  - CONN-12
  - CONN-07

must_haves:
  truths:
    - "BCB FX Flow connector fetches commercial, financial, total FX flows and BCB swap stock from 4 BCB SGS series"
    - "BCB FX Flow connector stores records to flow_data table with correct flow_type per series"
    - "STN Fiscal connector fetches primary balance, debt/GDP, revenue/expenditure from 4+ BCB SGS fiscal series"
    - "STN Fiscal connector stores records to fiscal_data table with correct fiscal_metric per series"
    - "Both connectors use ON CONFLICT DO NOTHING for idempotent writes"
    - "Both connectors have passing tests with respx mocks"
  artifacts:
    - path: "src/connectors/bcb_fx_flow.py"
      provides: "BCB FX Flow connector with 4 SGS series"
      min_lines: 100
    - path: "tests/connectors/test_bcb_fx_flow.py"
      provides: "BCB FX Flow tests with respx mocks"
      min_lines: 50
    - path: "src/connectors/stn_fiscal.py"
      provides: "STN Fiscal connector with BCB SGS fiscal series"
      min_lines: 100
    - path: "tests/connectors/test_stn_fiscal.py"
      provides: "STN Fiscal tests with respx mocks"
      min_lines: 50
  key_links:
    - from: "src/connectors/bcb_fx_flow.py"
      to: "src/core/models/flow_data.py"
      via: "_bulk_insert with FlowData model"
      pattern: "_bulk_insert.*FlowData.*uq_flow_data_natural_key"
    - from: "src/connectors/stn_fiscal.py"
      to: "src/core/models/fiscal_data.py"
      via: "_bulk_insert with FiscalData model"
      pattern: "_bulk_insert.*FiscalData.*uq_fiscal_data_natural_key"
---

<objective>
Implement the BCB FX Flow connector (CONN-12) and STN Fiscal connector (CONN-07) -- two simpler connectors that reuse the BCB SGS API pattern from Phase 2 but store to different target tables (flow_data and fiscal_data).

Purpose: These connectors complete the Brazilian FX flow and fiscal data coverage. Both use the same BCB SGS API (`api.bcb.gov.br/dados/serie/bcdata.sgs.{code}/dados`) already proven in Phase 2, making them the lowest-risk Phase 3 connectors.

Output: Two working connectors with tests, fetching from BCB SGS and storing to flow_data and fiscal_data tables respectively.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-extended-connectors/03-RESEARCH.md

# Pattern reference -- BCB SGS connector (same API, different target table)
@src/connectors/base.py
@src/connectors/bcb_sgs.py

# Target ORM models
@src/core/models/flow_data.py
@src/core/models/fiscal_data.py
@src/core/models/data_sources.py
@src/core/models/series_metadata.py

# Test infrastructure
@tests/connectors/conftest.py
@src/core/utils/parsing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: BCB FX Flow connector (CONN-12)</name>
  <files>
    src/connectors/bcb_fx_flow.py
    tests/connectors/test_bcb_fx_flow.py
    tests/fixtures/bcb_fx_flow_sample.json
  </files>
  <action>
Create `src/connectors/bcb_fx_flow.py` implementing `BcbFxFlowConnector` that inherits from `BaseConnector` (NOT from BcbSgsConnector).

**Class attributes:**
- `SOURCE_NAME = "BCB_FX_FLOW"`
- `BASE_URL = "https://api.bcb.gov.br"`
- `RATE_LIMIT_PER_SECOND = 3.0`

**Series registry (dict mapping series_key -> BCB SGS code):**
- `"BR_FX_FLOW_COMMERCIAL": 22704` (commercial FX flow)
- `"BR_FX_FLOW_FINANCIAL": 22705` (financial FX flow)
- `"BR_FX_FLOW_TOTAL": 22706` (total FX flow)
- `"BR_BCB_SWAP_STOCK": 12070` (BCB swap stock position)

**`fetch()` method:**
- Iterate over all series in the registry (or a subset if `series_ids` kwarg provided)
- For each series, call BCB SGS API: `GET /dados/serie/bcdata.sgs.{code}/dados?formato=json&dataInicial={DD/MM/YYYY}&dataFinal={DD/MM/YYYY}`
- Parse response: `data` field is DD/MM/YYYY date string, `valor` is period-decimal value string
- Use `parse_numeric_value(raw_value, ".")` from `src/core/utils/parsing.py`
- Tag each record with `_series_key` for the store() method
- Include date range chunking (reuse the same logic as BcbSgsConnector._chunk_date_range with 10-year max)
- Rate-limit with `asyncio.sleep(1.0 / RATE_LIMIT_PER_SECOND)` between series

**Flow type mapping (series_key -> flow_type):**
- `"BR_FX_FLOW_COMMERCIAL"` -> `"FX_COMMERCIAL"`
- `"BR_FX_FLOW_FINANCIAL"` -> `"FX_FINANCIAL"`
- `"BR_FX_FLOW_TOTAL"` -> `"FX_TOTAL"`
- `"BR_BCB_SWAP_STOCK"` -> `"BCB_SWAP_STOCK"`

**`store()` method:**
- Ensure data_source row exists (same pattern as BcbSgsConnector._ensure_data_source)
- Ensure series_metadata rows exist for each series key
- Build insert records with: `series_id`, `observation_date`, `value`, `flow_type` (from mapping), `unit="USD_MM"`, `release_time`
- Use `_bulk_insert(FlowData, records, "uq_flow_data_natural_key")`

**Test file** (`tests/connectors/test_bcb_fx_flow.py`):
- Create fixture `tests/fixtures/bcb_fx_flow_sample.json` with sample BCB SGS response (list of `{"data": "06/01/2025", "valor": "1234.5"}` entries)
- Test fetch parses dates and values correctly
- Test fetch with empty response returns empty list
- Test fetch skips invalid date/value entries
- Use respx mocking with `base_url="https://api.bcb.gov.br"`
  </action>
  <verify>
Run `python -m pytest tests/connectors/test_bcb_fx_flow.py -v` -- all tests pass.
Verify `BcbFxFlowConnector` is importable: `python -c "from src.connectors.bcb_fx_flow import BcbFxFlowConnector; print('OK')"`
  </verify>
  <done>
BCB FX Flow connector fetches 4 series from BCB SGS API, parses DD/MM/YYYY dates and period-decimal values, maps each series to a flow_type, and stores to flow_data via _bulk_insert with ON CONFLICT DO NOTHING. All tests pass with respx mocks.
  </done>
</task>

<task type="auto">
  <name>Task 2: STN Fiscal connector (CONN-07)</name>
  <files>
    src/connectors/stn_fiscal.py
    tests/connectors/test_stn_fiscal.py
    tests/fixtures/stn_fiscal_sample.json
  </files>
  <action>
Create `src/connectors/stn_fiscal.py` implementing `StnFiscalConnector` that inherits from `BaseConnector`.

**Class attributes:**
- `SOURCE_NAME = "STN_FISCAL"`
- `BASE_URL = "https://api.bcb.gov.br"`
- `RATE_LIMIT_PER_SECOND = 3.0`

**Series registry (dict mapping series_key -> (BCB SGS code, fiscal_metric, unit)):**
- `"BR_PRIMARY_BALANCE_MONTHLY": (5364, "PRIMARY_BALANCE", "BRL_MM")` -- central government primary balance
- `"BR_NET_DEBT_GDP_CENTRAL": (21864, "NET_DEBT_GDP", "PERCENT")` -- net debt / GDP central gov
- `"BR_GROSS_DEBT_GDP": (21865, "GROSS_DEBT_GDP", "PERCENT")` -- gross debt / GDP
- `"BR_TOTAL_REVENUE": (7620, "TOTAL_REVENUE", "BRL_MM")` -- total government revenue
- Optionally add 2-3 more fiscal series from the BCB SGS catalog if appropriate

**`fetch()` method:**
- Same BCB SGS API pattern as BCB FX Flow: `GET /dados/serie/bcdata.sgs.{code}/dados?formato=json&dataInicial=...&dataFinal=...`
- Parse DD/MM/YYYY dates, period-decimal values
- Tag records with `_series_key`
- Include 10-year date range chunking

**`store()` method:**
- Ensure data_source row exists
- Ensure series_metadata rows for each series key
- Build insert records with: `series_id`, `observation_date`, `value`, `fiscal_metric` (from registry tuple), `unit` (from registry tuple), `release_time`
- Use `_bulk_insert(FiscalData, records, "uq_fiscal_data_natural_key")`

**NOTE on Tesouro Transparente:** Per research, the Tesouro Transparente API (`apidatalake.tesouro.gov.br`) is unreliable. Use BCB SGS as the primary and only source for this connector. Debt composition from Tesouro Transparente is deferred -- do not block the connector on it.

**Test file** (`tests/connectors/test_stn_fiscal.py`):
- Create fixture `tests/fixtures/stn_fiscal_sample.json` with sample BCB SGS response
- Test fetch parses dates, values, and maps fiscal_metric correctly
- Test store builds records with correct fiscal_metric and unit per series
- Test empty response handling
- Use respx mocking with `base_url="https://api.bcb.gov.br"`
  </action>
  <verify>
Run `python -m pytest tests/connectors/test_stn_fiscal.py -v` -- all tests pass.
Verify `StnFiscalConnector` is importable: `python -c "from src.connectors.stn_fiscal import StnFiscalConnector; print('OK')"`
  </verify>
  <done>
STN Fiscal connector fetches 4+ fiscal series from BCB SGS API, parses responses correctly, maps each series to a fiscal_metric and unit, and stores to fiscal_data via _bulk_insert with ON CONFLICT DO NOTHING. Tests pass with respx mocks. Tesouro Transparente not needed.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/connectors/test_bcb_fx_flow.py tests/connectors/test_stn_fiscal.py -v` -- all tests pass
- Both connectors inherit from BaseConnector (not BcbSgsConnector)
- Both connectors use `_bulk_insert` with correct constraint names
- FlowData records have `flow_type` column populated
- FiscalData records have `fiscal_metric` column populated
- No new dependencies added to pyproject.toml
</verification>

<success_criteria>
- BcbFxFlowConnector passes all tests and correctly stores to flow_data table
- StnFiscalConnector passes all tests and correctly stores to fiscal_data table
- Both connectors follow the established BaseConnector pattern from Phase 2
- Both connectors handle date chunking, rate limiting, and idempotent writes
</success_criteria>

<output>
After completion, create `.planning/phases/03-extended-connectors/03-01-SUMMARY.md`
</output>
