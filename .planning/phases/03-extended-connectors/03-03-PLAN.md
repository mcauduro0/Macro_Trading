---
phase: 03-extended-connectors
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/connectors/b3_market_data.py
  - tests/connectors/test_b3_market_data.py
  - tests/fixtures/tesouro_direto_sample.json
  - src/connectors/treasury_gov.py
  - tests/connectors/test_treasury_gov.py
  - tests/fixtures/treasury_yield_sample.csv
autonomous: true
requirements:
  - CONN-05
  - CONN-09

must_haves:
  truths:
    - "B3/Tesouro Direto connector fetches DI swap curve from BCB SGS series #7805-7816 (12 tenors, 30d-360d)"
    - "B3/Tesouro Direto connector fetches NTN-B real rates from Tesouro Direto JSON API with CSV fallback"
    - "B3/Tesouro Direto connector stores curve data to curves table with curve_id='DI_PRE' and 'NTN_B_REAL'"
    - "DI swap rates are converted from percentage to decimal (13.50 -> 0.1350) before storage"
    - "US Treasury connector fetches daily nominal and real (TIPS) yield curves from Treasury.gov CSV"
    - "US Treasury connector computes breakeven yields (nominal - real) at matching tenors"
    - "US Treasury connector stores to curves table with curve_id='UST_NOM', 'UST_REAL', 'UST_BEI'"
    - "Both connectors handle missing/N/A values gracefully and skip them"
    - "Both connectors use ON CONFLICT DO NOTHING for idempotent writes"
  artifacts:
    - path: "src/connectors/b3_market_data.py"
      provides: "B3/Tesouro Direto connector for DI swap curve and NTN-B real rates"
      min_lines: 180
    - path: "tests/connectors/test_b3_market_data.py"
      provides: "B3/Tesouro Direto tests with respx mocks"
      min_lines: 80
    - path: "src/connectors/treasury_gov.py"
      provides: "US Treasury yield curve connector with breakeven computation"
      min_lines: 180
    - path: "tests/connectors/test_treasury_gov.py"
      provides: "US Treasury tests with respx mocks"
      min_lines: 80
  key_links:
    - from: "src/connectors/b3_market_data.py"
      to: "src/core/models/curves.py"
      via: "_bulk_insert with CurveData model"
      pattern: "_bulk_insert.*CurveData.*uq_curves_natural_key"
    - from: "src/connectors/treasury_gov.py"
      to: "src/core/models/curves.py"
      via: "_bulk_insert with CurveData model"
      pattern: "_bulk_insert.*CurveData.*uq_curves_natural_key"
    - from: "src/connectors/treasury_gov.py"
      to: "breakeven computation"
      via: "nominal[tenor] - real[tenor] at matching tenors"
      pattern: "UST_BEI"
---

<objective>
Implement the B3/Tesouro Direto connector (CONN-05) for the DI swap curve and NTN-B real rates, and the US Treasury connector (CONN-09) for nominal, real, and breakeven yield curves. Both store to the curves table.

Purpose: The DI swap curve and US Treasury yield curves are foundational for the Nelson-Siegel curve fitting, carry/rolldown analytics, and breakeven inflation calculations in Phase 5. These two connectors complete the curve data coverage for both Brazil and the US.

Output: Two working connectors with tests, producing CurveData records for DI_PRE, NTN_B_REAL, UST_NOM, UST_REAL, and UST_BEI curve IDs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-extended-connectors/03-RESEARCH.md

# Pattern reference
@src/connectors/base.py
@src/connectors/bcb_sgs.py

# Target ORM model
@src/core/models/curves.py
@src/core/models/data_sources.py
@src/core/models/series_metadata.py

# Test infrastructure
@tests/connectors/conftest.py
@src/core/utils/parsing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: B3/Tesouro Direto connector for DI swap curve and NTN-B real rates (CONN-05)</name>
  <files>
    src/connectors/b3_market_data.py
    tests/connectors/test_b3_market_data.py
    tests/fixtures/tesouro_direto_sample.json
  </files>
  <action>
Create `src/connectors/b3_market_data.py` implementing `B3MarketDataConnector` inheriting from `BaseConnector`.

**Class attributes:**
- `SOURCE_NAME = "B3_MARKET_DATA"`
- `BASE_URL = "https://api.bcb.gov.br"` (primary source for DI swap curve via SGS)
- `RATE_LIMIT_PER_SECOND = 3.0`
- `TESOURO_DIRETO_URL = "https://www.tesourodireto.com.br/json/br/com/b3/tesourodireto/service/api/treasurybondsinfo.json"`

**DI Swap Curve registry (series_name -> (SGS code, tenor_label, tenor_days)):**
```python
DI_SWAP_REGISTRY = {
    "DI_SWAP_30D":  (7805, "1M",  30),
    "DI_SWAP_60D":  (7806, "2M",  60),
    "DI_SWAP_90D":  (7807, "3M",  90),
    "DI_SWAP_120D": (7808, "4M",  120),
    "DI_SWAP_150D": (7809, "5M",  150),
    "DI_SWAP_180D": (7810, "6M",  180),
    "DI_SWAP_210D": (7811, "7M",  210),
    "DI_SWAP_240D": (7812, "8M",  240),
    "DI_SWAP_270D": (7813, "9M",  270),
    "DI_SWAP_300D": (7814, "10M", 300),
    "DI_SWAP_330D": (7815, "11M", 330),
    "DI_SWAP_360D": (7816, "12M", 360),
}
```

**`fetch_di_curve()` method:**
- For each DI swap series in the registry:
  - Fetch from BCB SGS API: `GET /dados/serie/bcdata.sgs.{code}/dados?formato=json&dataInicial=...&dataFinal=...`
  - Parse DD/MM/YYYY dates and period-decimal values
  - **CRITICAL: Convert rate from percentage to decimal -- divide by 100** (e.g., 13.50 -> 0.1350)
  - Build CurveData-compatible record:
    - `curve_id = "DI_PRE"`
    - `curve_date = observation_date`
    - `tenor_days` from registry
    - `tenor_label` from registry
    - `rate = value / 100.0`
    - `curve_type = "swap"`
    - `source = "BCB_SGS"`
- Include date range chunking (10-year max)
- Rate-limit between series: `asyncio.sleep(1.0 / RATE_LIMIT_PER_SECOND)`

**`fetch_ntnb_rates()` method:**
- Try Tesouro Direto JSON endpoint first:
  - `GET {TESOURO_DIRETO_URL}` with User-Agent header `"Mozilla/5.0 (compatible; MacroTrading/1.0)"`
  - Parse JSON response: look for bonds with "NTN-B" in the name
  - Extract `TxTR` or `rentabilidade` (real yield %) and maturity date
  - Convert maturity date to tenor_days from curve_date
  - Build CurveData records: `curve_id="NTN_B_REAL"`, `curve_type="sovereign_real"`, `source="TESOURO_DIRETO"`
  - Rate is already in % from Tesouro Direto -- divide by 100
- On failure (403, 404, timeout): log warning and return empty list. Do NOT block the connector -- NTN-B is a best-effort source per research.

**`fetch()` method:**
- Call `fetch_di_curve(start_date, end_date)` -> list of DI_PRE records
- Call `fetch_ntnb_rates()` -> list of NTN_B_REAL records (may be empty)
- Return combined list

**`store()` method:**
- Use `_bulk_insert(CurveData, records, "uq_curves_natural_key")` directly
- CurveData records don't use series_id (CurveData has its own natural key: curve_id + curve_date + tenor_days)
- No need for _ensure_data_source or _ensure_series_metadata (curves table uses curve_id string, not FK)

**Test file** (`tests/connectors/test_b3_market_data.py`):
- Create fixture `tests/fixtures/tesouro_direto_sample.json` with sample Tesouro Direto response
- Test DI swap curve: mock BCB SGS responses for 2 tenors, verify rate is divided by 100
- Test DI swap curve: verify curve_id="DI_PRE", correct tenor_label and tenor_days
- Test NTN-B: mock Tesouro Direto JSON response, verify curve_id="NTN_B_REAL"
- Test NTN-B fallback: mock 404 from Tesouro Direto, verify empty list returned (no crash)
- Test empty BCB SGS response handling
- Use respx mocking
  </action>
  <verify>
Run `python -m pytest tests/connectors/test_b3_market_data.py -v` -- all tests pass.
Verify `B3MarketDataConnector` is importable: `python -c "from src.connectors.b3_market_data import B3MarketDataConnector; print('OK')"`
Verify DI registry has 12 tenors: `python -c "from src.connectors.b3_market_data import B3MarketDataConnector; assert len(B3MarketDataConnector.DI_SWAP_REGISTRY) == 12; print('12 tenors OK')"`
  </verify>
  <done>
B3/Tesouro Direto connector fetches DI swap curve from 12 BCB SGS series (30d-360d) with rate/100 conversion, and NTN-B real rates from Tesouro Direto JSON with graceful fallback. Stores to curves table with curve_id DI_PRE and NTN_B_REAL. Tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: US Treasury yield curve connector (CONN-09)</name>
  <files>
    src/connectors/treasury_gov.py
    tests/connectors/test_treasury_gov.py
    tests/fixtures/treasury_yield_sample.csv
  </files>
  <action>
Create `src/connectors/treasury_gov.py` implementing `TreasuryGovConnector` inheriting from `BaseConnector`.

**Class attributes:**
- `SOURCE_NAME = "TREASURY_GOV"`
- `BASE_URL = "https://home.treasury.gov"`
- `RATE_LIMIT_PER_SECOND = 2.0`
- `TIMEOUT_SECONDS = 60.0` (Treasury CSV can be slow)

**URL templates:**
```python
NOMINAL_URL = (
    "/resource-center/data-chart-center/interest-rates/"
    "daily-treasury-rates.csv/all/{year}"
    "?type=daily_treasury_yield_curve"
    "&field_tdr_date_value={year}&page&_format=csv"
)
REAL_URL = (
    "/resource-center/data-chart-center/interest-rates/"
    "daily-treasury-rates.csv/all/{year}"
    "?type=daily_treasury_real_yield_curve"
    "&field_tdr_date_value={year}&page&_format=csv"
)
```

**Tenor mapping (CSV column name -> (tenor_label, tenor_days)):**
```python
TENOR_MAP = {
    "1 Mo": ("1M", 30), "2 Mo": ("2M", 60), "3 Mo": ("3M", 90),
    "4 Mo": ("4M", 120), "6 Mo": ("6M", 180), "1 Yr": ("1Y", 365),
    "2 Yr": ("2Y", 730), "3 Yr": ("3Y", 1095), "5 Yr": ("5Y", 1825),
    "7 Yr": ("7Y", 2555), "10 Yr": ("10Y", 3650), "20 Yr": ("20Y", 7300),
    "30 Yr": ("30Y", 10950),
}
```
Note: Skip unknown columns dynamically (Treasury added 1.5 Mo in Feb 2025).

**`_fetch_curve_csv()` private method:**
- Accepts `url_template: str`, `year: int`, `curve_id: str`, `curve_type: str`
- Fetch CSV: `GET url_template.format(year=year)`
- Parse with `pandas.read_csv(io.StringIO(response.text))` via `asyncio.to_thread` to not block event loop
- For each row in the DataFrame:
  - Parse Date column: `pd.to_datetime(row["Date"]).date()`
  - For each column in TENOR_MAP that exists in the CSV:
    - Get rate value; skip if NaN, empty, or "N/A"
    - Build CurveData record: `curve_id`, `curve_date`, `tenor_days`, `tenor_label`, `rate=float(val)/100.0`, `curve_type`, `source="TREASURY_GOV"`
- Return list of records

**`fetch()` method:**
- Determine year range from start_date.year to end_date.year
- For each year:
  - Call `_fetch_curve_csv(NOMINAL_URL, year, "UST_NOM", "sovereign_nominal")`
  - Call `_fetch_curve_csv(REAL_URL, year, "UST_REAL", "sovereign_real")`
- Filter records to be within [start_date, end_date]
- **Compute breakeven yield curve:**
  - Group nominal and real records by (curve_date, tenor_label)
  - At matching tenors (typically 5Y, 7Y, 10Y, 20Y, 30Y -- where both nominal and real exist):
    - `breakeven_rate = nominal_rate - real_rate`
    - Build CurveData record: `curve_id="UST_BEI"`, `curve_type="breakeven"`, same curve_date and tenor
- Return nominal + real + breakeven records combined

**`store()` method:**
- Use `_bulk_insert(CurveData, records, "uq_curves_natural_key")` directly (same as B3 connector)

**Test file** (`tests/connectors/test_treasury_gov.py`):
- Create fixture `tests/fixtures/treasury_yield_sample.csv` with 3-5 rows of sample Treasury yield data, including some "N/A" and empty cells
- Test nominal curve parsing: correct number of records, rates divided by 100
- Test N/A and empty values are skipped (not parsed as float)
- Test breakeven computation: `UST_BEI` rate = nominal - real at matching tenors
- Test date filtering: records outside start/end range are excluded
- Test unknown columns (e.g., "1.5 Mo") are skipped without error
- Use respx mocking with `base_url="https://home.treasury.gov"`
  </action>
  <verify>
Run `python -m pytest tests/connectors/test_treasury_gov.py -v` -- all tests pass.
Verify `TreasuryGovConnector` is importable: `python -c "from src.connectors.treasury_gov import TreasuryGovConnector; print('OK')"`
Verify TENOR_MAP has 13 tenors: `python -c "from src.connectors.treasury_gov import TreasuryGovConnector; assert len(TreasuryGovConnector.TENOR_MAP) == 13; print('13 tenors OK')"`
  </verify>
  <done>
US Treasury connector fetches nominal and TIPS yield curves from Treasury.gov CSV by year, computes breakeven (nominal - real), handles N/A values and dynamic columns gracefully, and stores all three curve sets (UST_NOM, UST_REAL, UST_BEI) to curves table. Tests pass.
  </done>
</task>

</tasks>

<verification>
- `python -m pytest tests/connectors/test_b3_market_data.py tests/connectors/test_treasury_gov.py -v` -- all tests pass
- B3: DI rates divided by 100 (percentage to decimal), 12 tenors in registry
- B3: NTN-B fallback on 404 returns empty list (no crash)
- Treasury: N/A and empty cells skipped, breakeven computed correctly
- Both connectors store to CurveData with correct curve_id values
- pandas CSV parsing wrapped in asyncio.to_thread for Treasury connector
- No new dependencies added
</verification>

<success_criteria>
- B3MarketDataConnector fetches DI swap curve (12 tenors) and NTN-B real rates and stores to curves
- TreasuryGovConnector fetches nominal + real + breakeven yield curves and stores to curves
- Rate conversion (% to decimal) is correct in both connectors
- Both connectors pass all tests with respx mocks
</success_criteria>

<output>
After completion, create `.planning/phases/03-extended-connectors/03-03-SUMMARY.md`
</output>
