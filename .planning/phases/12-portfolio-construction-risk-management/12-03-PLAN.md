---
phase: 12-portfolio-construction-risk-management
plan: 03
type: execute
wave: 2
depends_on: [12-01, 12-02]
files_modified:
  - src/risk/risk_limits.py
  - src/risk/drawdown_manager.py
  - src/risk/risk_monitor.py
  - src/risk/__init__.py
  - tests/test_risk/test_risk_limits.py
  - tests/test_risk/test_drawdown_manager.py
  - tests/test_risk/test_risk_monitor.py
autonomous: true
requirements: [RISK-05, RISK-06, RISK-07, RISK-08, TESTV2-04]

must_haves:
  truths:
    - "RiskLimitChecker has 9 configurable risk limits (max VaR, max drawdown, max leverage, max position, max asset class, max risk budget, max strategy loss, max asset class loss, max correlation)"
    - "Pre-trade limit checking simulates proposed trades and verifies no limits breached before execution"
    - "DrawdownManager tracks 3-level circuit breakers: L1 (-3%) reduce 25%, L2 (-5%) reduce 50%, L3 (-8%) close all"
    - "Circuit breaker re-entry after 5-day cooldown when drawdown recovers above -3%, with gradual 3-day ramp-up"
    - "Circuit breaker events are logged with full context (positions, P&L, signal state)"
    - "Three independent circuit breaker layers: portfolio drawdown, per-strategy daily loss, per-asset-class loss"
    - "RiskMonitor generates aggregate report: VaR/CVaR, stress test results, limit utilization, circuit breaker status"
    - "All TESTV2-04 unit tests pass for VaR calculation, limit checking, and circuit breakers"
  artifacts:
    - path: "src/risk/risk_limits.py"
      provides: "RiskLimitsConfig, RiskLimitChecker with 9 limits and pre-trade checking"
      min_lines: 150
    - path: "src/risk/drawdown_manager.py"
      provides: "DrawdownManager with CircuitBreakerState machine, 3 levels, cooldown, re-entry"
      min_lines: 180
    - path: "src/risk/risk_monitor.py"
      provides: "RiskMonitor orchestrator producing RiskReport dataclass"
      min_lines: 120
    - path: "tests/test_risk/test_risk_limits.py"
      provides: "Unit tests for limit configuration, checking, and pre-trade validation"
      min_lines: 80
    - path: "tests/test_risk/test_drawdown_manager.py"
      provides: "Unit tests for circuit breaker state transitions, cooldown, re-entry"
      min_lines: 100
    - path: "tests/test_risk/test_risk_monitor.py"
      provides: "Unit tests for aggregate risk report generation"
      min_lines: 60
  key_links:
    - from: "src/risk/risk_monitor.py"
      to: "src/risk/var_calculator.py"
      via: "imports VaRCalculator to compute VaR for report"
      pattern: "from src\\.risk\\.var_calculator import"
    - from: "src/risk/risk_monitor.py"
      to: "src/risk/stress_tester.py"
      via: "imports StressTester to run scenarios for report"
      pattern: "from src\\.risk\\.stress_tester import"
    - from: "src/risk/risk_monitor.py"
      to: "src/risk/risk_limits.py"
      via: "imports RiskLimitChecker to check limits for report"
      pattern: "from src\\.risk\\.risk_limits import"
    - from: "src/risk/risk_monitor.py"
      to: "src/risk/drawdown_manager.py"
      via: "imports DrawdownManager to check circuit breakers for report"
      pattern: "from src\\.risk\\.drawdown_manager import"
---

<objective>
Build the risk management engine's operational layer: RiskLimitChecker (9 configurable limits with pre-trade checking), DrawdownManager (3-level circuit breakers with cooldown and gradual re-entry), and RiskMonitor (aggregate risk report combining VaR, stress tests, limits, and circuit breaker status).

Purpose: This completes the risk management engine by adding the enforcement and monitoring layers on top of the quantitative computation (VaR, stress testing) from Plan 12-02. The RiskMonitor is the single entry point that produces the daily risk report consumed by the pipeline in Phase 13.

Output: 3 new modules in `src/risk/`, comprehensive unit tests covering TESTV2-04, and complete package exports.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-portfolio-construction-risk-management/12-CONTEXT.md
@.planning/phases/12-portfolio-construction-risk-management/12-RESEARCH.md

# Prior plan summaries needed (uses VaRCalculator, StressTester from 12-02)
@.planning/phases/12-portfolio-construction-risk-management/12-01-SUMMARY.md
@.planning/phases/12-portfolio-construction-risk-management/12-02-SUMMARY.md

# Key source files
@src/risk/__init__.py
@src/risk/var_calculator.py
@src/risk/stress_tester.py
@src/portfolio/signal_aggregator.py
@src/portfolio/capital_allocator.py
@src/core/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: RiskLimitChecker, DrawdownManager, and RiskMonitor modules</name>
  <files>
    src/risk/risk_limits.py
    src/risk/drawdown_manager.py
    src/risk/risk_monitor.py
    src/risk/__init__.py
  </files>
  <action>
**risk_limits.py — RiskLimitChecker (RISK-05, RISK-06):**

1. Define `RiskLimitsConfig` frozen dataclass with 9 configurable limits:
   - `max_var_95_pct: float = 0.03` — max 3% daily VaR at 95%
   - `max_var_99_pct: float = 0.05` — max 5% daily VaR at 99%
   - `max_drawdown_pct: float = 0.10` — max 10% peak-to-trough drawdown
   - `max_leverage: float = 3.0` — max sum of absolute weights
   - `max_single_position_pct: float = 0.25` — max 25% single position weight
   - `max_asset_class_pct: float = 0.50` — max 50% asset class concentration
   - `max_risk_budget_pct: float = 0.20` — max 20% risk contribution per position
   - `max_strategy_daily_loss_pct: float = 0.02` — max 2% daily loss per strategy
   - `max_asset_class_daily_loss_pct: float = 0.03` — max 3% daily loss per asset class

2. Define `LimitCheckResult` dataclass:
   - `limit_name: str`
   - `limit_value: float`
   - `current_value: float`
   - `utilization_pct: float` — current_value / limit_value * 100
   - `breached: bool`
   - `details: str`

3. `RiskLimitChecker.__init__(self, config: RiskLimitsConfig | None = None)`:
   - Defaults to RiskLimitsConfig().

4. `RiskLimitChecker.check_all(self, portfolio_state: dict) -> list[LimitCheckResult]`:
   - portfolio_state dict contains: `weights` (dict[str, float]), `leverage` (float), `var_95` (float), `var_99` (float), `drawdown_pct` (float), `risk_contributions` (dict[str, float] | None), `asset_class_weights` (dict[str, float] | None), `strategy_daily_pnl` (dict[str, float] | None), `asset_class_daily_pnl` (dict[str, float] | None).
   - Check each of the 9 limits against portfolio_state. Only check limits where data is available (skip None fields).
   - Return list of LimitCheckResult for all checked limits.

5. `RiskLimitChecker.check_pre_trade(self, current_state: dict, proposed_weights: dict[str, float]) -> tuple[bool, list[LimitCheckResult]]`:
   - Simulate the post-trade state: merge proposed_weights into current_state.
   - Run check_all on the hypothetical state.
   - Return (all_pass, results) where all_pass = True if no limits breached.

6. `RiskLimitChecker.utilization_report(self, results: list[LimitCheckResult]) -> dict[str, float]`:
   - Return {limit_name: utilization_pct} for dashboard display. Sorted by utilization descending.

**drawdown_manager.py — DrawdownManager (RISK-07):**

1. Define `CircuitBreakerState(str, Enum)`:
   - NORMAL, L1_TRIGGERED, L2_TRIGGERED, L3_TRIGGERED, COOLDOWN, RECOVERING

2. Define `CircuitBreakerEvent` dataclass:
   - `timestamp: datetime`
   - `state_from: CircuitBreakerState`
   - `state_to: CircuitBreakerState`
   - `drawdown_pct: float`
   - `action: str` (e.g., "reduce_25%", "reduce_50%", "close_all", "cooldown_start", "recovery_start")
   - `positions_snapshot: dict[str, float]` — positions at time of trigger
   - `pnl_at_trigger: float` — current P&L
   - `signals_at_trigger: dict` — current signal state for post-mortem (locked decision: full context logging)

3. Define `CircuitBreakerConfig` frozen dataclass:
   - `l1_drawdown_pct: float = 0.03` — L1 threshold: -3%
   - `l1_reduction: float = 0.25` — reduce by 25%
   - `l2_drawdown_pct: float = 0.05` — L2 threshold: -5%
   - `l2_reduction: float = 0.50` — reduce by 50%
   - `l3_drawdown_pct: float = 0.08` — L3 threshold: -8%
   - `l3_reduction: float = 1.00` — close all (100% reduction)
   - `cooldown_days: int = 5` — days before re-entry allowed
   - `recovery_days: int = 3` — days to ramp back to full exposure
   - `recovery_threshold_pct: float = 0.03` — drawdown must recover above -3% to exit cooldown

4. `DrawdownManager.__init__(self, config: CircuitBreakerConfig | None = None)`:
   - config defaults to CircuitBreakerConfig()
   - `self.state: CircuitBreakerState = CircuitBreakerState.NORMAL`
   - `self.high_water_mark: float = 0.0` — initialized on first update
   - `self.cooldown_counter: int = 0`
   - `self.recovery_day: int = 0`
   - `self.event_log: list[CircuitBreakerEvent] = []`
   - `self._hwm_initialized: bool = False`

5. `DrawdownManager.update(self, current_equity: float, positions: dict[str, float] | None = None, pnl: float = 0.0, signals: dict | None = None) -> float`:
   - Update high_water_mark = max(high_water_mark, current_equity). Initialize HWM on first call.
   - Compute current_drawdown_pct = (current_equity - high_water_mark) / high_water_mark if hwm > 0.
   - **State machine transitions:**
     - NORMAL: if drawdown >= l1 -> L1_TRIGGERED (log event with full context)
     - L1_TRIGGERED: if drawdown >= l2 -> L2_TRIGGERED; if drawdown recovers to < l1 * 0.5 -> NORMAL
     - L2_TRIGGERED: if drawdown >= l3 -> L3_TRIGGERED; if drawdown recovers to < l1 -> L1_TRIGGERED
     - L3_TRIGGERED: immediately transition to COOLDOWN, reset cooldown_counter = cooldown_days
     - COOLDOWN: decrement cooldown_counter each call. When counter reaches 0 AND drawdown < recovery_threshold -> RECOVERING
     - RECOVERING: increment recovery_day. When recovery_day >= recovery_days -> NORMAL, reset HWM to current_equity.
   - Every state transition creates a CircuitBreakerEvent in event_log with full context (positions, P&L, signals) per locked decision.
   - Return `scale_factor`: NORMAL -> 1.0, L1 -> (1 - l1_reduction) = 0.75, L2 -> (1 - l2_reduction) = 0.50, L3 -> 0.0, COOLDOWN -> 0.0, RECOVERING -> recovery_day / recovery_days (gradual ramp: 0.33, 0.66, 1.0).

6. `DrawdownManager.current_drawdown(self) -> float`:
   - Return current drawdown percentage.

7. `DrawdownManager.get_events(self) -> list[CircuitBreakerEvent]`:
   - Return copy of event_log.

8. `DrawdownManager.reset(self) -> None`:
   - Reset to NORMAL state with cleared event log. For testing.

**Per-strategy and per-asset-class circuit breakers:**
Add `StrategyLossTracker` and `AssetClassLossTracker` classes within drawdown_manager.py:
- `StrategyLossTracker.__init__(self, max_daily_loss_pct: float = 0.02)` — tracks daily P&L per strategy_id
- `StrategyLossTracker.update(self, strategy_id: str, daily_pnl_pct: float) -> bool` — returns True if breached
- `AssetClassLossTracker.__init__(self, max_daily_loss_pct: float = 0.03)` — tracks daily P&L per asset class
- `AssetClassLossTracker.update(self, asset_class: str, daily_pnl_pct: float) -> bool` — returns True if breached
- Both maintain event logs matching CircuitBreakerEvent format (locked decision: full context logging per layer).

**risk_monitor.py — RiskMonitor (RISK-08):**

1. Define `RiskReport` dataclass:
   - `timestamp: datetime`
   - `portfolio_value: float`
   - `var_results: dict[str, VaRResult]` — keyed by method name
   - `stress_results: list[StressResult]`
   - `limit_results: list[LimitCheckResult]`
   - `limit_utilization: dict[str, float]`
   - `circuit_breaker_state: CircuitBreakerState`
   - `circuit_breaker_scale: float`
   - `drawdown_pct: float`
   - `recent_cb_events: list[CircuitBreakerEvent]` — last 10 events
   - `conflict_log: list[str]` — from signal aggregation conflicts
   - `overall_risk_level: str` — "LOW", "MODERATE", "HIGH", "CRITICAL"

2. `RiskMonitor.__init__(self, var_calculator: VaRCalculator | None = None, stress_tester: StressTester | None = None, limit_checker: RiskLimitChecker | None = None, drawdown_manager: DrawdownManager | None = None)`:
   - Create default instances for any None parameters.

3. `RiskMonitor.generate_report(self, portfolio_returns: np.ndarray, positions: dict[str, float], portfolio_value: float, weights: dict[str, float], current_equity: float | None = None, returns_matrix: np.ndarray | None = None, portfolio_weights: np.ndarray | None = None, conflict_log: list[str] | None = None) -> RiskReport`:
   - **Step 1 — VaR**: Run var_calculator.calculate(portfolio_returns, "historical") and .calculate(portfolio_returns, "parametric"). If returns_matrix and portfolio_weights provided, also run Monte Carlo.
   - **Step 2 — Stress tests**: Run stress_tester.run_all(positions, portfolio_value).
   - **Step 3 — Limits**: Build portfolio_state dict from provided data and run limit_checker.check_all().
   - **Step 4 — Circuit breaker**: If current_equity provided, run drawdown_manager.update(current_equity, positions).
   - **Step 5 — Risk level**: Determine overall_risk_level based on: any limit breached -> "CRITICAL", any limit > 80% utilized -> "HIGH", drawdown > 2% -> "HIGH", drawdown > 1% -> "MODERATE", else "LOW".
   - Return RiskReport with all results.

4. `RiskMonitor.format_report(self, report: RiskReport) -> str`:
   - Plain-text formatted report matching existing backtest report pattern (from `src/backtesting/report.py`).
   - Sections: Portfolio Summary, VaR/CVaR, Stress Test Results (table), Limit Utilization (table), Circuit Breaker Status, Conflict Log.
   - Use ASCII box drawing (= and - chars) for terminal compatibility.

**Update __init__.py:**
Add exports: RiskLimitsConfig, RiskLimitChecker, LimitCheckResult, CircuitBreakerState, CircuitBreakerConfig, CircuitBreakerEvent, DrawdownManager, StrategyLossTracker, AssetClassLossTracker, RiskMonitor, RiskReport.
  </action>
  <verify>
    - `python -c "from src.risk.risk_limits import RiskLimitChecker, RiskLimitsConfig; print('OK')"` succeeds
    - `python -c "from src.risk.drawdown_manager import DrawdownManager, CircuitBreakerState; print('OK')"` succeeds
    - `python -c "from src.risk.risk_monitor import RiskMonitor, RiskReport; print('OK')"` succeeds
    - `python -c "from src.risk import RiskMonitor, DrawdownManager, RiskLimitChecker, VaRCalculator, StressTester; print('All exports OK')"` succeeds
    - `ruff check src/risk/` — zero errors
  </verify>
  <done>
    - RiskLimitChecker checks all 9 configurable limits with utilization reporting
    - Pre-trade checking simulates proposed state and verifies no breaches
    - DrawdownManager implements full state machine with 6 states (NORMAL, L1, L2, L3, COOLDOWN, RECOVERING)
    - Circuit breaker events logged with full context (positions, P&L, signals)
    - Per-strategy and per-asset-class loss trackers fire independently
    - RiskMonitor orchestrates all risk components into a single RiskReport
  </done>
</task>

<task type="auto">
  <name>Task 2: TESTV2-04 unit tests for risk limits, circuit breakers, and risk monitor</name>
  <files>
    tests/test_risk/test_risk_limits.py
    tests/test_risk/test_drawdown_manager.py
    tests/test_risk/test_risk_monitor.py
  </files>
  <action>
**test_risk_limits.py — RiskLimitChecker tests:**
- test_all_limits_pass: well-balanced portfolio with no breaches -> all results have breached=False
- test_leverage_breach: weights summing to 4.0 -> leverage limit breached
- test_var_95_breach: var_95=-0.04 (4%) > limit 3% -> breached
- test_drawdown_breach: drawdown_pct=0.12 > limit 0.10 -> breached
- test_single_position_breach: one weight=0.30 > limit 0.25 -> breached
- test_asset_class_concentration_breach: FI weights summing to 0.60 > limit 0.50 -> breached
- test_strategy_daily_loss_breach: strategy daily loss -2.5% > limit 2% -> breached
- test_pre_trade_pass: proposed weights within all limits -> (True, results)
- test_pre_trade_fail: proposed weights breaching leverage -> (False, results)
- test_utilization_report: 50% utilized limit -> utilization_pct=50.0
- test_custom_config: custom RiskLimitsConfig with tighter limits -> detects more breaches

**test_drawdown_manager.py — DrawdownManager tests (core TESTV2-04):**
- test_normal_no_drawdown: equity at or above HWM -> NORMAL state, scale=1.0
- test_l1_trigger: equity drops 3% from HWM -> L1_TRIGGERED, scale=0.75
- test_l2_trigger: equity drops 5% from HWM -> L2_TRIGGERED, scale=0.50
- test_l3_trigger: equity drops 8% from HWM -> L3_TRIGGERED then COOLDOWN, scale=0.0
- test_cooldown_duration: after L3, 5 update calls needed before COOLDOWN expires
- test_cooldown_no_exit_if_drawdown_high: cooldown counter reaches 0 but drawdown still > -3% -> stays in COOLDOWN
- test_recovery_gradual_ramp: after cooldown, 3 days of recovery with scale 0.33, 0.66, 1.0
- test_recovery_to_normal: after 3 recovery days -> NORMAL state, HWM reset
- test_event_logging: each state transition produces CircuitBreakerEvent with full context
- test_event_has_positions_snapshot: event.positions_snapshot matches positions at trigger time
- test_l1_recovery: equity recovers from -3% to above -1.5% (l1 * 0.5) -> back to NORMAL
- test_escalation_l1_to_l2: equity worsens from -3% to -5% -> escalates L1 -> L2
- test_hwm_updates_only_upward: HWM increases on new highs, never decreases
- test_strategy_loss_tracker_breach: strategy daily loss exceeding threshold -> returns True
- test_asset_class_loss_tracker_breach: asset class daily loss exceeding threshold -> returns True
- test_reset: reset() returns to NORMAL with empty event log

**test_risk_monitor.py — RiskMonitor integration tests:**
- test_generate_report_basic: with synthetic returns and positions, report has all required fields
- test_report_has_var_results: report.var_results contains "historical" and "parametric" keys
- test_report_has_stress_results: report.stress_results has 4 scenario results
- test_report_has_limit_results: report.limit_results is non-empty list
- test_report_risk_level_low: healthy portfolio -> overall_risk_level = "LOW"
- test_report_risk_level_critical: breached limit -> overall_risk_level = "CRITICAL"
- test_format_report_text: format_report() returns non-empty string with "VaR" and "Stress" sections
- test_default_components: RiskMonitor() with no args creates all default components

Run: `python -m pytest tests/test_risk/ -v`
  </action>
  <verify>
    - `python -m pytest tests/test_risk/ -v` — all tests pass (VaR + stress + limits + drawdown + monitor)
    - Total test count: ~11 (VaR) + ~10 (stress) + ~11 (limits) + ~16 (drawdown) + ~8 (monitor) = ~56 tests
    - `ruff check src/risk/ tests/test_risk/` — zero errors
  </verify>
  <done>
    - RiskLimitChecker: 11 tests covering all 9 limit types, pre-trade checking, and custom config
    - DrawdownManager: 16 tests covering all state transitions, cooldown, recovery, event logging, and per-strategy/per-asset-class trackers
    - RiskMonitor: 8 tests covering report generation, risk level classification, and text formatting
    - Total TESTV2-04 coverage: ~56 tests across all risk management components
    - All tests are pure unit tests with no database dependency
    - Zero lint errors
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_risk/ -v` — all ~56 tests pass
2. `python -m pytest tests/test_portfolio/ tests/test_risk/ -v` — all Phase 12 tests pass together (~83 total)
3. `python -c "from src.risk import RiskMonitor, DrawdownManager, RiskLimitChecker, VaRCalculator, StressTester; print('All risk exports OK')"` succeeds
4. `python -c "from src.portfolio import SignalAggregator, PortfolioConstructor, CapitalAllocator; print('All portfolio exports OK')"` succeeds
5. `ruff check src/portfolio/ src/risk/ tests/test_portfolio/ tests/test_risk/` — zero errors
6. Verify circuit breaker state machine: NORMAL -> L1 -> L2 -> L3 -> COOLDOWN -> RECOVERING -> NORMAL
7. Verify risk report contains all sections: VaR, stress, limits, circuit breaker status
</verification>

<success_criteria>
- RiskLimitChecker enforces 9 configurable limits with pre-trade checking
- DrawdownManager implements full 3-level circuit breaker state machine with cooldown and gradual re-entry
- Per-strategy and per-asset-class loss trackers fire independently
- RiskMonitor generates aggregate risk report combining all risk components
- All TESTV2-04 tests pass (~56 tests for risk management alone)
- Total Phase 12 test count: ~83 tests across portfolio + risk modules
</success_criteria>

<output>
After completion, create `.planning/phases/12-portfolio-construction-risk-management/12-03-SUMMARY.md`
</output>
