---
phase: 12-portfolio-construction-risk-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/portfolio/__init__.py
  - src/portfolio/signal_aggregator.py
  - src/portfolio/portfolio_constructor.py
  - src/portfolio/capital_allocator.py
  - tests/test_portfolio/__init__.py
  - tests/test_portfolio/test_signal_aggregator.py
  - tests/test_portfolio/test_portfolio_constructor.py
  - tests/test_portfolio/test_capital_allocator.py
autonomous: true
requirements: [PORT-01, PORT-02, PORT-03, PORT-04]

must_haves:
  truths:
    - "SignalAggregator combines 5 agent signals into directional consensus per asset class using weighted vote"
    - "Conflicting agent signals within an asset class are detected and reported with details"
    - "CrossAssetAgent regime score triggers veto (flatten/reduce) when extreme (< -0.7 or > 0.7)"
    - "Intra-asset-class strategy conflicts are detected and net position is dampened by 40%"
    - "PortfolioConstructor computes risk-parity base weights using scipy.optimize with Ledoit-Wolf covariance"
    - "Conviction overlay scales risk-parity weights by strategy signal strength and confidence"
    - "Regime scaling applies 3 discrete levels: Risk-On 100%, Neutral 70%, Risk-Off 40%"
    - "Regime transitions are gradual over 2-3 days to avoid whipsaw"
    - "CapitalAllocator enforces max 3x leverage, max 25% single position, max 50% asset class concentration, max 20% risk budget"
    - "Rebalance threshold check triggers only when drift exceeds 5% from target"
  artifacts:
    - path: "src/portfolio/signal_aggregator.py"
      provides: "SignalAggregator class with aggregate() method, AggregatedSignal dataclass"
      min_lines: 150
    - path: "src/portfolio/portfolio_constructor.py"
      provides: "PortfolioConstructor class with construct() method, risk parity, conviction overlay, regime scaling"
      min_lines: 200
    - path: "src/portfolio/capital_allocator.py"
      provides: "CapitalAllocator class with allocate() method, constraint enforcement, drift check"
      min_lines: 150
    - path: "tests/test_portfolio/test_signal_aggregator.py"
      provides: "Unit tests for weighted vote, conflict detection, CrossAsset veto"
      min_lines: 100
    - path: "tests/test_portfolio/test_portfolio_constructor.py"
      provides: "Unit tests for risk parity, conviction overlay, regime scaling"
      min_lines: 100
    - path: "tests/test_portfolio/test_capital_allocator.py"
      provides: "Unit tests for constraint enforcement, drift threshold, trade computation"
      min_lines: 80
  key_links:
    - from: "src/portfolio/signal_aggregator.py"
      to: "src/agents/base.py"
      via: "imports AgentSignal, AgentReport"
      pattern: "from src\\.agents\\.base import"
    - from: "src/portfolio/signal_aggregator.py"
      to: "src/core/enums.py"
      via: "imports AssetClass, SignalDirection"
      pattern: "from src\\.core\\.enums import"
    - from: "src/portfolio/portfolio_constructor.py"
      to: "src/strategies/base.py"
      via: "imports StrategyPosition, StrategyConfig"
      pattern: "from src\\.strategies\\.base import"
    - from: "src/portfolio/capital_allocator.py"
      to: "src/portfolio/portfolio_constructor.py"
      via: "imports PortfolioTarget for constraint checking"
      pattern: "from src\\.portfolio\\.portfolio_constructor import"
---

<objective>
Build the signal aggregation and portfolio construction pipeline: SignalAggregator (weighted vote consensus per asset class with conflict detection and CrossAsset veto), PortfolioConstructor (risk parity + conviction overlay + regime scaling with gradual transitions), and CapitalAllocator (constraint enforcement, drift-triggered rebalancing, trade computation).

Purpose: This is the bridge between agent/strategy outputs and the risk management engine. Without it, signals remain disconnected numbers -- this plan wires them into an actionable portfolio with proper position sizing.

Output: New `src/portfolio/` package with 3 modules and comprehensive unit tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-portfolio-construction-risk-management/12-CONTEXT.md
@.planning/phases/12-portfolio-construction-risk-management/12-RESEARCH.md

# Key upstream source files
@src/agents/base.py
@src/agents/registry.py
@src/strategies/base.py
@src/strategies/__init__.py
@src/core/enums.py
@src/backtesting/portfolio.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: SignalAggregator and PortfolioConstructor with dataclasses</name>
  <files>
    src/portfolio/__init__.py
    src/portfolio/signal_aggregator.py
    src/portfolio/portfolio_constructor.py
  </files>
  <action>
Create `src/portfolio/` package with `__init__.py`, `signal_aggregator.py`, and `portfolio_constructor.py`.

**signal_aggregator.py — SignalAggregator class (PORT-01):**

1. Define `AggregatedSignal` dataclass:
   - `asset_class: AssetClass`
   - `direction: SignalDirection` (net direction from weighted vote)
   - `net_score: float` (weighted sum in [-1, +1])
   - `confidence: float` (average confidence of contributing signals, 0-1)
   - `contributing_agents: list[dict]` (agent_id, direction, weight, confidence per contributor)
   - `conflicts_detected: bool`
   - `conflict_details: list[str]` (human-readable conflict descriptions)
   - `veto_applied: bool` (True if CrossAsset veto fired)
   - `veto_details: str` (reason for veto)
   - `timestamp: datetime` (default_factory=datetime.utcnow)

2. Define `DEFAULT_AGENT_WEIGHTS: dict[str, dict[AssetClass, float]]` — domain-tuned weight matrix per agent per asset class. Use these defaults (Claude's discretion within weighted vote framework):
   - `inflation_agent`: FIXED_INCOME=0.25, FX=0.10, EQUITY_INDEX=0.10, COMMODITY=0.15
   - `monetary_agent`: FIXED_INCOME=0.35, FX=0.20, EQUITY_INDEX=0.15, COMMODITY=0.05
   - `fiscal_agent`: FIXED_INCOME=0.20, FX=0.15, EQUITY_INDEX=0.20, COMMODITY=0.05
   - `fx_agent`: FIXED_INCOME=0.05, FX=0.40, EQUITY_INDEX=0.10, COMMODITY=0.20
   - `cross_asset_agent`: FIXED_INCOME=0.15, FX=0.15, EQUITY_INDEX=0.45, COMMODITY=0.55
   Weights per asset class sum to 1.0 across all agents.

3. `SignalAggregator.__init__(self, agent_weights=None)` — accepts optional custom weight matrix, defaults to DEFAULT_AGENT_WEIGHTS.

4. `SignalAggregator.aggregate(self, agent_reports: dict[str, AgentReport]) -> list[AggregatedSignal]`:
   - For each asset class in AssetClass (FIXED_INCOME, FX, EQUITY_INDEX, COMMODITY):
     - Collect composite signals from each agent (signal_id ending with "_COMPOSITE" or the main signal)
     - Map each signal's direction to a numeric score: LONG=+1, SHORT=-1, NEUTRAL=0
     - Multiply by agent weight for this asset class and by signal confidence
     - Sum weighted scores to get `net_score`
     - Normalize by sum of non-zero weights (avoid division by zero — if all weights zero, produce net_score=0, direction=NEUTRAL)
     - Direction: net_score > 0.1 -> LONG, net_score < -0.1 -> SHORT, else NEUTRAL
     - Detect conflicts: if any agent disagrees with the net direction AND has weight > 0.10, flag conflict
     - **CrossAsset veto check (bilateral)**: If cross_asset_agent's CROSSASSET_REGIME signal value is extreme in EITHER direction, apply veto: reduce net_score by 50% and set veto_applied=True. Specifically: regime_score > 0.7 (extreme risk-off) fires veto to protect capital by reducing exposure; regime_score < -0.7 (extreme risk-on / euphoria) fires veto to prevent over-leveraging into a potentially fragile market. Both cases set veto_applied=True and populate veto_details with the direction and score.
   - Return list of AggregatedSignal, one per asset class

5. `SignalAggregator.detect_strategy_conflicts(self, positions: dict[str, list[StrategyPosition]]) -> dict[AssetClass, list[str]]`:
   - Group positions by asset class (using strategy_id prefix mapping or passed asset_class info)
   - Within each asset class, check if any positions have opposing directions
   - Return {asset_class: [conflict description strings]}
   - This is used by PortfolioConstructor to apply the 40% dampening

**portfolio_constructor.py — PortfolioConstructor class (PORT-02):**

1. Define `RegimeState(str, Enum)`: RISK_ON, NEUTRAL, RISK_OFF with scale factors 1.0, 0.7, 0.4

2. Define `PortfolioTarget` dataclass:
   - `weights: dict[str, float]` — instrument -> target weight
   - `regime: RegimeState`
   - `regime_scale: float` — actual scale applied (may be transitional)
   - `conflicts: dict[AssetClass, list[str]]` — detected conflicts
   - `risk_parity_weights: dict[str, float]` — pre-conviction weights for diagnostics
   - `conviction_weights: dict[str, float]` — post-conviction, pre-regime weights
   - `timestamp: datetime`

3. Define `REGIME_THRESHOLDS`: regime_score > 0.3 -> RISK_OFF, regime_score < -0.3 -> RISK_ON, else NEUTRAL (from RESEARCH.md pitfall 4)

4. `PortfolioConstructor.__init__(self, conflict_dampening: float = 0.60, transition_days: int = 3)`:
   - `conflict_dampening`: multiplicative factor for conflicted asset classes (0.60 = 40% reduction, within locked 30-50% range)
   - `transition_days`: number of days for gradual regime transitions (locked at 2-3 days, default 3)
   - `_previous_regime: RegimeState | None = None`
   - `_regime_transition_day: int = 0` — tracks how many days into a transition

5. `PortfolioConstructor.construct(self, strategy_positions: dict[str, list[StrategyPosition]], returns_matrix: np.ndarray | None, instrument_list: list[str] | None, regime_score: float = 0.0, conflicts: dict[AssetClass, list[str]] | None = None) -> PortfolioTarget`:
   - **Step 1 — Flatten positions**: Merge all strategy positions into net weights per instrument. If multiple strategies target same instrument, sum weights.
   - **Step 2 — Risk parity base weights**: If returns_matrix is provided (shape n_obs x n_instruments), compute risk parity weights via `scipy.optimize.minimize(method='SLSQP')` with equal-risk-contribution objective. Use `sklearn.covariance.LedoitWolf` for robust covariance estimation. If returns_matrix is None or insufficient data (< 60 observations), fall back to equal weights.
   - **Step 3 — Conviction overlay**: Scale each risk parity weight by the average conviction of strategies contributing to that instrument. Conviction = mean(confidence * STRENGTH_MAP[strength]) across contributing strategy positions. Re-normalize so sum of absolute weights = sum of absolute risk parity weights.
   - **Step 4 — Conflict dampening**: For instruments in asset classes with detected conflicts (from `conflicts` param), multiply weight by `conflict_dampening` (0.60).
   - **Step 5 — Regime scaling**: Classify regime_score into RegimeState via REGIME_THRESHOLDS. Apply gradual transition: if regime changed from previous, scale = previous_scale + (target_scale - previous_scale) * (transition_day / transition_days). Track transition progress.
   - Return PortfolioTarget with all intermediate weights for diagnostics.

6. Helper `_risk_parity_weights(cov_matrix: np.ndarray) -> np.ndarray`: Pure function. Minimize sum((RC_i - 1/n)^2) where RC_i = w_i * (Sigma @ w)_i / (w' Sigma w). Bounds (0.01, 1.0), constraint sum=1.0, SLSQP, ftol=1e-12, maxiter=1000.

**__init__.py:**
Export SignalAggregator, AggregatedSignal, PortfolioConstructor, PortfolioTarget, CapitalAllocator (CapitalAllocator from Task 2), AllocationResult (from Task 2).

Use structlog for logging throughout. No database access — these are pure computation modules.
  </action>
  <verify>
    - `python -c "from src.portfolio.signal_aggregator import SignalAggregator, AggregatedSignal; print('OK')"` succeeds
    - `python -c "from src.portfolio.portfolio_constructor import PortfolioConstructor, PortfolioTarget; print('OK')"` succeeds
    - `python -c "from scipy.optimize import minimize; from sklearn.covariance import LedoitWolf; print('OK')"` confirms dependencies
    - `ruff check src/portfolio/` passes with zero errors
  </verify>
  <done>
    - SignalAggregator.aggregate() produces AggregatedSignal per asset class from agent reports
    - Conflict detection flags disagreements between agents and between strategies
    - CrossAsset veto fires bilaterally: when regime_score > 0.7 (extreme risk-off) OR regime_score < -0.7 (extreme risk-on), reducing net_score by 50%
    - PortfolioConstructor.construct() produces PortfolioTarget with risk-parity base, conviction overlay, regime scaling
    - Regime transitions are gradual over 3 days (configurable)
    - Risk parity uses scipy SLSQP + Ledoit-Wolf covariance
  </done>
</task>

<task type="auto">
  <name>Task 2: CapitalAllocator, package exports, and all unit tests</name>
  <files>
    src/portfolio/capital_allocator.py
    src/portfolio/__init__.py
    tests/test_portfolio/__init__.py
    tests/test_portfolio/test_signal_aggregator.py
    tests/test_portfolio/test_portfolio_constructor.py
    tests/test_portfolio/test_capital_allocator.py
  </files>
  <action>
**capital_allocator.py — CapitalAllocator class (PORT-03, PORT-04):**

1. Define `AllocationConstraints` frozen dataclass:
   - `max_leverage: float = 3.0` — sum of absolute weights cap
   - `max_single_position: float = 0.25` — max absolute weight per instrument
   - `max_asset_class_concentration: float = 0.50` — max sum of abs weights per asset class
   - `max_risk_budget_pct: float = 0.20` — max risk contribution per position
   - `drift_threshold: float = 0.05` — rebalance trigger threshold (5% absolute deviation)
   - `min_trade_notional: float = 10_000.0` — minimum trade size filter

2. Define `AllocationResult` dataclass:
   - `target_weights: dict[str, float]` — final constrained weights
   - `trades: dict[str, float]` — instrument -> weight change (delta)
   - `rebalance_needed: bool` — whether drift exceeded threshold
   - `constraint_violations: list[str]` — description of any constraints that were binding
   - `leverage_used: float` — final leverage ratio
   - `asset_class_exposure: dict[str, float]` — exposure per asset class
   - `timestamp: datetime`

3. `CapitalAllocator.__init__(self, constraints: AllocationConstraints | None = None)`:
   - Defaults to AllocationConstraints() with defaults above.

4. `CapitalAllocator.allocate(self, portfolio_target: PortfolioTarget, current_weights: dict[str, float] | None = None, instrument_to_asset_class: dict[str, AssetClass] | None = None) -> AllocationResult`:
   - **Step 1 — Apply single position limit**: Clamp each weight to [-max_single_position, max_single_position]. Log any binding constraints.
   - **Step 2 — Apply asset class concentration**: Group instruments by asset_class (from instrument_to_asset_class mapping). If any asset class total abs weight > max_asset_class_concentration, scale down that asset class's weights proportionally.
   - **Step 3 — Apply leverage limit**: If sum(abs(weights)) > max_leverage, scale all weights proportionally. This matches the existing pattern in `Portfolio.rebalance()`.
   - **Step 4 — Drift check**: If current_weights provided, compute max(abs(target_weight_i - current_weight_i)) across all instruments. If max drift <= drift_threshold, set rebalance_needed=False and return current_weights as target (no trade). Otherwise rebalance_needed=True.
   - **Step 5 — Compute trades**: trades[instrument] = target_weight - current_weight. Filter out trades where abs(delta) * assumed_equity < min_trade_notional (use 1M as reference equity for weight-space filtering, i.e., filter if abs(delta) < min_trade_notional / 1_000_000).
   - Return AllocationResult with all diagnostics.

5. `CapitalAllocator.check_risk_budget(self, weights: dict[str, float], cov_matrix: np.ndarray | None, instrument_list: list[str] | None) -> list[str]`:
   - If cov_matrix provided, compute marginal risk contribution per position.
   - RC_i = w_i * (Sigma @ w)_i / (w' Sigma w). If any RC_i > max_risk_budget_pct, return violation descriptions.
   - If cov_matrix not available, skip risk budget check (return empty list).

**Update __init__.py** to export all classes: SignalAggregator, AggregatedSignal, PortfolioConstructor, PortfolioTarget, RegimeState, CapitalAllocator, AllocationConstraints, AllocationResult.

**Unit Tests (all 3 test files, no database required):**

`tests/test_portfolio/__init__.py` — empty init.

`tests/test_portfolio/test_signal_aggregator.py`:
- test_aggregate_unanimous_long: all agents agree LONG -> net_score > 0.5, direction=LONG, conflicts_detected=False
- test_aggregate_unanimous_short: all agents agree SHORT -> direction=SHORT
- test_aggregate_conflict: 3 agents LONG, 2 agents SHORT -> LONG but conflicts_detected=True
- test_aggregate_neutral_when_balanced: equal LONG/SHORT with equal weights -> NEUTRAL
- test_veto_fires_extreme_risk_off: regime_score > 0.7 -> veto_applied=True, net_score reduced
- test_veto_fires_extreme_risk_on: regime_score < -0.7 -> veto_applied=True, net_score reduced (bilateral veto)
- test_veto_not_fires_moderate: regime_score = 0.3 -> veto_applied=False
- test_no_signals: empty agent reports -> all NEUTRAL
- test_detect_strategy_conflicts: opposing positions in same asset class -> conflict flagged
- test_weights_normalize_with_missing_agents: if only 3 of 5 agents report, weights renormalize

`tests/test_portfolio/test_portfolio_constructor.py`:
- test_risk_parity_equal_vol: 3 assets with equal vol and zero correlation -> equal weights
- test_risk_parity_unequal_vol: higher vol asset gets lower weight
- test_conviction_overlay_scales: higher conviction strategy gets larger weight
- test_regime_scaling_risk_on: regime_score < -0.3 -> scale=1.0
- test_regime_scaling_risk_off: regime_score > 0.3 -> scale=0.4
- test_regime_scaling_neutral: regime_score ~0.0 -> scale=0.7
- test_regime_transition_gradual: regime change applies partial scale on day 1 (not instant)
- test_conflict_dampening: conflicted asset class positions reduced by 40%
- test_fallback_equal_weights_no_returns: no returns_matrix -> equal weights

`tests/test_portfolio/test_capital_allocator.py`:
- test_leverage_cap: weights exceeding 3x scaled down proportionally
- test_single_position_cap: weight > 0.25 clamped to 0.25
- test_asset_class_concentration: FI weights > 50% scaled to 50%
- test_drift_below_threshold_no_rebalance: drift < 5% -> rebalance_needed=False
- test_drift_above_threshold_rebalance: drift > 5% -> rebalance_needed=True
- test_trade_computation: correct delta between target and current weights
- test_risk_budget_violation_detected: position contributing > 20% risk flagged
- test_all_constraints_pass: well-balanced portfolio passes all checks
- test_min_trade_filter: tiny trades filtered out

Run: `python -m pytest tests/test_portfolio/ -v`
  </action>
  <verify>
    - `python -m pytest tests/test_portfolio/ -v` — all tests pass
    - `python -c "from src.portfolio import SignalAggregator, PortfolioConstructor, CapitalAllocator; print('OK')"` succeeds
    - `ruff check src/portfolio/ tests/test_portfolio/` passes with zero errors
  </verify>
  <done>
    - CapitalAllocator enforces all 4 constraint types (leverage, single position, asset class, risk budget)
    - Drift threshold check correctly gates rebalancing at 5% deviation
    - Trade computation produces correct deltas between target and current weights
    - All unit tests pass: SignalAggregator (~10), PortfolioConstructor (~9), CapitalAllocator (~9) = ~28 total tests
    - Package exports verified via import statement
    - Zero lint errors
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_portfolio/ -v` — all ~28 tests pass
2. `python -c "from src.portfolio import SignalAggregator, AggregatedSignal, PortfolioConstructor, PortfolioTarget, CapitalAllocator, AllocationResult; print('All exports OK')"` succeeds
3. `ruff check src/portfolio/ tests/test_portfolio/` — zero errors
4. Verify risk parity weights sum to ~1.0 for a test case with known covariance
5. Verify regime scaling: RISK_OFF produces scale factor of 0.4 on weights
</verification>

<success_criteria>
- SignalAggregator produces directional consensus per asset class via weighted vote
- PortfolioConstructor computes risk-parity + conviction + regime-scaled target weights
- CapitalAllocator enforces all portfolio constraints and drift-triggered rebalancing
- All code is pure computation (no database, no I/O)
- ~28 unit tests pass, zero lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/12-portfolio-construction-risk-management/12-01-SUMMARY.md`
</output>
