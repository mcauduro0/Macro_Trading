---
phase: 08-inflation-monetary-policy-agents
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/features/monetary_features.py
  - src/agents/monetary_agent.py
  - tests/test_monetary_agent.py
autonomous: true
requirements:
  - MONP-01
  - MONP-02
  - MONP-03
  - MONP-04
  - MONP-05
  - MONP-06
  - TESTV2-01
  - TESTV2-02

must_haves:
  truths:
    - "MonetaryPolicyAgent.run(as_of_date) returns an AgentReport with exactly 5 AgentSignal objects"
    - "TaylorRuleModel returns SHORT when Selic is 150bps above Taylor-implied rate (policy restrictive) with STRONG strength"
    - "KalmanFilterRStar runs the full filter on available history and returns a float r* estimate"
    - "SelicPathModel returns SHORT when market-implied Selic path > model Taylor path (fade hike pricing)"
    - "MonetaryFeatureEngine returns dict with DI slope, belly, long_premium, real_rate_gap keys"
    - "All monetary unit tests pass without a database connection"
  artifacts:
    - path: "src/agents/features/monetary_features.py"
      provides: "MonetaryFeatureEngine class with compute() method"
      contains: "class MonetaryFeatureEngine"
    - path: "src/agents/monetary_agent.py"
      provides: "MonetaryPolicyAgent + 5 models (Taylor, Kalman, SelicPath, TermPremium, UsFed, Composite)"
      exports: ["MonetaryPolicyAgent", "TaylorRuleModel", "KalmanFilterRStar", "SelicPathModel", "TermPremiumModel", "UsFedAnalysis"]
    - path: "tests/test_monetary_agent.py"
      provides: "Unit tests for monetary feature keys and model directions"
      contains: "def test_monetary_feature_engine_keys"
  key_links:
    - from: "src/agents/monetary_agent.py"
      to: "src/agents/features/monetary_features.py"
      via: "instantiation of MonetaryFeatureEngine in MonetaryPolicyAgent.__init__"
      pattern: "MonetaryFeatureEngine"
    - from: "src/agents/monetary_agent.py"
      to: "src/agents/base.py"
      via: "class MonetaryPolicyAgent(BaseAgent)"
      pattern: "class MonetaryPolicyAgent.*BaseAgent"
    - from: "src/agents/monetary_agent.py"
      to: "KalmanFilterRStar"
      via: "TaylorRuleModel receives r* from KalmanFilterRStar at runtime"
      pattern: "KalmanFilterRStar"
---

<objective>
Build MonetaryFeatureEngine (BR DI curve shape + US UST curve features), all 5 monetary models (TaylorRuleModel, KalmanFilterRStar, SelicPathModel, TermPremiumModel, UsFedAnalysis), MonetaryPolicyAgent orchestration with MONETARY_BR_COMPOSITE, and unit tests.

Purpose: MonetaryPolicyAgent is independent of InflationAgent — it can be built in Wave 1 in parallel. After this plan, MonetaryPolicyAgent.run() produces all 5 required signals and is registerable in AgentRegistry alongside InflationAgent.
Output: src/agents/features/monetary_features.py, src/agents/monetary_agent.py, tests/test_monetary_agent.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-agent-framework-data-loader/07-01-SUMMARY.md
@.planning/phases/07-agent-framework-data-loader/07-02-SUMMARY.md
@src/agents/base.py
@src/agents/data_loader.py
@src/core/enums.py
@tests/test_agents/test_base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MonetaryFeatureEngine, all 5 monetary models, and MonetaryPolicyAgent</name>
  <files>
    src/agents/features/monetary_features.py
    src/agents/monetary_agent.py
  </files>
  <action>
**Part A — MonetaryFeatureEngine in `src/agents/features/monetary_features.py`:**

```python
class MonetaryFeatureEngine:
    """Compute BR DI curve shape + US UST curve features for monetary policy analysis."""

    def compute(self, data: dict, as_of_date: date) -> dict[str, Any]:
        """Return flat dict of all monetary policy features."""
```

**BR features (data["di_curve"] is a DataFrame with columns: tenor_1y, tenor_2y, tenor_5y, tenor_10y at each curve date; data["selic"] is macro_series; data["focus"] has Focus expectations; data["ibc_br"] for output gap; data["selic_history"] is full Selic history):**

DI curve shape (locked: tenors 1Y, 2Y, 5Y, 10Y per CONTEXT.md):
- `di_1y`, `di_2y`, `di_5y`, `di_10y`: latest DI rates at each tenor (%)
- `di_slope`: di_10y - di_1y (10Y minus 1Y spread)
- `di_belly`: di_2y - (di_1y + di_5y) / 2 (2Y vs midpoint of 1Y and 5Y)
- `di_long_premium`: di_10y - di_5y (long-end premium)
- `di_1y_real`: di_1y - focus_ipca_12m (1Y real DI rate)

BCB policy:
- `selic_target`: current Selic target rate (from data["selic"], latest value)
- `real_rate_gap`: selic_target - focus_ipca_12m (real rate implied by BCB)
- `policy_inertia`: change in Selic over last 3 BCB meetings (approximate from last 3 monthly selic changes)
- `focus_ipca_12m`: 12M ahead IPCA Focus median (same as inflation agent)

IBC-Br output gap (same HP-filter computation as InflationFeatureEngine — reuse hpfilter):
- `ibc_br_output_gap`: (actual - trend) / trend * 100

Selic history (needed for Kalman filter):
- `_selic_history_series`: the full Selic monthly time series as pd.Series (private key for KalmanFilterRStar)
- `_focus_history_series`: the full Focus 12M monthly time series as pd.Series
- `_ibc_gap_series`: the full IBC-Br output gap monthly time series as pd.Series

DI implied path for Selic path model:
- `_di_implied_path`: dict mapping approximate meeting horizon (months: 1, 3, 6, 9, 12, 18, 24) to DI rate at that tenor, derived from di_1y and di_2y via linear interpolation between tenors.

Term premium inputs:
- `_tp_raw_series`: Focus terminal Selic rate (use Focus 24M IPCA + estimated r* as proxy for expected short rate path terminal). TP = di_10y - focus_terminal_selic. Store as scalar: `di_10y - (focus_ipca_12m + 3.5)` as a rough proxy. Store trailing 24M series of this proxy from history in `_tp_history`.

**US features (data["fed_funds"] macro series; data["ust_curve"] DataFrame; data["us_macro"] dict with NFCI, CPI, PCE):**
- `fed_funds_rate`: Fed Funds Effective Rate (latest)
- `ust_2y`, `ust_5y`, `ust_10y`: UST yields
- `ust_slope`: ust_10y - ust_2y
- `ust_real_10y`: ust_10y - us_breakeven_10y (from data if available)
- `nfci`: Chicago Fed NFCI (latest; NaN if unavailable)
- `us_pce_core_yoy`: PCE core YoY (same as inflation agent)

Guard all computations with try/except returning np.nan. Add to `src/agents/features/__init__.py`: `from src.agents.features.monetary_features import MonetaryFeatureEngine`.

**Part B — `src/agents/monetary_agent.py`:**

Create the full file with:

**TaylorRuleModel**:
```python
class TaylorRuleModel:
    """BCB-modified Taylor Rule: i* = r* + π_e + α(π_e - π*) + β(y_gap) + γ(inertia)."""
    SIGNAL_ID = "MONETARY_BR_TAYLOR"
    ALPHA = 1.5   # inflation gap coefficient
    BETA = 0.5    # output gap coefficient
    GAMMA = 0.5   # inertia coefficient
    PI_STAR = 3.0 # BCB inflation target
    GAP_FLOOR = 1.0  # 100bps floor (locked in CONTEXT.md)
    # Strength bands (Claude's discretion): 100-150bps → MODERATE, >150bps → STRONG
    MODERATE_BAND = 1.5  # 150bps
```

`run(features: dict, r_star: float, as_of_date: date) -> AgentSignal`:
- i_star = r_star + features["focus_ipca_12m"] + ALPHA*(features["focus_ipca_12m"] - PI_STAR) + BETA*features["ibc_br_output_gap"] + GAMMA*features["policy_inertia"]
- policy_gap = features["selic_target"] - i_star (positive = Selic above Taylor = restrictive)
- Signal fires only if |policy_gap| >= GAP_FLOOR (100bps). Else NEUTRAL/NO_SIGNAL.
- Direction: policy_gap > 0 (Selic above Taylor, restrictive) → SHORT (rate cut bias); policy_gap < 0 (Selic below Taylor, loose) → LONG (hike risk).
- Strength: |gap| in [GAP_FLOOR, MODERATE_BAND) → MODERATE (confidence=0.60), |gap| >= MODERATE_BAND → STRONG (confidence=0.85).
- value = round(policy_gap, 4), horizon_days=252.
- metadata: {"i_star": i_star, "selic": features["selic_target"], "r_star": r_star, "policy_gap_bps": policy_gap * 100}.
- If any input feature is NaN: return NO_SIGNAL.

**KalmanFilterRStar**:
```python
class KalmanFilterRStar:
    """State-space estimation of time-varying natural rate r* from Selic history."""
    MIN_OBS = 24
    DEFAULT_R_STAR = 3.0  # % — returned if insufficient data
```

`estimate(selic_series: pd.Series, expectations_series: pd.Series, gap_series: pd.Series) -> tuple[float, float]`:
- Returns (r_star_estimate, uncertainty) where uncertainty is filter variance.
- Observations: y_t = selic_t - expectations_t (proxy for ex-ante real rate). State: x_t = r_star (random walk).
- Implement directly with numpy (no external Kalman library required):
  ```
  # State transition: x_t = x_{t-1} + w_t, w_t ~ N(0, Q)
  # Observation: y_t = x_t + v_t, v_t ~ N(0, R)
  Q = 0.01  # state noise (r* changes slowly)
  R = 1.0   # observation noise
  x = 3.0   # initial r* estimate
  P = 1.0   # initial uncertainty
  for y in obs_series:
      P_pred = P + Q
      K = P_pred / (P_pred + R)  # Kalman gain
      x = x + K * (y - x)
      P = (1 - K) * P_pred
  return x, P
  ```
- If len(obs_series.dropna()) < MIN_OBS: log warning, return (DEFAULT_R_STAR, float('inf')).
- obs_series = (selic_series - expectations_series).dropna()

**SelicPathModel**:
```python
class SelicPathModel:
    """Market-implied Selic path vs Taylor Rule model path signal."""
    SIGNAL_ID = "MONETARY_BR_SELIC_PATH"
```

`run(features: dict, i_star: float, as_of_date: date) -> AgentSignal`:
- Market-implied path: proxy using `features["di_1y"]` as 1Y market Selic expectation (forward looking, accounts for easing/tightening priced in).
- Model path: `i_star` from TaylorRuleModel (what fundamentals suggest terminal rate should be).
- market_vs_model = features["di_1y"] - i_star
- Direction (Claude's discretion, per standard rates strategy):
  - market > model → SHORT (market is pricing more tightening than fundamentals justify — fade the hike pricing, rates should come down)
  - market < model → LONG (market underpricing tightening risk — rates should go up)
- Signal fires if |market_vs_model| >= 0.5 (50bps).
- confidence = min(1.0, abs(market_vs_model) / 2.0).
- strength = classify_strength(confidence).
- value = round(market_vs_model, 4), horizon_days=126.
- metadata: {"di_1y": features["di_1y"], "taylor_implied": i_star, "deviation_bps": market_vs_model * 100}.
- If features["di_1y"] is NaN: return NO_SIGNAL.

**TermPremiumModel**:
```python
class TermPremiumModel:
    """DI term premium estimate and z-score signal."""
    SIGNAL_ID = "MONETARY_BR_TERM_PREMIUM"
    Z_HIGH = 1.5   # z > 1.5 → LONG (TP attractive, rates too high)
    Z_LOW = -1.5   # z < -1.5 → SHORT (TP compressed, duration expensive)
    MIN_HISTORY = 12  # months for z-score
```

`run(features: dict, as_of_date: date) -> AgentSignal`:
- Current TP proxy = `features["di_10y"] - (features["focus_ipca_12m"] + r_star_estimate)` where r_star comes from `features["_r_star_estimate"]` (stored by MonetaryPolicyAgent after running Kalman).
- Trailing 24M TP history in `features["_tp_history"]` (a Series). Compute z-score: (current_tp - history.mean()) / history.std().
- Direction: z > Z_HIGH → LONG (term premium is high = rates are above fair value, long duration); z < Z_LOW → SHORT (TP compressed, expensive to own duration).
- If |z| < 0.5: NEUTRAL.
- confidence = min(1.0, abs(z) / 3.0).
- strength = classify_strength(confidence).
- value = round(z, 4), horizon_days=252.
- If insufficient history or NaN: return NO_SIGNAL.

**UsFedAnalysis**:
```python
class UsFedAnalysis:
    """US Fed policy gap and financial conditions signal."""
    SIGNAL_ID = "MONETARY_US_FED_STANCE"
    # US Taylor Rule: i* = 2.5 + 1.5*(PCE_core - 2.0) + 0.5*output_gap
    NEUTRAL_RATE = 2.5
    ALPHA = 1.5
    BETA = 0.5
    GAP_FLOOR = 0.5  # 50bps floor for US (tighter market)
```

`run(features: dict, as_of_date: date) -> AgentSignal`:
- US output gap proxy: use ust_slope as a simple proxy (inverted yield curve = negative output gap). `us_output_gap_proxy = features["ust_slope"] * 0.5` — approximation only.
- US i_star = NEUTRAL_RATE + ALPHA*(features["us_pce_core_yoy"] - 2.0) + BETA*us_output_gap_proxy
- US policy gap = features["fed_funds_rate"] - us_i_star
- Direction: hawkish US Fed = restrictive global conditions.
  - gap > 0 (Fed above Taylor = tight) → LONG USDBRL risk-off signal (SHORT for local BRL assets): use SHORT direction (tighter global = BRL bearish context)
  - gap < 0 (Fed below Taylor = loose) → LONG (easy global = BRL supportive)
- Fires if |gap| >= GAP_FLOOR.
- confidence = min(1.0, abs(gap) / 2.0).
- strength = classify_strength(confidence).
- value = round(gap, 4), horizon_days=252.
- metadata: {"us_i_star": us_i_star, "fed_funds": features["fed_funds_rate"], "policy_gap_bps": gap * 100, "nfci": features.get("nfci", float("nan"))}.
- If pce_core or fed_funds is NaN: return NO_SIGNAL.

**MONETARY_BR_COMPOSITE** (built in `_build_composite()`):
- Weights: Taylor Rule 50%, Selic Path 30%, Term Premium 20% (Claude's discretion — fundamental model weighted heaviest).
- Same conflict dampening mechanic as InflationAgent: if >= 2 BR sub-signals disagree with plurality → dampening = 0.70.
- US Fed stance remains standalone signal only (not fed into BR composite — Claude's discretion: avoid double-counting from separate market).
- Direction = plurality vote among Taylor, SelicPath, TermPremium (non-NO_SIGNAL only). Renormalize weights if any absent.
- Composite confidence = weighted sum * dampening.
- metadata: {"weights": effective_weights, "dampening": dampening}.

**MonetaryPolicyAgent class**:
```python
class MonetaryPolicyAgent(BaseAgent):
    AGENT_ID = "monetary_agent"
    AGENT_NAME = "Monetary Policy Agent"

    def __init__(self, loader: PointInTimeDataLoader) -> None:
        super().__init__(self.AGENT_ID, self.AGENT_NAME)
        self.loader = loader
        self.feature_engine = MonetaryFeatureEngine()
        self.kalman = KalmanFilterRStar()
        self.taylor = TaylorRuleModel()
        self.selic_path = SelicPathModel()
        self.term_premium = TermPremiumModel()
        self.us_fed = UsFedAnalysis()
```

`load_data(as_of_date)`: load all monetary series using self.loader:
- Selic target: `self.loader.get_macro_series("BCB-432", as_of_date, lookback_days=3650)` (BCB Selic target series 432)
- DI curve: `self.loader.get_curves("DI", as_of_date)` — returns DataFrame; filter to latest curve date
- Focus IPCA 12M: `self.loader.get_macro_series("FOCUS-IPCA-12M", as_of_date, lookback_days=3650)`
- IBC-Br: `self.loader.get_macro_series("BCB-24363", as_of_date, lookback_days=5475)` (15Y for Kalman)
- Fed Funds: `self.loader.get_macro_series("FRED-DFF", as_of_date, lookback_days=3650)`
- UST yields: `self.loader.get_curves("UST", as_of_date)`
- NFCI: `self.loader.get_macro_series("FRED-NFCI", as_of_date, lookback_days=1825)`
- PCE core: `self.loader.get_macro_series("FRED-PCEPILFE", as_of_date, lookback_days=1825)`
- US breakeven 10Y: `self.loader.get_macro_series("FRED-T10YIE", as_of_date, lookback_days=1825)`
- Wrap all in try/except returning None on failure.

`compute_features(data)`: call `self.feature_engine.compute(data, ...)`, return features dict.

`run_models(features)`:
```python
def run_models(self, features: dict) -> list[AgentSignal]:
    as_of_date = features["_as_of_date"]
    # Step 1: Run Kalman to get r*
    r_star, r_star_uncertainty = self.kalman.estimate(
        features["_selic_history_series"],
        features["_focus_history_series"],
        features["_ibc_gap_series"],
    )
    features["_r_star_estimate"] = r_star
    signals = []
    # Step 2: Taylor Rule (needs r*)
    taylor_sig = self.taylor.run(features, r_star, as_of_date)
    signals.append(taylor_sig)
    # Step 3: Selic Path (needs taylor i*)
    i_star = features["selic_target"] - taylor_sig.value if taylor_sig.strength != SignalStrength.NO_SIGNAL else features["selic_target"]
    selic_path_sig = self.selic_path.run(features, i_star, as_of_date)
    signals.append(selic_path_sig)
    # Step 4: Term Premium
    signals.append(self.term_premium.run(features, as_of_date))
    # Step 5: US Fed
    signals.append(self.us_fed.run(features, as_of_date))
    # Step 6: Composite (BR only)
    signals.append(self._build_composite(signals[:3], as_of_date))
    return signals
```

`generate_narrative(signals, features)`: simple formatted string per-signal summary, similar to InflationAgent.

Add `features["_as_of_date"] = as_of_date` in compute_features().

Also update `src/agents/features/__init__.py` to export MonetaryFeatureEngine.

Run `ruff check --fix src/agents/features/ src/agents/monetary_agent.py` after writing.
  </action>
  <verify>
    Run: `python -c "from src.agents.monetary_agent import MonetaryPolicyAgent, TaylorRuleModel, KalmanFilterRStar, SelicPathModel, TermPremiumModel, UsFedAnalysis; print('all OK')"`
    Run: `python -c "from src.agents.features.monetary_features import MonetaryFeatureEngine; print(MonetaryFeatureEngine)"`
    Run: `python -c "from src.agents.features import MonetaryFeatureEngine; print('import OK')"`
    Run: `ruff check src/agents/features/ src/agents/monetary_agent.py`
  </verify>
  <done>
    All 6 monetary classes importable without error. MonetaryFeatureEngine importable from src.agents.features.
    TaylorRuleModel.GAP_FLOOR == 1.0 (locked 100bps floor). ruff check passes zero violations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for MonetaryPolicyAgent models</name>
  <files>
    tests/test_monetary_agent.py
  </files>
  <action>
Create `tests/test_monetary_agent.py` with unit tests using synthetic features dicts — no database required. Follow the same pattern as tests/test_inflation_agent.py (MagicMock loader, synthetic DataFrames, no DB imports).

**Test file imports:**
```python
from __future__ import annotations

import numpy as np
import pandas as pd
import pytest
from datetime import date, datetime
from unittest.mock import MagicMock

from src.agents.monetary_agent import (
    MonetaryPolicyAgent,
    TaylorRuleModel,
    KalmanFilterRStar,
    SelicPathModel,
    TermPremiumModel,
    UsFedAnalysis,
)
from src.agents.features.monetary_features import MonetaryFeatureEngine
from src.core.enums import SignalDirection, SignalStrength
```

**Tests to implement:**

1. `test_monetary_feature_engine_keys` (addresses TESTV2-01):
   - Build synthetic data dict: `di_curve` DataFrame with columns tenor_1y=12.5, tenor_2y=12.8, tenor_5y=13.0, tenor_10y=13.2 (5 rows monthly), `selic` DataFrame value=12.25, `focus` DataFrame focus_ipca_12m=4.5, `ibc_br` DataFrame (60 monthly rows, value ~150 index level), plus empty DataFrames for US series.
   - Call `MonetaryFeatureEngine().compute(data, date(2024,1,31))`.
   - Assert all required keys present: `["di_slope", "di_belly", "di_long_premium", "di_1y_real", "selic_target", "real_rate_gap", "policy_inertia", "focus_ipca_12m", "ibc_br_output_gap"]`.
   - Assert `"_selic_history_series"` key present.
   - Assert `"_focus_history_series"` key present.
   - Assert di_slope == pytest.approx(13.2 - 12.5, abs=0.01).

2. `test_taylor_rule_gap_signal_short` (addresses TESTV2-02):
   - Build features: `selic_target=14.75`, `focus_ipca_12m=5.0`, `ibc_br_output_gap=1.0`, `policy_inertia=0.0`.
   - r_star = 3.0 (default).
   - i_star = 3.0 + 5.0 + 1.5*(5.0-3.0) + 0.5*1.0 + 0.5*0.0 = 3.0+5.0+3.0+0.5+0.0 = 11.5
   - policy_gap = 14.75 - 11.5 = 3.25 (Selic far above Taylor → SHORT, STRONG).
   - Call `TaylorRuleModel().run(features, r_star=3.0, as_of_date=date(2024,1,31))`.
   - Assert signal.direction == SignalDirection.SHORT.
   - Assert signal.strength == SignalStrength.STRONG (gap 3.25 > 1.5 MODERATE_BAND).
   - Assert signal.signal_id == "MONETARY_BR_TAYLOR".

3. `test_taylor_rule_gap_signal_no_signal_below_floor` (addresses TESTV2-02):
   - features: `selic_target=11.75`, `focus_ipca_12m=4.5`, `ibc_br_output_gap=0.0`, `policy_inertia=0.0`.
   - i_star = 3.0+4.5+1.5*(4.5-3.0)+0.5*0+0.5*0 = 3.0+4.5+2.25 = 9.75
   - gap = 11.75-9.75 = 2.0 → SHORT STRONG... try gap < floor:
   - Use `selic_target=10.5`, same others: i_star=9.75, gap=0.75 — still >= 1.0 floor.
   - Use `selic_target=10.0`: gap=0.25 < 1.0 floor → NO_SIGNAL.
   - Assert signal.strength == SignalStrength.NO_SIGNAL.
   - Assert signal.direction == SignalDirection.NEUTRAL.

4. `test_taylor_rule_gap_signal_long` (addresses TESTV2-02):
   - features: `selic_target=8.0`, `focus_ipca_12m=4.5`, `ibc_br_output_gap=0.0`, `policy_inertia=0.0`.
   - i_star = 3.0+4.5+1.5*(4.5-3.0)+0.0+0.0 = 9.75, gap = 8.0-9.75 = -1.75 → LONG (policy loose).
   - Assert signal.direction == SignalDirection.LONG.
   - Assert signal.strength == SignalStrength.STRONG (|gap|=1.75 > 1.5 MODERATE_BAND).

5. `test_kalman_rstar_returns_float` (addresses TESTV2-01):
   - Build selic_series: pd.Series of 60 values ~12.5 (monthly Selic history).
   - Build expectations_series: pd.Series of 60 values ~4.5 (Focus 12M).
   - Build gap_series: pd.Series of 60 values ~0.5 (output gap).
   - Call `r_star, uncertainty = KalmanFilterRStar().estimate(selic_series, expectations_series, gap_series)`.
   - Assert isinstance(r_star, float).
   - Assert 0.0 < r_star < 20.0 (reasonable r* range).
   - Assert isinstance(uncertainty, float).

6. `test_kalman_rstar_insufficient_data` (addresses TESTV2-02):
   - Build series with only 10 observations.
   - Assert r_star == KalmanFilterRStar.DEFAULT_R_STAR (3.0).

7. `test_selic_path_model_short_market_above_model` (addresses TESTV2-01):
   - features: `di_1y=13.5`, `_as_of_date=date(2024,1,31)`.
   - i_star = 11.5 (market 13.5 > model 11.5 → SHORT, fade hike pricing).
   - Call `SelicPathModel().run(features, i_star=11.5, as_of_date=date(2024,1,31))`.
   - Assert signal.direction == SignalDirection.SHORT.
   - Assert signal.signal_id == "MONETARY_BR_SELIC_PATH".

8. `test_selic_path_model_long_market_below_model`:
   - features: `di_1y=9.0`, i_star = 11.5 (market below model → LONG, market underpricing hike risk).
   - Assert signal.direction == SignalDirection.LONG.

9. `test_term_premium_high_tp_long`:
   - Build `_tp_history` as pd.Series of 24 values: mean=1.0, std=0.5.
   - features: `di_10y=15.0`, `focus_ipca_12m=5.0`, `_r_star_estimate=3.0`, `_tp_history=tp_series`.
   - Current TP = 15.0 - (5.0 + 3.0) = 7.0. z = (7.0 - 1.0) / 0.5 = 12 >> 1.5 → LONG.
   - Assert signal.direction == SignalDirection.LONG.

10. `test_monetary_composite_weights_and_dampening`:
    - Build 3 synthetic AgentSignals for Taylor(SHORT), SelicPath(SHORT), TermPremium(LONG) — conflict detected.
    - Patch MonetaryPolicyAgent (MagicMock loader, no-op persistence) and call `_build_composite(signals, date(2024,1,31))`.
    - Assert composite.metadata["dampening"] == 0.7 (conflict detected: 2 SHORT vs 1 LONG, 1 disagrees).
    - Assert composite.direction == SignalDirection.SHORT (plurality = SHORT).
    - Assert composite.signal_id == "MONETARY_BR_COMPOSITE".

11. `test_monetary_composite_no_conflict`:
    - 3 SHORT signals → all agree → dampening == 1.0.
    - Assert composite.direction == SignalDirection.SHORT.
    - Assert composite.metadata["dampening"] == 1.0.

Use `pytest.approx` for float comparisons. Helper function to build synthetic AgentSignal:
```python
def make_signal(signal_id, direction, strength, confidence=0.7):
    return AgentSignal(
        signal_id=signal_id, agent_id="monetary_agent",
        timestamp=datetime.utcnow(), as_of_date=date(2024,1,31),
        direction=direction, strength=strength, confidence=confidence, value=1.0, horizon_days=252,
    )
```

Import AgentSignal from `src.agents.base`.

After writing, run `pytest tests/test_monetary_agent.py -v --tb=short` to confirm all tests pass. Fix any model bugs found during test execution directly in monetary_agent.py (inline in this task, not deferred).

Run `ruff check tests/test_monetary_agent.py` before committing.
  </action>
  <verify>
    Run: `pytest tests/test_monetary_agent.py -v --tb=short 2>&1 | tail -25`
    Expected: 11+ tests pass, 0 failed.
    Run: `ruff check tests/test_monetary_agent.py`
  </verify>
  <done>
    pytest reports 11+ passed, 0 failed, no database required.
    TaylorRuleModel: SHORT when gap=3.25bps (STRONG), NO_SIGNAL when gap < 1.0.
    KalmanFilterRStar: returns float r* and defaults to 3.0 when insufficient data.
    SelicPathModel: SHORT when market DI > Taylor model path.
    MONETARY_BR_COMPOSITE: dampening=0.7 when conflict, dampening=1.0 when unanimous.
    ruff check passes.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.agents.monetary_agent import MonetaryPolicyAgent, TaylorRuleModel, KalmanFilterRStar, SelicPathModel, TermPremiumModel, UsFedAnalysis"` — clean import
2. `python -c "from src.agents.features import MonetaryFeatureEngine, InflationFeatureEngine"` — both importable from features package
3. `pytest tests/test_monetary_agent.py -v` — all tests pass
4. `ruff check src/agents/features/ src/agents/monetary_agent.py tests/test_monetary_agent.py` — zero violations
5. TaylorRuleModel.GAP_FLOOR == 1.0 (100bps — locked per CONTEXT.md)
6. SelicPathModel direction convention: market > model → SHORT (verified in test)
</verification>

<success_criteria>
- MonetaryFeatureEngine.compute() returns dict with di_slope, di_belly, di_long_premium, di_1y_real, selic_target, real_rate_gap, policy_inertia, focus_ipca_12m, ibc_br_output_gap
- TaylorRuleModel.GAP_FLOOR == 1.0 (100bps, locked). MODERATE for 100-150bps, STRONG for > 150bps
- KalmanFilterRStar returns (float, float) tuple; defaults to 3.0 when < 24 obs
- SelicPathModel: market > model path → SHORT (fade hike pricing per rates strategy convention)
- MONETARY_BR_COMPOSITE weights: Taylor 50%, SelicPath 30%, TermPremium 20%
- US Fed stance is standalone signal (NOT fed into BR composite)
- All 11+ monetary unit tests pass without DB
- Both agents can be imported and are compatible with AgentRegistry.register()
</success_criteria>

<output>
After completion, create `.planning/phases/08-inflation-monetary-policy-agents/08-03-SUMMARY.md`
</output>
