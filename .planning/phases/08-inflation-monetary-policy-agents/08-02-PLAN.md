---
phase: 08-inflation-monetary-policy-agents
plan: 02
type: execute
wave: 2
depends_on:
  - 08-01
files_modified:
  - src/agents/inflation_agent.py
  - tests/test_inflation_agent.py
autonomous: true
requirements:
  - INFL-04
  - INFL-05
  - INFL-06
  - INFL-07
  - TESTV2-01
  - TESTV2-02

must_haves:
  truths:
    - "InflationAgent.run(as_of_date) returns an AgentReport with exactly 6 AgentSignal objects"
    - "INFLATION_BR_COMPOSITE direction equals the majority vote of its non-NO_SIGNAL sub-signals"
    - "InflationSurpriseModel returns LONG when z-score > 1.0 (upside surprise) and STRONG when |z| > 2.0"
    - "InflationPersistenceModel returns LONG when composite 0-100 score > 60 and SHORT when < 40"
    - "All inflation unit tests pass without a database connection"
  artifacts:
    - path: "src/agents/inflation_agent.py"
      provides: "Complete InflationAgent with all 5 sub-models and composite signal"
      exports: ["InflationAgent", "PhillipsCurveModel", "IpcaBottomUpModel", "InflationSurpriseModel", "InflationPersistenceModel", "UsInflationTrendModel"]
    - path: "tests/test_inflation_agent.py"
      provides: "Unit tests for feature engine keys and model signal directions"
      contains: "def test_inflation_feature_engine_keys"
  key_links:
    - from: "src/agents/inflation_agent.py"
      to: "InflationSurpriseModel, InflationPersistenceModel, UsInflationTrendModel"
      via: "instantiated in InflationAgent.__init__, called in run_models()"
      pattern: "run_models"
    - from: "src/agents/inflation_agent.py"
      to: "INFLATION_BR_COMPOSITE signal"
      via: "_build_composite() called at end of run_models()"
      pattern: "_build_composite"
    - from: "tests/test_inflation_agent.py"
      to: "src/agents/inflation_agent.py"
      via: "direct model instantiation with synthetic features dict"
      pattern: "PhillipsCurveModel|InflationSurpriseModel"
---

<objective>
Complete InflationAgent: add InflationSurpriseModel, InflationPersistenceModel, UsInflationTrendModel, implement run_models() and generate_narrative(), build INFLATION_BR_COMPOSITE signal, and write unit tests for all models.

Purpose: This plan closes out the InflationAgent as a fully runnable analytical agent. After this plan, InflationAgent.run(as_of_date) produces all 6 required signals and is registerable in AgentRegistry.
Output: Updated src/agents/inflation_agent.py (complete) and tests/test_inflation_agent.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-inflation-monetary-policy-agents/08-01-SUMMARY.md
@src/agents/base.py
@src/agents/data_loader.py
@src/core/enums.py
@tests/test_agents/test_base.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add remaining inflation models and complete InflationAgent orchestration</name>
  <files>
    src/agents/inflation_agent.py
  </files>
  <action>
Extend `src/agents/inflation_agent.py` (which already contains InflationAgent stub, PhillipsCurveModel, IpcaBottomUpModel from Plan 08-01) to add three remaining sub-models and complete InflationAgent.run_models() and generate_narrative().

**InflationSurpriseModel** class:

```python
class InflationSurpriseModel:
    """IPCA actual vs Focus MoM consensus z-score signal."""
    SIGNAL_ID = "INFLATION_BR_SURPRISE"
    Z_FIRE = 1.0    # |z| > 1.0 → signal fires
    Z_STRONG = 2.0  # |z| > 2.0 → STRONG
```

Implementation of `run(features: dict, as_of_date: date) -> AgentSignal`:
- From `features["_surprise_series"]` (a DataFrame with columns: actual_mom, focus_mom_median, computed by compute_features from IPCA MoM and Focus MoM median, aligned monthly) compute:
  - `monthly_surprise = actual_mom - focus_mom_median` (in pp)
  - `rolling_3m_avg = monthly_surprise.rolling(3).mean().iloc[-1]`
  - `trailing_12m = monthly_surprise.tail(12)`
  - `z_score = (rolling_3m_avg - trailing_12m.mean()) / trailing_12m.std()` (handle std=0 → return NEUTRAL)
- Direction rules (per CONTEXT.md locked decisions):
  - z > 0 (actual > consensus, upside surprise) → LONG (hawkish signal)
  - z < 0 (downside surprise) → SHORT
- Fires only when |z| >= Z_FIRE. If |z| < Z_FIRE: direction = NEUTRAL, strength = NO_SIGNAL, confidence = 0.0.
- Strength: |z| >= Z_STRONG → STRONG (confidence=0.85+), else classify_strength(min(abs(z)/2.0, 1.0)).
- value = round(z_score, 4), horizon_days=63
- metadata: {"z_score": z, "rolling_3m_avg_pp": rolling_3m_avg, "trailing_12m_std": std}
- If fewer than 12 months of surprise data: return NO_SIGNAL.
- On exception: log warning, return NO_SIGNAL.

**InflationPersistenceModel** class:

```python
class InflationPersistenceModel:
    """Composite 0-100 inflation persistence score from 4 components."""
    SIGNAL_ID = "INFLATION_BR_PERSISTENCE"
    WEIGHTS = {"diffusion": 0.25, "core_accel": 0.25, "services_mom": 0.25, "expectations": 0.25}
    HIGH_THRESHOLD = 60.0  # score > 60 → LONG (sticky inflation)
    LOW_THRESHOLD = 40.0   # score < 40 → SHORT (falling)
```

Implementation of `run(features: dict, as_of_date: date) -> AgentSignal`:
- Read from features:
  1. **Diffusion (0-100 normalized)**: `features["ipca_diffusion"]` — already 0-100 from BCB series. Sub-score = min(100, max(0, features["ipca_diffusion"])).
  2. **Core acceleration (3M vs 6M momentum)**: `features["ipca_core_smoothed"]` — compute 3M average minus 6M average of core YoY. Normalize: 50 + (diff * 10) clamped to [0, 100].
  3. **Services momentum (3M SAAR)**: from services YoY rolling data in `features["_services_3m_saar"]`. SAAR value in [0,15]. Normalize: min(100, max(0, saar / 15 * 100)).
  4. **Expectations anchoring (inverted)**: `features["focus_ipca_12m"]` — distance from BCB target (3.0%). anchoring_sub = max(0, 100 - abs(features["focus_ipca_12m"] - 3.0) * 20).
- If any sub-score is NaN, skip that component and renormalize weights among available components. If all 4 are NaN: return NO_SIGNAL.
- Composite score = weighted sum of available sub-scores (weights renormalized to sum=1.0).
- Direction: score > HIGH_THRESHOLD → LONG, score < LOW_THRESHOLD → SHORT, else NEUTRAL.
- confidence = abs(score - 50) / 50.0 (distance from neutral midpoint, 0→1).
- strength = classify_strength(confidence).
- value = round(score, 2), horizon_days=63.
- metadata: {"score": score, "diffusion_sub": d, "core_accel_sub": c, "services_sub": s, "expectations_sub": e}.

**UsInflationTrendModel** class:

```python
class UsInflationTrendModel:
    """US PCE core trend analysis vs Fed 2% target."""
    SIGNAL_ID = "INFLATION_US_TREND"
    FED_TARGET = 2.0
```

Implementation of `run(features: dict, as_of_date: date) -> AgentSignal`:
- Read: `pce_3m_saar = features["us_pce_core_3m_saar"]`, `pce_yoy = features["us_pce_core_yoy"]`, `supercore_mom = features["us_pce_supercore_mom_3m"]`.
- Target gap = pce_yoy - FED_TARGET.
- Trend signal: if pce_3m_saar > FED_TARGET and target_gap > 0 → LONG (above target, hawkish); if pce_3m_saar < FED_TARGET and target_gap < 0 → SHORT; else NEUTRAL.
- Secondary confirmation: if supercore_mom > 0 adds confirmation (raises confidence 10pp); if opposing → dampens 10pp.
- confidence = min(1.0, abs(target_gap) / 2.0)  — 2pp above target = full confidence.
- strength = classify_strength(confidence).
- If any of the three inputs are NaN: use only available inputs; if all NaN return NO_SIGNAL.
- value = round(pce_3m_saar, 4) if available else round(pce_yoy, 4), horizon_days=252.
- metadata: {"pce_3m_saar": pce_3m_saar, "target_gap_pp": target_gap, "supercore_momentum": supercore_mom}.

**Complete InflationAgent.run_models():**

```python
def run_models(self, features: dict) -> list[AgentSignal]:
    as_of_date = features["_as_of_date"]
    signals = []

    for model in [self.phillips, self.bottom_up, self.surprise, self.persistence, self.us_trend]:
        try:
            sig = model.run(features, as_of_date)
            signals.append(sig)
        except Exception as exc:
            self.log.warning("model_failed", model=model.SIGNAL_ID, error=str(exc))

    composite = self._build_composite(signals, as_of_date)
    signals.append(composite)
    return signals
```

Add models to `__init__`: `self.phillips = PhillipsCurveModel()`, `self.bottom_up = IpcaBottomUpModel()`, `self.surprise = InflationSurpriseModel()`, `self.persistence = InflationPersistenceModel()`, `self.us_trend = UsInflationTrendModel()`.

Store `features["_as_of_date"] = as_of_date` in compute_features().

**Complete InflationAgent._build_composite():**

```python
def _build_composite(self, signals: list[AgentSignal], as_of_date: date) -> AgentSignal:
    """Weighted composite of BR inflation sub-signals.

    Weights: Phillips 35%, BottomUp 30%, Surprise 20%, Persistence 15%.
    Conflict dampening: if >= 2 signals disagree with plurality, reduce confidence 30%.
    """
```

Implementation:
- Weights dict: `{INFLATION_BR_PHILLIPS: 0.35, INFLATION_BR_BOTTOMUP: 0.30, INFLATION_BR_SURPRISE: 0.20, INFLATION_BR_PERSISTENCE: 0.15}` (US trend excluded from BR composite, remains standalone).
- Filter to non-NO_SIGNAL BR signals only. If none available: return NO_SIGNAL composite.
- Renormalize weights for available signals (sum to 1.0).
- Majority vote for direction: count LONG vs SHORT vs NEUTRAL votes; plurality wins. Ties go NEUTRAL.
- Conflict detection: if >= 2 signals have a direction different from plurality direction → `dampening = 0.70` else `dampening = 1.0`.
- Composite confidence = sum(w * sig.confidence for available) * dampening.
- strength = classify_strength(composite_confidence).
- value = composite_confidence (the confidence itself as numeric signal).
- metadata: {"weights": effective_weights, "dampening": dampening, "sub_directions": {sig.signal_id: sig.direction.value for sig in active_signals}}.
- Return AgentSignal(signal_id="INFLATION_BR_COMPOSITE", agent_id="inflation_agent", ..., horizon_days=252).

**Complete InflationAgent.generate_narrative():**

Simple formatted string summarizing directions and composite score:
```python
def generate_narrative(self, signals, features) -> str:
    lines = ["# Inflation Agent Analysis", ""]
    for sig in signals:
        lines.append(f"- {sig.signal_id}: {sig.direction.value} ({sig.strength.value}, conf={sig.confidence:.2f})")
    lines.append(f"\nComposite inflation view: {composite_direction} as of {as_of_date}")
    return "\n".join(lines)
```

Also update `compute_features()` to set up `features["_surprise_series"]` (DataFrame with actual_mom and focus_mom aligned monthly) and `features["_services_3m_saar"]` from services data, using IBC-Br HP filter output already computed. Store `features["_as_of_date"]` = the as_of_date passed to load_data().

Run `ruff check --fix src/agents/inflation_agent.py` after writing.
  </action>
  <verify>
    Run: `python -c "from src.agents.inflation_agent import InflationAgent, InflationSurpriseModel, InflationPersistenceModel, UsInflationTrendModel; print('all models OK')"`
    Run: `python -c "from src.agents.inflation_agent import InflationSurpriseModel; m = InflationSurpriseModel(); print(m.Z_FIRE, m.Z_STRONG)"`
    Run: `ruff check src/agents/inflation_agent.py`
  </verify>
  <done>
    All 5 model classes importable. InflationSurpriseModel.Z_FIRE == 1.0, Z_STRONG == 2.0.
    InflationPersistenceModel.HIGH_THRESHOLD == 60.0. InflationAgent instantiates with a dummy PointInTimeDataLoader
    (mocked). ruff check passes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for InflationAgent models</name>
  <files>
    tests/test_inflation_agent.py
  </files>
  <action>
Create `tests/test_inflation_agent.py` with unit tests that use synthetic features dicts — no database connection required. Follow the pattern from `tests/test_agents/test_base.py` (DummyAgent, no-op persistence override).

**Test file structure:**

```python
"""Unit tests for InflationAgent models and InflationFeatureEngine.

All tests use synthetic data and mock the PointInTimeDataLoader.
No database connection required.
"""
from __future__ import annotations

import numpy as np
import pandas as pd
import pytest
from datetime import date, datetime
from unittest.mock import MagicMock, patch

from src.agents.inflation_agent import (
    InflationAgent,
    PhillipsCurveModel,
    IpcaBottomUpModel,
    InflationSurpriseModel,
    InflationPersistenceModel,
    UsInflationTrendModel,
)
from src.agents.features.inflation_features import InflationFeatureEngine
from src.core.enums import SignalDirection, SignalStrength
```

**Tests to implement:**

1. `test_inflation_feature_engine_keys` (addresses TESTV2-01):
   - Build a minimal synthetic `data` dict where each key contains a non-empty DataFrame with a "value" column and DatetimeIndex (monthly, 60 rows).
   - Call `InflationFeatureEngine().compute(data, date(2024, 1, 31))`.
   - Assert all required keys are present in output: `["ipca_yoy", "ipca_mom", "ipca_core_smoothed", "focus_ipca_12m", "ibc_br_level", "ibc_br_output_gap", "usdbrl_yoy", "crb_yoy", "us_pce_core_yoy", "us_pce_core_3m_saar", "us_pce_target_gap"]`.
   - Assert `"_raw_ols_data"` key is present (needed by PhillipsCurveModel).
   - Assert `"_raw_components"` key is present (needed by IpcaBottomUpModel).

2. `test_phillips_curve_model_direction_long` (addresses TESTV2-02):
   - Build `_raw_ols_data` DataFrame with 120 rows where core_yoy is ~8%, expectations_12m ~5%, output_gap ~2, usdbrl_yoy ~10, crb_yoy ~5 (synthetic but internally consistent high-inflation scenario).
   - `features = {"_raw_ols_data": df, "_as_of_date": date(2024,1,31)}`.
   - Call `PhillipsCurveModel().run(features, date(2024,1,31))`.
   - Assert signal.direction == SignalDirection.LONG (predicted core > 3.5% target).
   - Assert signal.signal_id == "INFLATION_BR_PHILLIPS".
   - Assert 0.0 <= signal.confidence <= 1.0.

3. `test_phillips_curve_model_no_signal_insufficient_data` (addresses TESTV2-02):
   - Build `_raw_ols_data` with only 10 rows.
   - Call `PhillipsCurveModel().run(features, date(2024,1,31))`.
   - Assert signal.strength == SignalStrength.NO_SIGNAL.
   - Assert signal.confidence == 0.0.

4. `test_ipca_bottom_up_seasonal` (addresses TESTV2-01):
   - Build `_raw_components` dict with all 9 keys, each a DataFrame with 60 monthly rows, "value" column, values ~0.5 MoM (6% annualized = above target).
   - Call `IpcaBottomUpModel().run({"_raw_components": comp_data, "_as_of_date": date(2024,1,31)}, date(2024,1,31))`.
   - Assert signal is not NO_SIGNAL (seasonal factors computed).
   - Assert signal.value > 3.0 (forecast exceeds 3% target given 0.5 MoM inputs).
   - Assert isinstance(signal.value, float).

5. `test_inflation_surprise_model_long_signal` (addresses TESTV2-01, TESTV2-02):
   - Build surprise_series with 15 monthly rows: actual_mom ~0.6, focus_mom_median ~0.3 (persistent upside surprise).
   - `features = {"_surprise_series": df, "_as_of_date": date(2024,1,31)}`.
   - Call `InflationSurpriseModel().run(features, date(2024,1,31))`.
   - Assert signal.direction == SignalDirection.LONG (upside surprise = hawkish).
   - Assert signal.strength in [SignalStrength.MODERATE, SignalStrength.STRONG, SignalStrength.WEAK] (not NO_SIGNAL — z should fire).

6. `test_inflation_surprise_model_strong_signal` (addresses TESTV2-02):
   - Build surprise_series with extreme upside: actual_mom ~0.9, focus_mom_median ~0.1 for last 3M.
   - Assert signal.strength == SignalStrength.STRONG (|z| > 2.0).

7. `test_persistence_model_long_high_diffusion` (addresses TESTV2-01):
   - Build features: `ipca_diffusion=75`, `ipca_core_smoothed` series trending up, `focus_ipca_12m=6.5`.
   - Call `InflationPersistenceModel().run(features, date(2024,1,31))`.
   - Assert signal.direction == SignalDirection.LONG (score > 60).

8. `test_persistence_model_short_low_diffusion` (addresses TESTV2-01):
   - Build features: `ipca_diffusion=25`, `ipca_core_smoothed` series declining, `focus_ipca_12m=3.0`.
   - Assert signal.direction == SignalDirection.SHORT (score < 40).

9. `test_us_inflation_trend_above_target`:
   - features: `us_pce_core_3m_saar=3.5`, `us_pce_core_yoy=3.2`, `us_pce_supercore_mom_3m=0.3`.
   - Assert signal.direction == SignalDirection.LONG.

10. `test_inflation_composite_majority_vote`:
    - Build 4 synthetic AgentSignals: 3 LONG + 1 SHORT for BR sub-signals.
    - Call `InflationAgent._build_composite(signals, date(2024,1,31))` directly (no DB needed — agent instantiated with MagicMock loader, persistence methods patched).
    - Assert composite.direction == SignalDirection.LONG (majority).
    - Assert composite.signal_id == "INFLATION_BR_COMPOSITE".
    - Assert 0.0 < composite.confidence <= 1.0.

11. `test_inflation_composite_conflict_dampening`:
    - Build 2 LONG + 2 SHORT sub-signals (tie or near-conflict).
    - Assert composite.confidence is lower than a pure-consensus scenario (dampening applied).
    - Assert composite.metadata["dampening"] == 0.7.

Use `pytest.approx` for floating point comparisons. Keep synthetic DataFrames simple: `pd.DataFrame({"value": [0.5]*60}, index=pd.date_range("2019-01-31", periods=60, freq="ME"))`.

Do NOT import database or connect to PostgreSQL — mock any loader with `MagicMock()`.

Run `pytest tests/test_inflation_agent.py -v --tb=short` after writing to confirm all tests pass (or identify any model bugs to fix inline).
  </action>
  <verify>
    Run: `pytest tests/test_inflation_agent.py -v --tb=short 2>&1 | tail -20`
    Expected: all 11 tests pass (no FAILED lines, may see warnings).
    Run: `ruff check tests/test_inflation_agent.py`
  </verify>
  <done>
    pytest reports 11 passed (or more if additional edge cases added), 0 failed.
    No import errors. ruff check passes. No test requires a running database.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.agents.inflation_agent import InflationAgent, InflationSurpriseModel, InflationPersistenceModel, UsInflationTrendModel"` — clean import
2. `pytest tests/test_inflation_agent.py -v` — all tests pass
3. `ruff check src/agents/inflation_agent.py tests/test_inflation_agent.py` — zero violations
4. InflationSurpriseModel: positive z > 1.0 → direction LONG, |z| > 2.0 → strength STRONG (verified in test_inflation_surprise_model_strong_signal)
5. INFLATION_BR_COMPOSITE metadata contains "dampening" key
</verification>

<success_criteria>
- InflationAgent.run_models() returns a list of exactly 6 AgentSignal objects (5 sub-models + composite)
- INFLATION_BR_COMPOSITE weights sum check: Phillips 0.35 + BottomUp 0.30 + Surprise 0.20 + Persistence 0.15 = 1.00
- All signals have direction in {LONG, SHORT, NEUTRAL} and confidence in [0.0, 1.0]
- All 11+ unit tests pass without database
- TESTV2-01 satisfied: feature engine keys test verifies all expected feature names
- TESTV2-02 satisfied: Phillips Curve OLS direction and NO_SIGNAL path verified with known inputs
</success_criteria>

<output>
After completion, create `.planning/phases/08-inflation-monetary-policy-agents/08-02-SUMMARY.md`
</output>
