---
phase: 02-connectors
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pyproject.toml
  - src/connectors/base.py
  - src/connectors/__init__.py
  - src/core/utils/__init__.py
  - src/core/utils/parsing.py
  - src/core/utils/calendars.py
  - src/core/utils/tenors.py
  - src/core/utils/logging_config.py
  - tests/__init__.py
  - tests/conftest.py
  - tests/connectors/__init__.py
  - tests/connectors/conftest.py
  - tests/utils/__init__.py
  - tests/utils/test_parsing.py
  - tests/utils/test_calendars.py
  - tests/utils/test_tenors.py
  - tests/fixtures/bcb_sgs_sample.json
  - tests/fixtures/fred_sample.json
  - tests/fixtures/ptax_sample.json
  - tests/fixtures/yahoo_sample.json
autonomous: true
requirements:
  - CONN-01
  - DATA-03
  - DATA-04
  - DATA-05
  - TEST-03

must_haves:
  truths:
    - "BaseConnector ABC can be subclassed and provides async HTTP client, retry with backoff, rate limiting, and structured logging"
    - "parse_numeric_value handles both period-decimal and comma-decimal formats correctly"
    - "Business day calendar utilities correctly identify ANBIMA and NYSE holidays"
    - "Tenor-to-days and tenor-to-date conversions produce correct dates with business day adjustment"
    - "pytest conftest provides async session fixture and sample date fixtures"
    - "All new dependencies (httpx, tenacity, respx, yfinance, bizdays, exchange_calendars) install successfully"
  artifacts:
    - path: "src/connectors/base.py"
      provides: "BaseConnector ABC with async HTTP, retry, rate limiting, idempotent store"
      min_lines: 100
    - path: "src/core/utils/parsing.py"
      provides: "parse_numeric_value utility for Brazilian and international number formats"
      exports: ["parse_numeric_value"]
    - path: "src/core/utils/calendars.py"
      provides: "Business day calendar utilities using bizdays (ANBIMA) and exchange_calendars (NYSE)"
      exports: ["is_business_day_br", "is_business_day_us", "count_business_days_br", "add_business_days_br"]
    - path: "src/core/utils/tenors.py"
      provides: "Tenor parsing, tenor-to-days, tenor-to-date, tenor-to-business-days conversions"
      exports: ["parse_tenor", "tenor_to_calendar_days", "tenor_to_date", "tenor_to_business_days"]
    - path: "tests/conftest.py"
      provides: "Async session fixture, sample date fixtures, sample API response loaders"
      min_lines: 30
  key_links:
    - from: "src/connectors/base.py"
      to: "src/core/database.py"
      via: "async_session_factory import for store() method"
      pattern: "from src\\.core\\.database import async_session_factory"
    - from: "src/connectors/base.py"
      to: "tenacity"
      via: "retry decorator on _request_with_retry"
      pattern: "from tenacity import"
    - from: "src/core/utils/calendars.py"
      to: "bizdays"
      via: "Calendar.load('ANBIMA')"
      pattern: "Calendar\\.load"
---

<objective>
Base connector infrastructure, data utility modules, and test scaffolding for Phase 2.

Purpose: Establish the BaseConnector abstract class, number/date/calendar utilities, and pytest test infrastructure that all four concrete connectors depend on. This plan also installs all new Python dependencies (httpx, tenacity, respx, yfinance, bizdays, exchange_calendars) into pyproject.toml.

Output: BaseConnector ABC in src/connectors/base.py, three utility modules in src/core/utils/, complete test infrastructure under tests/, and updated pyproject.toml with Phase 2 dependencies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-connectors/02-RESEARCH.md

@src/core/config.py
@src/core/database.py
@src/core/models/macro_series.py
@src/core/models/market_data.py
@src/core/models/series_metadata.py
@src/core/models/instruments.py
@src/core/models/data_sources.py
@src/connectors/__init__.py
@pyproject.toml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create BaseConnector ABC with exception hierarchy</name>
  <files>
    pyproject.toml
    src/connectors/base.py
    src/connectors/__init__.py
    src/core/utils/__init__.py
    src/core/utils/logging_config.py
  </files>
  <action>
**1. Update pyproject.toml dependencies:**

Add to `[project] dependencies`:
- `httpx>=0.27.0`
- `tenacity>=8.2.0`
- `yfinance>=0.2.36`
- `bizdays>=1.0.0`
- `exchange_calendars>=4.5.0`
- `python-dateutil>=2.8.0`

Add to `[project.optional-dependencies] dev`:
- `respx>=0.21.0`
- `pytest-cov>=4.1.0`

Run `pip install -e ".[dev]"` to install all new deps.

**2. Create src/core/utils/__init__.py** (empty package init).

**3. Create src/core/utils/logging_config.py:**
- Configure structlog with:
  - `structlog.contextvars.merge_contextvars` as first processor
  - `structlog.processors.add_log_level`
  - `structlog.processors.TimeStamper(fmt="iso")`
  - `structlog.dev.ConsoleRenderer()` (dev mode)
- Provide `get_logger(name: str) -> structlog.BoundLogger` function
- Provide `configure_logging()` function that runs structlog.configure() once

**4. Create src/connectors/base.py with BaseConnector:**

Exception hierarchy at module level:
- `ConnectorError(Exception)` -- base for all connector errors
- `RateLimitError(ConnectorError)` -- API rate limit hit
- `DataParsingError(ConnectorError)` -- response data parse failure
- `FetchError(ConnectorError)` -- HTTP fetch failure after retries

BaseConnector(abc.ABC) class:
- Class attributes (subclasses MUST override): `SOURCE_NAME: str`, `BASE_URL: str`
- Class attributes (subclasses MAY override): `RATE_LIMIT_PER_SECOND: float = 5.0`, `MAX_RETRIES: int = 3`, `TIMEOUT_SECONDS: float = 30.0`
- `__init__(self)`: creates `self._client: httpx.AsyncClient | None = None`, `self._semaphore = asyncio.Semaphore(int(self.RATE_LIMIT_PER_SECOND))`, `self.log = structlog.get_logger().bind(connector=self.SOURCE_NAME)`
- `async __aenter__(self)`: creates httpx.AsyncClient with `base_url=self.BASE_URL`, `timeout=httpx.Timeout(self.TIMEOUT_SECONDS)`, `limits=httpx.Limits(max_connections=10, max_keepalive_connections=5)`. Returns self.
- `async __aexit__(self, *exc)`: closes client if exists
- `client` property: returns `self._client`, raises ConnectorError if None
- `async _request(self, method: str, url: str, **kwargs) -> httpx.Response`: rate-limited wrapper using `async with self._semaphore`, delegates to `_request_with_retry`
- `_request_with_retry` method decorated with `@retry(retry=retry_if_exception_type((httpx.HTTPStatusError, httpx.ConnectError, httpx.TimeoutException)), stop=stop_after_attempt(self.MAX_RETRIES), wait=wait_exponential_jitter(initial=1, max=30, jitter=5), before_sleep=before_sleep_log(self.log, "warning"), reraise=True)`. Inside: calls `self.client.request(method, url, **kwargs)`, checks for 429 status (raises RateLimitError), calls `response.raise_for_status()`, returns response.

  NOTE: Since tenacity decorators don't support instance attribute references like `self.MAX_RETRIES` directly, implement retry logic inside `_request_with_retry` using `async for attempt in AsyncRetrying(...)` pattern instead of decorator. This allows accessing `self.MAX_RETRIES`.

- Abstract methods:
  - `async def fetch(self, start_date: date, end_date: date, **kwargs) -> list[dict[str, Any]]`
  - `async def store(self, records: list[dict[str, Any]]) -> int`

- Concrete method `async def run(self, start_date: date, end_date: date, **kwargs) -> int`:
  - Calls `self.fetch()` then `self.store()`
  - Logs "no_records_fetched" if empty, "ingestion_complete" with fetched/inserted counts otherwise
  - Returns count of inserted records

- Concrete helper `async def _bulk_insert(self, model_class, records: list[dict], constraint_name: str) -> int`:
  - Uses `sqlalchemy.dialects.postgresql.insert as pg_insert`
  - `async with async_session_factory() as session: async with session.begin(): stmt = pg_insert(model_class).values(records); stmt = stmt.on_conflict_do_nothing(constraint=constraint_name); result = await session.execute(stmt); return result.rowcount`
  - This is the reusable ON CONFLICT DO NOTHING pattern (DATA-03)

**5. Update src/connectors/__init__.py:**
- Import and re-export: `BaseConnector, ConnectorError, RateLimitError, DataParsingError, FetchError` from `.base`
  </action>
  <verify>
Run: `python -c "from src.connectors.base import BaseConnector, ConnectorError, RateLimitError, DataParsingError, FetchError; print('BaseConnector imported successfully')"` -- should print success message.

Run: `python -c "from src.core.utils.logging_config import get_logger, configure_logging; print('Logging config imported')"` -- should succeed.

Run: `pip list | grep -E 'httpx|tenacity|respx|yfinance|bizdays|exchange.calendars'` -- all 6 packages should be listed.
  </verify>
  <done>
BaseConnector ABC exists with async context manager, retry with exponential backoff + jitter, rate limiting via semaphore, structured logging, and reusable _bulk_insert helper with ON CONFLICT DO NOTHING. All Phase 2 Python dependencies installed. Exception hierarchy provides ConnectorError, RateLimitError, DataParsingError, FetchError.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create data utilities (parsing, calendars, tenors) with tests and test infrastructure</name>
  <files>
    src/core/utils/parsing.py
    src/core/utils/calendars.py
    src/core/utils/tenors.py
    tests/__init__.py
    tests/conftest.py
    tests/connectors/__init__.py
    tests/connectors/conftest.py
    tests/utils/__init__.py
    tests/utils/test_parsing.py
    tests/utils/test_calendars.py
    tests/utils/test_tenors.py
    tests/fixtures/bcb_sgs_sample.json
    tests/fixtures/fred_sample.json
    tests/fixtures/ptax_sample.json
    tests/fixtures/yahoo_sample.json
  </files>
  <action>
**1. Create src/core/utils/parsing.py:**

```python
def parse_numeric_value(raw: str, decimal_sep: str = ".") -> float | None:
```
- Handles both period-decimal (international) and comma-decimal (Brazilian) formats
- If `decimal_sep == ","`: remove period thousands separators, replace comma with period, then float()
- If `decimal_sep == "."`: remove comma thousands separators, then float()
- Returns None for empty strings, "-", ".", whitespace-only
- Raises `ValueError` for genuinely unparseable values
- Include type hints and docstring with examples

**2. Create src/core/utils/calendars.py:**

Using bizdays and exchange_calendars as recommended in RESEARCH.md:

```python
from bizdays import Calendar
import exchange_calendars as xcals
```

- Module-level lazy initialization:
  - `_anbima_cal: Calendar | None = None` with `_get_anbima()` that does `Calendar.load("ANBIMA")` on first call
  - `_nyse_cal` with `_get_nyse()` that does `xcals.get_calendar("XNYS")` on first call

- Functions (all take `date` objects):
  - `is_business_day_br(d: date) -> bool` -- uses ANBIMA calendar
  - `is_business_day_us(d: date) -> bool` -- uses NYSE calendar (note: exchange_calendars uses `pd.Timestamp` internally, convert)
  - `count_business_days_br(start: date, end: date) -> int` -- ANBIMA bizdays count (exclusive of start)
  - `count_business_days_us(start: date, end: date) -> int` -- NYSE session count
  - `add_business_days_br(d: date, n: int) -> date` -- offset by n business days using ANBIMA
  - `next_business_day_br(d: date) -> date` -- next BD if d is not a BD, else d
  - `previous_business_day_br(d: date) -> date` -- previous BD
  - `next_business_day_us(d: date) -> date`
  - `previous_business_day_us(d: date) -> date`

**3. Create src/core/utils/tenors.py:**

```python
import re
from datetime import date, timedelta
from dateutil.relativedelta import relativedelta
```

- `TENOR_PATTERN = re.compile(r"^(\d+)([DWMY])$", re.IGNORECASE)`
- `parse_tenor(tenor: str) -> tuple[int, str]` -- returns (count, unit_letter)
- `tenor_to_calendar_days(tenor: str) -> int` -- approximate: D=1, W=7, M=30, Y=365
- `tenor_to_date(tenor: str, reference_date: date, calendar=None) -> date`:
  - D units: if calendar, use calendar.offset; else timedelta
  - W: timedelta(weeks=count)
  - M: relativedelta(months=count)
  - Y: relativedelta(years=count)
  - If calendar provided and result is not a business day, roll to next business day (Following convention)
- `tenor_to_business_days(tenor: str, reference_date: date, calendar) -> int` -- compute target date then count BDs

**4. Create test infrastructure:**

- `tests/__init__.py` -- empty
- `tests/utils/__init__.py` -- empty
- `tests/connectors/__init__.py` -- empty

- `tests/conftest.py` -- root conftest:
  - Fixture `sample_dates` returning dict with common test date ranges: `{"start_2024": date(2024, 1, 1), "end_2024": date(2024, 12, 31), "start_2025": date(2025, 1, 1), "mid_2025": date(2025, 6, 15)}`
  - Fixture `load_fixture` returning a callable that loads JSON from tests/fixtures/ directory using `pathlib.Path`

- `tests/connectors/conftest.py` -- connector-specific conftest:
  - Fixture `bcb_sgs_response` that loads tests/fixtures/bcb_sgs_sample.json
  - Fixture `fred_response` that loads tests/fixtures/fred_sample.json
  - Fixture `ptax_response` that loads tests/fixtures/ptax_sample.json

**5. Create test fixture JSON files:**

`tests/fixtures/bcb_sgs_sample.json`:
```json
[
  {"data": "02/01/2025", "valor": "0.16"},
  {"data": "03/01/2025", "valor": "1.31"},
  {"data": "04/01/2025", "valor": "0.83"},
  {"data": "05/01/2025", "valor": ""},
  {"data": "06/01/2025", "valor": "-"}
]
```

`tests/fixtures/fred_sample.json`:
```json
{
  "realtime_start": "2025-01-01",
  "realtime_end": "2025-12-31",
  "observation_start": "2025-01-01",
  "observation_end": "2025-06-30",
  "observations": [
    {"realtime_start": "2025-02-14", "realtime_end": "2025-03-14", "date": "2025-01-01", "value": "308.417"},
    {"realtime_start": "2025-03-15", "realtime_end": "9999-12-31", "date": "2025-01-01", "value": "308.620"},
    {"realtime_start": "2025-03-15", "realtime_end": "9999-12-31", "date": "2025-02-01", "value": "309.685"},
    {"realtime_start": "2025-04-10", "realtime_end": "9999-12-31", "date": "2025-03-01", "value": "."}
  ]
}
```

`tests/fixtures/ptax_sample.json`:
```json
{
  "value": [
    {"cotacaoCompra": 5.7036, "cotacaoVenda": 5.7042, "dataHoraCotacao": "2025-01-15 13:07:03.490", "tipoBoletim": "Fechamento"},
    {"cotacaoCompra": 5.6900, "cotacaoVenda": 5.6910, "dataHoraCotacao": "2025-01-15 10:05:12.123", "tipoBoletim": "Abertura"},
    {"cotacaoCompra": 5.7150, "cotacaoVenda": 5.7160, "dataHoraCotacao": "2025-01-16 13:08:45.567", "tipoBoletim": "Fechamento"}
  ]
}
```

`tests/fixtures/yahoo_sample.json`:
```json
{
  "tickers": ["BRL=X", "^GSPC"],
  "sample_data": {
    "BRL=X": [
      {"Date": "2025-01-02", "Open": 6.18, "High": 6.21, "Low": 6.15, "Close": 6.19, "Volume": 0},
      {"Date": "2025-01-03", "Open": 6.19, "High": 6.22, "Low": 6.17, "Close": 6.20, "Volume": 0}
    ],
    "^GSPC": [
      {"Date": "2025-01-02", "Open": 5881.63, "High": 5906.47, "Low": 5867.08, "Close": 5881.63, "Volume": 3544500000},
      {"Date": "2025-01-03", "Open": 5900.12, "High": 5920.87, "Low": 5880.56, "Close": 5906.47, "Volume": 3628100000}
    ]
  }
}
```

**6. Create test files:**

`tests/utils/test_parsing.py`:
- Test `parse_numeric_value("0.16", ".")` == 0.16
- Test `parse_numeric_value("1.234,56", ",")` == 1234.56
- Test `parse_numeric_value("1,234.56", ".")` == 1234.56
- Test `parse_numeric_value("", ".")` is None
- Test `parse_numeric_value("-", ".")` is None
- Test `parse_numeric_value(".", ".")` is None
- Test `parse_numeric_value("abc", ".")` raises ValueError

`tests/utils/test_calendars.py`:
- Test `is_business_day_br(date(2025, 3, 3))` is False (Carnaval Monday 2025)
- Test `is_business_day_br(date(2025, 3, 4))` is False (Carnaval Tuesday 2025)
- Test `is_business_day_br(date(2025, 3, 5))` is True (Ash Wednesday is a business day after noon, but ANBIMA treats it as a holiday in many calendars -- verify and adjust test accordingly)
- Test `is_business_day_br(date(2025, 1, 1))` is False (New Year)
- Test `is_business_day_br(date(2025, 1, 2))` is True (normal Thursday)
- Test `is_business_day_us(date(2025, 1, 1))` is False (New Year)
- Test `is_business_day_us(date(2025, 7, 4))` is False (Independence Day)
- Test `is_business_day_us(date(2025, 1, 2))` is True
- Test `count_business_days_br` for a known range
- Test `add_business_days_br` for a known case

`tests/utils/test_tenors.py`:
- Test `parse_tenor("3M")` == (3, "M")
- Test `parse_tenor("1Y")` == (1, "Y")
- Test `parse_tenor("21D")` == (21, "D")
- Test `parse_tenor("2W")` == (2, "W")
- Test `tenor_to_calendar_days("3M")` == 90
- Test `tenor_to_calendar_days("1Y")` == 365
- Test `tenor_to_date("1M", date(2025, 1, 15))` == date(2025, 2, 15)
- Test `tenor_to_date("1Y", date(2025, 1, 15))` == date(2026, 1, 15)
- Test invalid tenor raises ValueError
  </action>
  <verify>
Run: `python -m pytest tests/utils/ -v` -- all parsing, calendar, and tenor tests should pass.

Run: `python -c "from src.core.utils.parsing import parse_numeric_value; assert parse_numeric_value('1.234,56', ',') == 1234.56; print('Parsing OK')"` -- should print "Parsing OK".

Run: `python -c "from src.core.utils.calendars import is_business_day_br; print('BR cal:', is_business_day_br(__import__('datetime').date(2025,1,1)))"` -- should print False.
  </verify>
  <done>
Three utility modules (parsing, calendars, tenors) exist with comprehensive tests passing. Test infrastructure (conftest, fixtures, directory structure) is ready for connector tests. parse_numeric_value handles both period and comma decimal formats. Business day calendars work for ANBIMA (BR) and NYSE (US). Tenor conversions produce correct dates.
  </done>
</task>

</tasks>

<verification>
1. `pip install -e ".[dev]"` succeeds with all new dependencies
2. `python -c "from src.connectors.base import BaseConnector"` imports without error
3. `python -c "from src.core.utils.parsing import parse_numeric_value"` imports without error
4. `python -c "from src.core.utils.calendars import is_business_day_br, is_business_day_us"` imports without error
5. `python -c "from src.core.utils.tenors import parse_tenor, tenor_to_date"` imports without error
6. `python -m pytest tests/utils/ -v` -- all utility tests pass
7. BaseConnector cannot be instantiated directly (is abstract)
</verification>

<success_criteria>
- BaseConnector ABC has: async context manager, retry with backoff, rate limiting, structured logging, _bulk_insert with ON CONFLICT DO NOTHING
- parse_numeric_value correctly handles: "0.16" (period), "1.234,56" (comma), empty strings, "-", "."
- Business day calendars load ANBIMA and NYSE calendars and correctly identify holidays
- Tenor utilities parse standard tenors and convert to dates with business day adjustment
- Test infrastructure exists with conftest fixtures, sample JSON fixtures, and passing utility tests
- All 6 new Python packages installed (httpx, tenacity, yfinance, bizdays, exchange_calendars, respx)
</success_criteria>

<output>
After completion, create `.planning/phases/02-connectors/02-01-SUMMARY.md`
</output>
