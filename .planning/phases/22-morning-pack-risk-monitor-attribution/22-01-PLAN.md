---
phase: 22-morning-pack-risk-monitor-attribution
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pms/morning_pack.py
  - src/pms/attribution.py
  - tests/test_pms/test_morning_pack.py
  - tests/test_pms/test_attribution.py
autonomous: true
requirements:
  - PMS-MP-01
  - PMS-MP-03
  - PMS-PA-01
  - PMS-PA-02
  - PMS-PA-03

must_haves:
  truths:
    - "MorningPackService.generate() returns a DailyBriefing dict with all sections: action_items, trade_proposals, market_snapshot, agent_views, regime, signals, signal_changes, portfolio_state, macro_narrative"
    - "Morning Pack uses action-first ordering: action items and proposals before context sections"
    - "MorningPackService auto-persists each briefing to internal _briefings list"
    - "LLM narrative generation with template fallback produces 4-5 paragraph analytical brief"
    - "PerformanceAttributionEngine decomposes P&L by strategy, asset class, instrument, factor, and time period"
    - "Factor-based attribution uses tag mapping (carry, momentum, mean-reversion, event-driven, relative-value, macro-discretionary)"
    - "Attribution supports daily, WTD, MTD, QTD, YTD, inception, and custom date range periods"
    - "Attribution is additive: each dimension sums to total P&L independently"
  artifacts:
    - path: "src/pms/morning_pack.py"
      provides: "MorningPackService with generate(), get_latest(), get_by_date() methods"
      contains: "class MorningPackService"
    - path: "src/pms/attribution.py"
      provides: "PerformanceAttributionEngine with compute_attribution(), compute_equity_curve()"
      contains: "class PerformanceAttributionEngine"
    - path: "tests/test_pms/test_morning_pack.py"
      provides: "Tests for MorningPackService"
      contains: "test_generate_morning_pack"
    - path: "tests/test_pms/test_attribution.py"
      provides: "Tests for PerformanceAttributionEngine"
      contains: "test_attribution_sums_to_total"
  key_links:
    - from: "src/pms/morning_pack.py"
      to: "src/pms/trade_workflow.py"
      via: "TradeWorkflowService.get_pending_proposals()"
      pattern: "get_pending_proposals"
    - from: "src/pms/morning_pack.py"
      to: "src/pms/position_manager.py"
      via: "PositionManager.get_book()"
      pattern: "get_book"
    - from: "src/pms/attribution.py"
      to: "src/pms/position_manager.py"
      via: "PositionManager positions and P&L history"
      pattern: "_positions|_pnl_history"
---

<objective>
Create MorningPackService and PerformanceAttributionEngine -- two core PMS services that consolidate system intelligence into actionable daily briefings and multi-dimensional P&L attribution.

Purpose: These services power the operational frontend pages (Phase 23/25). MorningPackService is the daily command center for the portfolio manager; PerformanceAttributionEngine enables understanding WHERE returns come from.

Output: `src/pms/morning_pack.py`, `src/pms/attribution.py`, and their test suites.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/pms/position_manager.py
@src/pms/trade_workflow.py
@src/pms/__init__.py
@src/portfolio/signal_aggregator_v2.py
@src/portfolio/signal_monitor.py
@src/agents/registry.py
@src/risk/var_calculator.py
@src/risk/risk_limits_v2.py
@src/risk/stress_tester.py
@src/agents/cross_asset_view.py
@tests/test_pms/test_trade_workflow.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: MorningPackService with daily briefing generation, LLM narrative, and action items</name>
  <files>src/pms/morning_pack.py, tests/test_pms/test_morning_pack.py</files>
  <action>
Create `src/pms/morning_pack.py` with class `MorningPackService`.

**Constructor** accepts optional component references (all default to None for graceful degradation):
- `position_manager: PositionManager | None` -- from src.pms.position_manager
- `trade_workflow: TradeWorkflowService | None` -- from src.pms.trade_workflow
- `signal_aggregator: SignalAggregatorV2 | None` -- from src.portfolio.signal_aggregator_v2
- `signal_monitor: SignalMonitor | None` -- from src.portfolio.signal_monitor
- `risk_limits_manager: RiskLimitsManager | None` -- from src.risk.risk_limits_v2
- `var_calculator: VaRCalculator | None` -- from src.risk.var_calculator
- `stress_tester: StressTester | None` -- from src.risk.stress_tester
- Internal `_briefings: list[dict]` for auto-persistence (same in-memory pattern as PositionManager._positions)

**generate(briefing_date: date, force: bool = False) -> dict:**
The core method. If briefing for this date already exists and force=False, return existing.

Collect each section with try/except returning `{"status": "unavailable", "reason": str}` on failure (graceful degradation per user decision). Sections:

1. **action_items** (FIRST per action-first ordering decision):
   - Trade proposals from trade_workflow.get_pending_proposals()
   - Risk limit breaches from risk_limits_manager (if latest check_all_v2 shows WARNING/BREACHED)
   - Signal flips/conviction surges from signal_monitor (if available)
   - Stale data warnings (if any section failed to load)
   - Regime changes (if cross-asset agent view available)
   Each item: `{priority: "CRITICAL"|"HIGH"|"MEDIUM"|"LOW", category: str, description: str, urgency: str}`
   Sort by priority (CRITICAL first).

2. **trade_proposals**: List of pending proposals from trade_workflow

3. **market_snapshot**: Dict with groups of macro indicators. Since direct DB access is deferred, build a placeholder structure:
   `{brazil_rates: {}, brazil_macro: {}, fx: {}, us_rates: {}, us_macro: {}, global_: {}, credit: {}}`
   Each group can be populated by the caller or by the Dagster pipeline.

4. **agent_views**: For each of the 5 agents (inflation, monetary, fiscal, fx, cross_asset), include:
   `{agent_id, signal_direction, conviction, key_drivers: list[str], risks: list[str], narrative_excerpt: str}`
   Use AgentRegistry to get registered agents and their latest reports if available. Return placeholder if agent not registered.

5. **regime**: Current regime from CrossAssetAgent view (Goldilocks/Reflation/Stagflation/Deflation) with probabilities. Placeholder dict if unavailable.

6. **top_signals**: Top 10 signals by conviction from signal_aggregator if available.

7. **signal_changes**: Dict with `{flips: list, surges: list, new_above_threshold: list}` from signal_monitor.

8. **portfolio_state**: From position_manager.get_book() -- summary, positions count, leverage, P&L today/MTD/YTD.

9. **macro_narrative**: LLM-generated 4-5 paragraph analytical brief (~400 words). Use Claude API (ANTHROPIC_API_KEY) with httpx.post to api.anthropic.com/v1/messages. The prompt should request a research-note-style analysis connecting dots across agents, regime, signals, and portfolio. On any failure, fall back to a template-based narrative that concatenates key data points. Per user decision: analytical brief, not abbreviated.

Auto-persist: Append the complete briefing dict (with `id`, `briefing_date`, `created_at`, all sections) to `self._briefings`.

**get_latest() -> dict | None:** Return most recent briefing from _briefings.
**get_by_date(briefing_date: date) -> dict | None:** Find by date.
**get_history(days: int = 30) -> list[dict]:** Return last N briefings (summary only: date, action count, narrative excerpt).

**Tests** in `tests/test_pms/test_morning_pack.py`:
- test_generate_morning_pack: Create MorningPackService with PositionManager + TradeWorkflowService (real instances, no mocks needed since in-memory). Generate a briefing. Verify all 9 sections present. Verify action-first ordering (action_items is first key or first section).
- test_graceful_degradation: Create MorningPackService with None for all optional components. Generate should still succeed with "unavailable" markers.
- test_auto_persist: Generate twice (different dates). Verify _briefings has 2 entries. get_latest() returns the second.
- test_action_items_prioritization: Set up a scenario with a pending proposal and a risk warning. Verify action items sorted by priority.

Follow the same code style as trade_workflow.py: `from __future__ import annotations`, structlog logger, docstrings, type hints.
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_pms/test_morning_pack.py -v</verify>
  <done>MorningPackService.generate() produces complete DailyBriefing dict with all 9 sections, action-first ordering, graceful degradation, LLM narrative with template fallback, and auto-persistence. 4 tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: PerformanceAttributionEngine with multi-dimensional P&L decomposition and factor tags</name>
  <files>src/pms/attribution.py, tests/test_pms/test_attribution.py</files>
  <action>
Create `src/pms/attribution.py` with class `PerformanceAttributionEngine`.

**Constructor** accepts:
- `position_manager: PositionManager | None` -- from src.pms.position_manager (direct import, same in-process pattern)

**FACTOR_TAGS class constant** -- maps strategy_id prefix to factor tags (per user decision: tag-based factor mapping):
```python
FACTOR_TAGS: dict[str, list[str]] = {
    "RATES_BR_01": ["carry"],
    "RATES_BR_02": ["macro-discretionary"],
    "RATES_BR_03": ["momentum", "mean-reversion"],
    "RATES_BR_04": ["macro-discretionary"],
    "RATES_03": ["relative-value"],
    "RATES_04": ["carry", "mean-reversion"],
    "RATES_05": ["event-driven"],
    "RATES_06": ["event-driven"],
    "FX_BR_01": ["carry"],
    "FX_02": ["carry", "momentum"],
    "FX_03": ["momentum"],
    "FX_04": ["relative-value"],
    "FX_05": ["macro-discretionary"],
    "INF_BR_01": ["carry"],
    "INF_02": ["event-driven"],
    "INF_03": ["carry"],
    "CUPOM_01": ["carry", "relative-value"],
    "CUPOM_02": ["relative-value"],
    "SOV_BR_01": ["macro-discretionary"],
    "SOV_01": ["momentum"],
    "SOV_02": ["relative-value"],
    "SOV_03": ["event-driven"],
    "CROSS_01": ["macro-discretionary"],
    "CROSS_02": ["momentum"],
}
```

**compute_attribution(start_date, end_date=None, period_label=None) -> dict:**
Main method. Uses position_manager._positions and _pnl_history.

Collect all positions active during the period (open before end_date AND (still open OR closed after start_date)).

Compute:
1. **period**: `{start, end, calendar_days, label}` -- label from period_label or computed
2. **total_pnl_brl**: Sum of realized P&L for closed positions + unrealized P&L for open positions within period
3. **total_return_pct**: total_pnl_brl / AUM * 100

4. **by_strategy**: Group positions by strategy_ids. For each strategy: `{strategy_id, pnl_brl, return_contribution_pct, trades_count, win_rate_pct}`. For positions with multiple strategy_ids, split P&L by strategy_weights (equal if not specified). Sum must equal total (additive).

5. **by_asset_class**: Group by asset_class. `{asset_class, pnl_brl, return_contribution_pct, avg_notional_brl}`. Sum must equal total.

6. **by_instrument**: Per position. `{position_id, instrument, direction, pnl_brl, return_pct, holding_days}`. Sum must equal total.

7. **by_factor**: Using FACTOR_TAGS, map each position's strategy_ids to factors. If a position maps to multiple factors, split P&L equally. `{factor, pnl_brl, return_contribution_pct, strategies_count}`. Factors: carry, momentum, mean-reversion, event-driven, relative-value, macro-discretionary.

8. **by_trade_type**: `{systematic: {pnl_brl, count}, discretionary: {pnl_brl, count}}`. Discretionary = signal_source == "DISCRETIONARY" in linked proposals (check trade_workflow if available), else all systematic.

9. **performance_stats**: Compute from daily P&L snapshots in _pnl_history within period: annualized_return_pct, annualized_vol_pct, sharpe_ratio (rf=0 for simplicity), sortino_ratio, max_drawdown_pct, win_rate_pct (% positive days), profit_factor (sum gains / abs sum losses), avg_win_brl, avg_loss_brl.

**Helper methods:**
- `compute_for_period(period: str) -> dict`: Convenience. period = "daily"|"WTD"|"MTD"|"QTD"|"YTD"|"inception"|"custom". For standard periods, compute start_date from end_date (today). For "inception", use earliest position entry_date.
- `compute_custom_range(start_date: date, end_date: date) -> dict`: Same as compute_attribution with explicit dates.
- `compute_equity_curve(start_date: date, end_date: date = None) -> list[dict]`: From _pnl_history, aggregate by date: `[{date, equity_brl, return_pct_daily, return_pct_cumulative, drawdown_pct}]`.
- `_get_factor_tags(strategy_id: str) -> list[str]`: Lookup in FACTOR_TAGS, default to ["untagged"].

**Tests** in `tests/test_pms/test_attribution.py`:
- test_attribution_sums_to_total: Create PositionManager with 3 positions across 2 asset classes. Open, MTM, close some. Run compute_attribution. Verify by_strategy sum == by_asset_class sum == by_instrument sum == total_pnl_brl.
- test_factor_attribution: Verify factor tags are applied correctly. Position with strategy_id="FX_02" should attribute to "carry" and "momentum".
- test_extended_periods: Test compute_for_period with "MTD", "YTD", "inception". Verify each returns valid attribution.
- test_equity_curve_consistency: Create 3 days of MTM snapshots. Verify equity curve has 3 points with correct cumulative returns.

Follow same code style: `from __future__ import annotations`, structlog, docstrings, type hints.
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_pms/test_attribution.py -v</verify>
  <done>PerformanceAttributionEngine decomposes P&L across 5 dimensions (strategy, asset class, instrument, factor, trade type) with extended periods and additive attribution. Factor tags cover all 24 strategies. 4 tests pass.</done>
</task>

</tasks>

<verification>
```bash
cd /home/user/Macro_Trading
python -m pytest tests/test_pms/test_morning_pack.py tests/test_pms/test_attribution.py -v
python -c "from src.pms.morning_pack import MorningPackService; print('MorningPackService imported OK')"
python -c "from src.pms.attribution import PerformanceAttributionEngine; print('AttributionEngine imported OK')"
```
</verification>

<success_criteria>
- MorningPackService.generate() returns dict with 9 sections in action-first order
- All sections degrade gracefully to "unavailable" when components are None
- PerformanceAttributionEngine.compute_attribution() returns dict with 9 decomposition groups
- Factor attribution uses tag-based mapping for all 24 strategies
- Both services use in-memory patterns (no DB dependency, consistent with Phase 20-21)
- All 8 tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/22-morning-pack-risk-monitor-attribution/22-01-SUMMARY.md`
</output>
