---
phase: 22-morning-pack-risk-monitor-attribution
plan: 03
type: execute
wave: 2
depends_on:
  - 22-01
  - 22-02
files_modified:
  - src/api/routes/pms_briefing.py
  - src/api/routes/pms_risk.py
  - src/api/routes/pms_attribution.py
  - src/api/schemas/pms_schemas.py
  - src/api/main.py
  - src/pms/__init__.py
  - tests/test_pms/test_pms_api.py
autonomous: true
requirements:
  - PMS-MP-02
  - PMS-RM-01
  - PMS-RM-02
  - PMS-RM-03

must_haves:
  truths:
    - "GET /api/v1/pms/morning-pack/latest returns the most recent DailyBriefing"
    - "POST /api/v1/pms/morning-pack/generate triggers new briefing generation"
    - "GET /api/v1/pms/risk/live returns complete risk snapshot"
    - "GET /api/v1/pms/risk/trend returns 30-day trend data"
    - "GET /api/v1/pms/attribution returns P&L attribution for specified period"
    - "All 3 new routers registered in main.py with PMS OpenAPI tags"
    - "Pydantic response schemas validate all API responses"
  artifacts:
    - path: "src/api/routes/pms_briefing.py"
      provides: "Morning Pack API endpoints"
      contains: "router = APIRouter"
    - path: "src/api/routes/pms_risk.py"
      provides: "Risk Monitor API endpoints"
      contains: "router = APIRouter"
    - path: "src/api/routes/pms_attribution.py"
      provides: "Performance Attribution API endpoints"
      contains: "router = APIRouter"
    - path: "src/api/main.py"
      provides: "Registration of all 3 new PMS routers"
      contains: "pms_briefing_router"
  key_links:
    - from: "src/api/routes/pms_briefing.py"
      to: "src/pms/morning_pack.py"
      via: "MorningPackService singleton"
      pattern: "MorningPackService"
    - from: "src/api/routes/pms_risk.py"
      to: "src/pms/risk_monitor.py"
      via: "RiskMonitorService singleton"
      pattern: "RiskMonitorService"
    - from: "src/api/routes/pms_attribution.py"
      to: "src/pms/attribution.py"
      via: "PerformanceAttributionEngine singleton"
      pattern: "PerformanceAttributionEngine"
    - from: "src/api/main.py"
      to: "src/api/routes/pms_briefing.py"
      via: "router import and include_router"
      pattern: "pms_briefing_router"
---

<objective>
Wire the three Phase 22 services to FastAPI endpoints with Pydantic schemas, register all routers in main.py, update PMS package exports, and add API integration tests.

Purpose: Make MorningPackService, RiskMonitorService, and PerformanceAttributionEngine accessible via REST API for the frontend pages (Phases 23-26) and external consumers.

Output: 3 new route modules, updated schemas, updated main.py with 6 PMS routers total, and API integration tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-morning-pack-risk-monitor-attribution/22-01-SUMMARY.md
@.planning/phases/22-morning-pack-risk-monitor-attribution/22-02-SUMMARY.md
@src/api/main.py
@src/api/routes/pms_portfolio.py
@src/api/routes/pms_trades.py
@src/api/routes/pms_journal.py
@src/api/schemas/pms_schemas.py
@src/pms/__init__.py
@tests/test_pms/test_pms_api.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Three PMS API routers (Morning Pack, Risk Monitor, Attribution) with Pydantic schemas</name>
  <files>src/api/routes/pms_briefing.py, src/api/routes/pms_risk.py, src/api/routes/pms_attribution.py, src/api/schemas/pms_schemas.py</files>
  <action>
**Part A: Add Pydantic response schemas to `src/api/schemas/pms_schemas.py`**

Append the following schema classes (do NOT remove existing schemas):

```python
# =====================================================================
# MORNING PACK SCHEMAS
# =====================================================================

class ActionItemResponse(BaseModel):
    priority: str  # CRITICAL, HIGH, MEDIUM, LOW
    category: str
    description: str
    urgency: str

class MorningPackResponse(BaseModel):
    id: int
    briefing_date: date
    created_at: datetime
    action_items: Any  # list[ActionItemResponse] or unavailable marker
    trade_proposals: Any
    market_snapshot: Any
    agent_views: Any
    regime: Any
    top_signals: Any
    signal_changes: Any
    portfolio_state: Any
    macro_narrative: Any
    model_config = ConfigDict(from_attributes=True)

class MorningPackSummaryResponse(BaseModel):
    briefing_date: date
    action_items_count: int
    narrative_excerpt: Optional[str] = None

class GenerateMorningPackRequest(BaseModel):
    briefing_date: Optional[date] = None
    force: bool = False

# =====================================================================
# RISK MONITOR SCHEMAS
# =====================================================================

class VaRSnapshotResponse(BaseModel):
    parametric_95: float = 0.0
    parametric_99: float = 0.0
    monte_carlo_95: Optional[float] = None
    monte_carlo_99: Optional[float] = None
    limit_95_pct: float = 2.0
    limit_99_pct: float = 3.0
    utilization_95_pct: float = 0.0
    utilization_99_pct: float = 0.0

class RiskAlertResponse(BaseModel):
    type: str
    severity: str  # WARNING or BREACH
    message: str
    value: float
    limit: float

class LiveRiskResponse(BaseModel):
    as_of_date: date
    var: Any
    leverage: Any
    drawdown: Any
    concentration: Any
    stress_tests: list[Any] = Field(default_factory=list)
    limits_summary: Any
    alerts: list[RiskAlertResponse] = Field(default_factory=list)

class RiskTrendPointResponse(BaseModel):
    date: date
    var_95: float = 0.0
    leverage_gross: float = 0.0
    drawdown_pct: float = 0.0
    alert_count: int = 0

# =====================================================================
# ATTRIBUTION SCHEMAS
# =====================================================================

class AttributionByStrategyResponse(BaseModel):
    strategy_id: str
    pnl_brl: float
    return_contribution_pct: float
    trades_count: int = 0
    win_rate_pct: float = 0.0

class AttributionByAssetClassResponse(BaseModel):
    asset_class: str
    pnl_brl: float
    return_contribution_pct: float
    avg_notional_brl: float = 0.0

class AttributionResponse(BaseModel):
    period: dict
    total_pnl_brl: float
    total_return_pct: float
    by_strategy: list[Any] = Field(default_factory=list)
    by_asset_class: list[Any] = Field(default_factory=list)
    by_instrument: list[Any] = Field(default_factory=list)
    by_factor: list[Any] = Field(default_factory=list)
    by_time_period: list[Any] = Field(default_factory=list)
    by_trade_type: Any = Field(default_factory=dict)
    performance_stats: Any = Field(default_factory=dict)

class EquityCurvePointResponse(BaseModel):
    date: date
    equity_brl: float
    return_pct_daily: float = 0.0
    return_pct_cumulative: float = 0.0
    drawdown_pct: float = 0.0
```

**Part B: Create `src/api/routes/pms_briefing.py`**

Follow exact same pattern as pms_trades.py (lazy singleton, duplicate _get_* helpers):

```python
router = APIRouter(prefix="/pms/morning-pack", tags=["PMS - Morning Pack"])
```

Lazy singleton pattern:
```python
_service = None
def _get_service():
    global _service
    if _service is None:
        from src.pms.morning_pack import MorningPackService
        from src.pms import TradeWorkflowService, PositionManager
        pm = PositionManager()
        tw = TradeWorkflowService(position_manager=pm)
        _service = MorningPackService(position_manager=pm, trade_workflow=tw)
    return _service
```

Endpoints:
1. `GET /pms/morning-pack/latest` -> `MorningPackResponse` -- calls service.get_latest(). Returns 404 if no briefing exists.
2. `GET /pms/morning-pack/{briefing_date}` -> `MorningPackResponse` -- calls service.get_by_date(). Date param as str, parse to date. 404 if not found.
3. `POST /pms/morning-pack/generate` -> `MorningPackResponse` -- accepts GenerateMorningPackRequest body. Calls service.generate(). Returns the generated briefing.
4. `GET /pms/morning-pack/history` -> `list[MorningPackSummaryResponse]` -- query param `days: int = 30`. Calls service.get_history().

Use try/except with HTTPException(500) for unexpected errors, same pattern as pms_portfolio.py.

**Part C: Create `src/api/routes/pms_risk.py`**

```python
router = APIRouter(prefix="/pms/risk", tags=["PMS - Risk Monitor"])
```

Lazy singleton:
```python
_service = None
def _get_service():
    global _service
    if _service is None:
        from src.pms.risk_monitor import RiskMonitorService
        from src.pms import PositionManager
        _service = RiskMonitorService(position_manager=PositionManager())
    return _service
```

Endpoints:
1. `GET /pms/risk/live` -> `LiveRiskResponse` -- calls service.compute_live_risk(). Accepts optional `as_of_date` query param.
2. `GET /pms/risk/trend` -> `list[RiskTrendPointResponse]` -- query param `days: int = 30`. Calls service.get_risk_trend().
3. `GET /pms/risk/limits` -> dict -- returns current PMSRiskLimits as dict plus latest limits_summary from compute_live_risk.

**Part D: Create `src/api/routes/pms_attribution.py`**

```python
router = APIRouter(prefix="/pms/attribution", tags=["PMS - Attribution"])
```

Lazy singleton:
```python
_service = None
def _get_service():
    global _service
    if _service is None:
        from src.pms.attribution import PerformanceAttributionEngine
        from src.pms import PositionManager
        _service = PerformanceAttributionEngine(position_manager=PositionManager())
    return _service
```

Endpoints:
1. `GET /pms/attribution` -> `AttributionResponse` -- query params: `period: str = "MTD"`, `start_date: str | None`, `end_date: str | None`. If period is "custom", use start_date/end_date. Otherwise call compute_for_period().
2. `GET /pms/attribution/equity-curve` -> `list[EquityCurvePointResponse]` -- query params: start_date, end_date (default last 30 days).
3. `GET /pms/attribution/best-worst` -> dict -- query param `n: int = 10`. Return top N and bottom N positions by P&L from latest attribution.
  </action>
  <verify>cd /home/user/Macro_Trading && python -c "from src.api.routes.pms_briefing import router; print(f'Briefing router: {len(router.routes)} routes')" && python -c "from src.api.routes.pms_risk import router; print(f'Risk router: {len(router.routes)} routes')" && python -c "from src.api.routes.pms_attribution import router; print(f'Attribution router: {len(router.routes)} routes')"</verify>
  <done>Three PMS API routers created with 10 total endpoints. Pydantic schemas defined for all request/response models. Lazy singleton pattern consistent with existing PMS routers.</done>
</task>

<task type="auto">
  <name>Task 2: Register routers in main.py, update PMS package exports, and add API integration tests</name>
  <files>src/api/main.py, src/pms/__init__.py, tests/test_pms/test_pms_api.py</files>
  <action>
**Part A: Update `src/api/main.py`**

Add imports for the 3 new routers (insert after existing PMS router imports):
```python
from src.api.routes.pms_briefing import router as pms_briefing_router
from src.api.routes.pms_risk import router as pms_risk_router
from src.api.routes.pms_attribution import router as pms_attribution_router
```

Add 3 new OpenAPI tags to the `openapi_tags` list:
```python
{"name": "PMS - Morning Pack", "description": "Daily briefing generation and retrieval"},
{"name": "PMS - Risk Monitor", "description": "Real-time risk metrics, limits, and alerts"},
{"name": "PMS - Attribution", "description": "Multi-dimensional P&L attribution and performance analytics"},
```

Register the 3 routers under `/api/v1` prefix (add after existing PMS router registrations):
```python
app.include_router(pms_briefing_router, prefix="/api/v1")
app.include_router(pms_risk_router, prefix="/api/v1")
app.include_router(pms_attribution_router, prefix="/api/v1")
```

This brings total PMS routers to 6 (portfolio, trades, journal, briefing, risk, attribution).

**Part B: Update `src/pms/__init__.py`**

Add imports for the 3 new service classes:
```python
from src.pms.morning_pack import MorningPackService
from src.pms.attribution import PerformanceAttributionEngine
from src.pms.risk_monitor import RiskMonitorService
from src.pms.risk_limits_config import PMSRiskLimits
```

Update `__all__` to include all 7 exports:
```python
__all__ = [
    "PositionManager",
    "MarkToMarketService",
    "TradeWorkflowService",
    "MorningPackService",
    "PerformanceAttributionEngine",
    "RiskMonitorService",
    "PMSRiskLimits",
]
```

Update module docstring to include the new services.

**Part C: Add API integration tests to `tests/test_pms/test_pms_api.py`**

Append new test functions (do NOT remove existing tests). Use the same noop lifespan TestClient pattern established in the existing test file. Import the app and create a TestClient.

New tests:
- test_morning_pack_generate: POST /api/v1/pms/morning-pack/generate with empty body. Verify 200, response has all expected keys.
- test_morning_pack_latest: First POST generate, then GET /api/v1/pms/morning-pack/latest. Verify 200 and data matches.
- test_morning_pack_history: GET /api/v1/pms/morning-pack/history?days=30. Verify 200, returns list.
- test_risk_live: GET /api/v1/pms/risk/live. Verify 200, response has var, leverage, drawdown, concentration, alerts keys.
- test_risk_trend: GET /api/v1/pms/risk/trend?days=30. Verify 200, returns list.
- test_risk_limits: GET /api/v1/pms/risk/limits. Verify 200, returns limits configuration.
- test_attribution: GET /api/v1/pms/attribution?period=MTD. Verify 200, response has period, total_pnl_brl, by_strategy, by_asset_class keys.
- test_attribution_equity_curve: GET /api/v1/pms/attribution/equity-curve. Verify 200, returns list.

All tests should handle empty portfolios gracefully (the services should work with no positions).

Use existing test patterns from the file: httpx TestClient, no database dependency, verify status codes and response structure.
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_pms/test_pms_api.py -v -k "morning_pack or risk_live or risk_trend or risk_limits or attribution"</verify>
  <done>6 PMS routers registered in main.py (3 existing + 3 new). PMS package exports all 7 classes. 8 new API integration tests pass. OpenAPI docs show 6 PMS tag groups with 30+ total PMS endpoints.</done>
</task>

</tasks>

<verification>
```bash
cd /home/user/Macro_Trading
# Verify all routers load
python -c "from src.api.main import app; routes = [r.path for r in app.routes if hasattr(r, 'path')]; pms = [r for r in routes if '/pms/' in r]; print(f'PMS routes: {len(pms)}'); assert len(pms) >= 20"

# Verify PMS package exports
python -c "from src.pms import MorningPackService, RiskMonitorService, PerformanceAttributionEngine, PMSRiskLimits; print('All PMS services importable')"

# Run all Phase 22 tests
python -m pytest tests/test_pms/test_morning_pack.py tests/test_pms/test_risk_monitor.py tests/test_pms/test_attribution.py tests/test_pms/test_pms_api.py -v
```
</verification>

<success_criteria>
- GET /api/v1/pms/morning-pack/latest returns briefing data (after generate)
- POST /api/v1/pms/morning-pack/generate creates a new briefing and returns it
- GET /api/v1/pms/risk/live returns complete risk snapshot
- GET /api/v1/pms/risk/trend returns trend data
- GET /api/v1/pms/attribution returns P&L attribution for specified period
- All 3 routers registered in main.py with proper tags
- PMS __init__.py exports all 7 service classes
- All 8 new API tests pass
- Existing PMS API tests still pass (no regression)
</success_criteria>

<output>
After completion, create `.planning/phases/22-morning-pack-risk-monitor-attribution/22-03-SUMMARY.md`
</output>
