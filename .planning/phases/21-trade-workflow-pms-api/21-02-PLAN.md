---
phase: 21-trade-workflow-pms-api
plan: 02
type: execute
wave: 2
depends_on: ["21-01"]
files_modified:
  - src/api/schemas/__init__.py
  - src/api/schemas/pms_schemas.py
  - src/api/routes/pms_portfolio.py
  - src/api/routes/pms_trades.py
autonomous: true
requirements: [PMS-API-01, PMS-API-02, PMS-API-03, PMS-TW-02]

must_haves:
  truths:
    - "Pydantic request/response schemas are defined for all PMS API operations (open position, close position, approve/reject/modify proposal, record outcome)"
    - "PMS Portfolio router serves 10 endpoints: GET /book, GET /book/positions, POST /book/positions/open, POST /book/positions/{id}/close, POST /book/positions/{id}/update-price, POST /book/mtm, GET /pnl/summary, GET /pnl/equity-curve, GET /pnl/attribution, GET /pnl/monthly-heatmap"
    - "PMS Trades router serves 6 endpoints: GET /proposals, GET /proposals/{id}, POST /proposals/{id}/approve, POST /proposals/{id}/reject, POST /proposals/{id}/modify-approve, POST /proposals/generate"
    - "All endpoints return Pydantic-validated responses with proper HTTP status codes and error handling"
  artifacts:
    - path: "src/api/schemas/pms_schemas.py"
      provides: "All Pydantic request/response models for PMS"
      contains: "class OpenPositionRequest"
    - path: "src/api/schemas/__init__.py"
      provides: "Schemas package init"
    - path: "src/api/routes/pms_portfolio.py"
      provides: "10 portfolio endpoints"
      contains: "router = APIRouter"
    - path: "src/api/routes/pms_trades.py"
      provides: "6 trade blotter endpoints"
      contains: "router = APIRouter"
  key_links:
    - from: "src/api/routes/pms_portfolio.py"
      to: "src/pms/trade_workflow.py"
      via: "Module-level TradeWorkflowService singleton for API usage"
      pattern: "TradeWorkflowService"
    - from: "src/api/routes/pms_trades.py"
      to: "src/pms/trade_workflow.py"
      via: "TradeWorkflowService for proposal operations"
      pattern: "TradeWorkflowService"
    - from: "src/api/routes/pms_portfolio.py"
      to: "src/api/schemas/pms_schemas.py"
      via: "Pydantic models for request validation and response serialization"
      pattern: "from src.api.schemas.pms_schemas import"
---

<objective>
Create Pydantic schemas for all PMS operations and implement two of the three PMS API routers: pms_portfolio (10 endpoints for book, positions, P&L) and pms_trades (6 endpoints for trade proposals and approval workflow).

Purpose: Expose the TradeWorkflowService and PositionManager operations via REST API, enabling the frontend (Phases 23-26) and external tools to interact with the PMS through well-typed endpoints with Swagger documentation.

Output: src/api/schemas/pms_schemas.py (12+ Pydantic models), src/api/routes/pms_portfolio.py (10 endpoints), src/api/routes/pms_trades.py (6 endpoints)
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/21-trade-workflow-pms-api/21-01-PLAN.md
@src/pms/position_manager.py
@src/pms/trade_workflow.py
@src/api/routes/portfolio_api.py
@src/api/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas and PMS Portfolio + Trades API routers</name>
  <files>src/api/schemas/__init__.py, src/api/schemas/pms_schemas.py, src/api/routes/pms_portfolio.py, src/api/routes/pms_trades.py</files>
  <action>
**Step 1: Create src/api/schemas/__init__.py**

Empty init file to make schemas a package:
```python
"""Pydantic request/response schemas for the Macro Trading API."""
```

**Step 2: Create src/api/schemas/pms_schemas.py**

All Pydantic v2 models (use `from pydantic import BaseModel, Field`):

Request models:
- `OpenPositionRequest`: instrument (str), asset_class (str), direction (str, "LONG"/"SHORT"), notional_brl (float, gt=0), execution_price (float, gt=0), entry_date (date, optional default today), manager_thesis (str, min_length=5), target_price (float, optional), stop_loss (float, optional), time_horizon (str, optional), strategy_ids (list[str], optional default [])
- `ClosePositionRequest`: close_price (float, gt=0), close_date (date, optional), manager_notes (str, optional), outcome_notes (str, optional)
- `UpdatePriceRequest`: price (float, gt=0)
- `MTMRequest`: price_overrides (dict[str, float], optional default {}), fx_rate (float, optional default 5.0)
- `ApproveProposalRequest`: execution_price (float, gt=0), execution_notional_brl (float, gt=0), manager_notes (str, optional), manager_thesis (str, optional), target_price (float, optional), stop_loss (float, optional), time_horizon (str, optional)
- `RejectProposalRequest`: manager_notes (str, min_length=3)
- `ModifyApproveRequest`: modified_direction (str, optional), modified_notional_brl (float, optional, gt=0), execution_price (float, optional, gt=0), manager_notes (str, optional)
- `GenerateProposalsRequest`: signals (list[dict], optional), as_of_date (date, optional)
- `OutcomeRequest`: outcome_notes (str, min_length=5), realized_pnl_assessment (str, optional, e.g. "GOOD"/"BAD"/"NEUTRAL")

Response models:
- `PositionResponse(BaseModel)`: model_config with from_attributes=True. Fields matching PositionManager position dict keys: id, instrument, asset_class, direction, notional_brl, entry_price, entry_date, current_price, unrealized_pnl_brl, realized_pnl_brl, is_open, etc. All optional fields use Optional[...] with default None.
- `BookSummaryResponse`: aum, total_notional_brl, leverage, open_positions (int), pnl_today_brl, pnl_mtd_brl, pnl_ytd_brl, total_unrealized_pnl_brl, total_realized_pnl_brl
- `BookResponse`: summary (BookSummaryResponse), positions (list[PositionResponse]), by_asset_class (dict[str, dict]), closed_today (list[PositionResponse])
- `TradeProposalResponse`: id, instrument, asset_class, direction, suggested_notional_brl, conviction, signal_source, strategy_ids, rationale, risk_impact, status, execution_price, execution_notional_brl, position_id, notes, created_at, reviewed_at
- `JournalEntryResponse`: id, created_at, entry_type, position_id, proposal_id, instrument, direction, notional_brl, manager_notes, system_notes, content_hash, is_locked
- `PnLPointResponse`: snapshot_date (date), daily_pnl_brl (float), cumulative_pnl_brl (float)
- `APIEnvelope(BaseModel, Generic[T])`: status (str, default "ok"), data (T), meta (dict). Use TypeVar T for generic wrapping.

NOTE: Use `model_config = ConfigDict(from_attributes=True)` on response models for ORM compatibility.

**Step 3: Create src/api/routes/pms_portfolio.py**

Router with prefix="/pms", tags=["PMS - Portfolio"]:

Use a module-level lazy initialization pattern for TradeWorkflowService:
```python
_workflow: TradeWorkflowService | None = None

def _get_workflow() -> TradeWorkflowService:
    global _workflow
    if _workflow is None:
        from src.pms import TradeWorkflowService
        _workflow = TradeWorkflowService()
    return _workflow
```

Endpoints (all sync, wrapped with asyncio.to_thread where needed):

1. **GET /book** -> BookResponse
   - Call `_get_workflow().position_manager.get_book()`
   - Return structured book response

2. **GET /book/positions** -> list[PositionResponse]
   - Query params: asset_class (optional), is_open (optional bool, default True)
   - Filter position_manager._positions by criteria
   - Return filtered list

3. **POST /book/positions/open** (body: OpenPositionRequest) -> PositionResponse
   - Call `_get_workflow().open_discretionary_trade(...)` with request fields
   - Return the created position from the result

4. **POST /book/positions/{position_id}/close** (body: ClosePositionRequest) -> PositionResponse
   - Call `_get_workflow().close_position(position_id, ...)`
   - Return closed position
   - HTTPException 404 if not found, 400 if already closed

5. **POST /book/positions/{position_id}/update-price** (body: UpdatePriceRequest) -> PositionResponse
   - Find position in position_manager._positions
   - Update current_price manually
   - HTTPException 404 if not found

6. **POST /book/mtm** (body: MTMRequest) -> dict
   - Call `_get_workflow().position_manager.mark_to_market(price_overrides, fx_rate)`
   - Return count of updated positions and summary

7. **GET /pnl/summary** -> dict
   - Call `_get_workflow().position_manager.get_book()`
   - Return only the summary portion

8. **GET /pnl/equity-curve** -> list[PnLPointResponse]
   - Query params: start_date (optional), end_date (optional)
   - Call `_get_workflow().position_manager.get_pnl_timeseries(start_date=..., end_date=...)`
   - Return timeseries list

9. **GET /pnl/attribution** -> dict
   - Compute P&L grouped by strategy_ids and asset_class from open+closed positions
   - Return {"by_strategy": {...}, "by_asset_class": {...}, "by_instrument": {...}}

10. **GET /pnl/monthly-heatmap** -> dict
    - Aggregate daily P&L from pnl_history by year-month
    - Return {"months": [{"year": 2026, "month": 1, "pnl_brl": ...}, ...]}

All endpoints wrap errors in try/except returning HTTPException with appropriate status codes.

**Step 4: Create src/api/routes/pms_trades.py**

Router with prefix="/pms/trades", tags=["PMS - Trade Blotter"]:

Use same `_get_workflow()` lazy pattern (import from pms_portfolio or duplicate).

Endpoints:

1. **GET /proposals** -> list[TradeProposalResponse]
   - Query params: status (optional, filter by PENDING/APPROVED/REJECTED/MODIFIED), date (optional)
   - Return filtered proposals from _get_workflow()._proposals

2. **GET /proposals/{proposal_id}** -> TradeProposalResponse
   - Find proposal by id
   - HTTPException 404 if not found

3. **POST /proposals/{proposal_id}/approve** (body: ApproveProposalRequest) -> TradeProposalResponse
   - Call `_get_workflow().approve_proposal(proposal_id, ...)`
   - HTTPException 400 on ValueError (not found, not pending)

4. **POST /proposals/{proposal_id}/reject** (body: RejectProposalRequest) -> TradeProposalResponse
   - Call `_get_workflow().reject_proposal(proposal_id, request.manager_notes)`
   - HTTPException 400 on ValueError

5. **POST /proposals/{proposal_id}/modify-approve** (body: ModifyApproveRequest) -> TradeProposalResponse
   - Call `_get_workflow().modify_and_approve_proposal(proposal_id, ...)`
   - HTTPException 400 on ValueError

6. **POST /proposals/generate** (body: GenerateProposalsRequest) -> list[TradeProposalResponse]
   - If request.signals provided, call `_get_workflow().generate_proposals_from_signals(signals, as_of_date)`
   - If no signals, return empty list with message (sample signals can be generated in demo mode)
   - Return created proposals

All endpoints use proper Pydantic response_model annotations for Swagger.
  </action>
  <verify>cd /home/user/Macro_Trading && python -c "
from src.api.schemas.pms_schemas import (
    OpenPositionRequest, ClosePositionRequest, UpdatePriceRequest, MTMRequest,
    ApproveProposalRequest, RejectProposalRequest, ModifyApproveRequest,
    GenerateProposalsRequest, OutcomeRequest,
    PositionResponse, BookResponse, TradeProposalResponse, JournalEntryResponse,
)
print('All schemas imported OK')
from src.api.routes.pms_portfolio import router as portfolio_router
from src.api.routes.pms_trades import router as trades_router
print(f'Portfolio routes: {len(portfolio_router.routes)}')
print(f'Trades routes: {len(trades_router.routes)}')
print('All routers imported OK')
"</verify>
  <done>
    - src/api/schemas/pms_schemas.py has 12+ Pydantic models covering all PMS request/response types
    - src/api/routes/pms_portfolio.py has 10 endpoints with proper tags and response models
    - src/api/routes/pms_trades.py has 6 endpoints with proper tags and response models
    - All endpoints use TradeWorkflowService via lazy singleton pattern
    - Error handling returns proper HTTP status codes (400, 404)
    - Pydantic validation works for all request bodies
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.api.schemas.pms_schemas import *"` -- all schema imports work
2. `python -c "from src.api.routes.pms_portfolio import router; print(len(router.routes))"` -- 10 routes
3. `python -c "from src.api.routes.pms_trades import router; print(len(router.routes))"` -- 6 routes
4. Schema validation test: `python -c "from src.api.schemas.pms_schemas import RejectProposalRequest; RejectProposalRequest(manager_notes='Too risky')"` -- works
5. Schema validation test: `python -c "from src.api.schemas.pms_schemas import RejectProposalRequest; RejectProposalRequest(manager_notes='ab')"` -- fails (min_length=3)
</verification>

<success_criteria>
- 12+ Pydantic schemas defined with proper validation (min_length, gt=0, optional defaults)
- 16 API endpoints across 2 routers with correct prefixes and tags
- All endpoints use TradeWorkflowService and PositionManager without DB dependency
- Swagger docs would show PMS - Portfolio and PMS - Trade Blotter tag groups
</success_criteria>

<output>
After completion, create `.planning/phases/21-trade-workflow-pms-api/21-02-SUMMARY.md`
</output>
