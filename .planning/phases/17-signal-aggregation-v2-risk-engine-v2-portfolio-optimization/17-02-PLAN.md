---
phase: 17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/risk/var_calculator.py
  - src/risk/stress_tester.py
  - tests/test_var_calculator_v2.py
  - tests/test_stress_tester_v2.py
autonomous: true
requirements:
  - RSKV-01
  - RSKV-02
  - RSKV-03
  - RSKV-04
  - RSKV-05
  - RSKV-06

must_haves:
  truths:
    - "Monte Carlo VaR uses t-Student marginals and Gaussian copula with Cholesky decomposition at 10,000 simulations over 756-day lookback"
    - "Parametric VaR uses Ledoit-Wolf shrinkage covariance for robust estimation"
    - "Marginal VaR shows per-position risk contribution; Component VaR decomposes total VaR by position"
    - "Both VaR and CVaR reported at 95% and 99% confidence levels"
    - "6+ stress scenarios include existing 4 plus BR Fiscal Crisis (2015 calibration) and Global Risk-Off (2020 COVID calibration)"
    - "Reverse stress testing finds scenarios producing a configurable max loss (default -10%)"
    - "Historical replay stress test replays actual returns from a specified crisis period"
  artifacts:
    - path: "src/risk/var_calculator.py"
      provides: "Enhanced VaR with Monte Carlo copula, parametric Ledoit-Wolf, marginal/component decomposition"
      min_lines: 300
    - path: "src/risk/stress_tester.py"
      provides: "Expanded stress scenarios, reverse stress testing, historical replay"
      min_lines: 250
    - path: "tests/test_var_calculator_v2.py"
      provides: "Tests for Monte Carlo, parametric, marginal, component VaR"
      min_lines: 100
    - path: "tests/test_stress_tester_v2.py"
      provides: "Tests for new scenarios, reverse stress, historical replay"
      min_lines: 80
  key_links:
    - from: "src/risk/var_calculator.py"
      to: "scipy.stats.t"
      via: "t-Student marginal fitting for Monte Carlo"
      pattern: "stats\\.t\\.fit|t_params"
    - from: "src/risk/var_calculator.py"
      to: "sklearn.covariance.LedoitWolf"
      via: "Shrinkage covariance estimation"
      pattern: "LedoitWolf"
    - from: "src/risk/stress_tester.py"
      to: "src/risk/var_calculator.py"
      via: "VaR results for reverse stress testing threshold"
      pattern: "VaRResult|var_calculator"
---

<objective>
Enhance the risk engine with Monte Carlo VaR using Gaussian copula (756-day lookback), parametric VaR with Ledoit-Wolf shrinkage, marginal and component VaR decomposition, two new stress scenarios calibrated to historical magnitudes, reverse stress testing, and historical replay.

Purpose: The existing VaR calculator (Phase 12) already has Monte Carlo with t-Student marginals and Cholesky decomposition. This plan enhances it with the 756-day lookback, marginal/component VaR decomposition, and always-report-both-VaR-and-CVaR pattern. The stress tester gains two new scenarios, reverse stress testing, and historical replay -- critical for understanding tail risk.

Output: Enhanced var_calculator.py and stress_tester.py with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/risk/var_calculator.py
@src/risk/stress_tester.py
@src/risk/risk_monitor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhanced VaR calculator with 756-day lookback, marginal VaR, and component VaR decomposition</name>
  <files>src/risk/var_calculator.py, tests/test_var_calculator_v2.py</files>
  <action>
Enhance the existing `src/risk/var_calculator.py` by adding marginal VaR and component VaR decomposition functions, updating the default lookback to 756 days (3 years per user decision), and ensuring both VaR and CVaR are always reported.

**Key changes to existing code:**

1. Update `VaRCalculator.__init__` default: `min_historical_obs: int = 756` (was 252). This is the 3-year lookback per user decision.

2. Keep existing `compute_historical_var`, `compute_parametric_var`, `compute_monte_carlo_var` functions unchanged (they already work correctly). The Monte Carlo already uses t-Student marginals, Gaussian copula via Ledoit-Wolf correlation, and Cholesky decomposition.

3. Update `VaRCalculator.__init__` to accept `lookback_days: int = 756` and store it. The `calculate_monte_carlo` method should trim `returns_matrix` to the last `lookback_days` rows before fitting.

**New function: `compute_marginal_var`:**
```python
def compute_marginal_var(
    returns_matrix: np.ndarray,
    weights: np.ndarray,
    confidence: float = 0.95,
    method: str = "parametric",
) -> dict[int, float]:
```
- Marginal VaR = change in portfolio VaR from a small increase in position weight.
- For parametric: MarginalVaR_i = (Sigma @ w)_i / sqrt(w^T @ Sigma @ w) * z_alpha * portfolio_value_factor
- Simpler approach: for each position i, compute portfolio VaR with weight[i] += epsilon and weight[i] -= epsilon, MarginalVaR_i = (VaR_plus - VaR_minus) / (2 * epsilon). Use epsilon = 0.001.
- Use Ledoit-Wolf covariance for Sigma. Returns dict mapping position index -> marginal VaR contribution.

**New function: `compute_component_var`:**
```python
def compute_component_var(
    returns_matrix: np.ndarray,
    weights: np.ndarray,
    confidence: float = 0.95,
) -> dict[int, float]:
```
- Component VaR = weight_i * MarginalVaR_i. Sum of all component VaRs = total VaR.
- Use the analytical Ledoit-Wolf covariance: ComponentVaR_i = w_i * (Sigma @ w)_i / sqrt(w^T @ Sigma @ w) * z_alpha
- Returns dict mapping position index -> component VaR.
- Verify: sum(component_var.values()) should approximately equal total parametric VaR.

**New dataclass: `VaRDecomposition`:**
```python
@dataclass
class VaRDecomposition:
    total_var: float
    total_cvar: float
    confidence: float
    marginal_var: dict[str, float]   # instrument_name -> marginal VaR
    component_var: dict[str, float]  # instrument_name -> component VaR
    pct_contribution: dict[str, float]  # instrument_name -> % of total VaR
```

**New method on VaRCalculator: `decompose_var`:**
```python
def decompose_var(
    self,
    returns_matrix: np.ndarray,
    weights: np.ndarray,
    instrument_names: list[str],
    confidence: float = 0.95,
) -> VaRDecomposition:
```
- Calls compute_marginal_var and compute_component_var, maps position indices to instrument_names, computes pct_contribution = component_var_i / total_var.

**Tests (tests/test_var_calculator_v2.py):**
- Test compute_marginal_var: marginal VaR for a position with higher volatility is larger
- Test compute_component_var: sum of component VaRs approximately equals total VaR (within 1% tolerance)
- Test VaRDecomposition returns correct instrument names and non-zero values
- Test decompose_var with 3 synthetic assets shows largest risk contributor correctly
- Test 756-day lookback default is applied when returns_matrix has >756 rows (only last 756 used)
- Test VaR and CVaR are both reported (CVaR should be more negative than VaR for non-degenerate distributions)
- Test parametric VaR with Ledoit-Wolf produces reasonable values for correlated assets
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_var_calculator_v2.py -v</verify>
  <done>VaR calculator enhanced with marginal/component VaR decomposition, 756-day lookback, both VaR and CVaR always reported at 95% and 99%; component VaR sums to total VaR</done>
</task>

<task type="auto">
  <name>Task 2: Expanded stress scenarios, reverse stress testing, and historical replay</name>
  <files>src/risk/stress_tester.py, tests/test_stress_tester_v2.py</files>
  <action>
Enhance the existing `src/risk/stress_tester.py` with two new stress scenarios, reverse stress testing, and historical replay capability.

**New stress scenarios (added to DEFAULT_SCENARIOS):**

Per user decision: calibrated to historical replay severity.

```python
StressScenario(
    name="BR Fiscal Crisis (Teto de Gastos)",
    description=(
        "Fiscal ceiling crisis with spending cap breach fears. BRL weakened, "
        "DI rates surged, NTN-B sold off, sovereign risk repriced. "
        "Calibrated to 2015 crisis magnitude."
    ),
    shocks={
        "USDBRL": 0.25,       # BRL depreciation (2015 magnitude)
        "DI_PRE": 0.035,      # DI rate increase
        "NTN_B_REAL": -0.10,  # NTN-B price decline
        "IBOVESPA": -0.18,    # Equity sell-off
        "CDS_BR": 0.40,       # Sovereign CDS widening
    },
    historical_period="Sep 2015 - Mar 2016",
),
StressScenario(
    name="Global Risk-Off (Geopolitical)",
    description=(
        "Global risk-off event with flight to quality. EM currencies weakened, "
        "equities dropped, oil declined, USD strengthened, UST rallied. "
        "Calibrated to 2020 COVID shock magnitude."
    ),
    shocks={
        "USDBRL": 0.20,       # BRL weakened (COVID 2020 magnitude)
        "DI_PRE": 0.015,      # Modest rate increase
        "IBOVESPA": -0.30,    # Equity crash
        "SP500": -0.25,       # US equity decline
        "OIL": -0.40,         # Oil crash
        "UST_NOM": -0.005,    # UST rally (safe haven, rates fall)
        "CDS_BR": 0.30,       # Sovereign spread widening
    },
    historical_period="Feb 2020 - Mar 2020",
),
```

**New method: `reverse_stress_test`:**
```python
def reverse_stress_test(
    self,
    positions: dict[str, float],
    portfolio_value: float,
    max_loss_pct: float = -0.10,  # default -10% per user decision
    step_size: float = 0.01,
    max_iterations: int = 100,
) -> dict:
```
- Goal: find shock multipliers that produce exactly max_loss_pct portfolio loss.
- Algorithm: Start with each scenario's shocks at 1.0x multiplier. Binary search the multiplier (between 0.01 and 5.0) such that portfolio_pnl / portfolio_value approximately equals max_loss_pct.
- For each scenario, find the multiplier_k such that sum(position_i * shock_i * multiplier_k) / portfolio_value = max_loss_pct.
- Return dict with: {"scenario_name": {"multiplier": float, "required_shocks": dict[str, float], "resulting_loss_pct": float, "feasible": bool}}.
- If a scenario cannot produce the target loss even at 5.0x multiplier (e.g., positions not exposed to that scenario's instruments), mark feasible=False.

**New method: `historical_replay`:**
```python
def historical_replay(
    self,
    positions: dict[str, float],
    historical_returns: dict[str, np.ndarray],
    portfolio_value: float,
    period_name: str = "Custom Period",
) -> StressResult:
```
- Takes actual historical daily returns for each instrument (as dict[instrument, 1D-array]).
- Computes cumulative P&L by applying the returns to notional positions day by day.
- Returns a StressResult where portfolio_pnl is the worst cumulative drawdown P&L during the period, and position_pnl shows per-instrument cumulative contribution at the worst point.
- This replays actual returns rather than using predefined shocks per user decision.

**New convenience method: `run_all_v2`:**
```python
def run_all_v2(
    self,
    positions: dict[str, float],
    portfolio_value: float,
    include_reverse: bool = True,
    max_loss_pct: float = -0.10,
) -> dict:
```
- Returns {"scenarios": list[StressResult], "reverse": dict | None, "worst_case": StressResult}.
- Calls run_all() for scenarios, optionally calls reverse_stress_test(), and identifies worst_case.

**Tests (tests/test_stress_tester_v2.py):**
- Test DEFAULT_SCENARIOS now has 6 scenarios (4 original + 2 new)
- Test BR Fiscal Crisis scenario applies correct shocks to DI_PRE and USDBRL positions
- Test Global Risk-Off scenario applies correct shocks to IBOVESPA and SP500 positions
- Test reverse_stress_test finds multiplier that produces ~10% loss for a simple portfolio
- Test reverse_stress_test returns feasible=False when positions have no exposure to scenario instruments
- Test historical_replay computes correct cumulative P&L from daily returns
- Test historical_replay identifies worst drawdown point
- Test run_all_v2 returns all 6 scenario results plus reverse stress results
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_stress_tester_v2.py -v</verify>
  <done>StressTester has 6 scenarios (including BR Fiscal Crisis and Global Risk-Off calibrated to historical magnitudes), reverse stress testing finds scenarios for -10% loss, historical replay computes daily P&L from actual returns</done>
</task>

</tasks>

<verification>
```bash
cd /home/user/Macro_Trading && python -m pytest tests/test_var_calculator_v2.py tests/test_stress_tester_v2.py -v --tb=short
```

Additional checks:
- `python -c "from src.risk.var_calculator import VaRCalculator, VaRDecomposition; print('VaR OK')"` — enhanced module imports cleanly
- `python -c "from src.risk.stress_tester import DEFAULT_SCENARIOS; assert len(DEFAULT_SCENARIOS) >= 6; print(f'Scenarios: {len(DEFAULT_SCENARIOS)}')"` — 6+ scenarios exist
- Verify existing VaRResult and StressResult dataclasses are preserved (backward compat with risk_monitor.py)
</verification>

<success_criteria>
- Monte Carlo VaR uses t-Student marginals, Gaussian copula, Cholesky decomposition with 756-day lookback
- Both VaR and CVaR reported at 95% and 99% confidence levels
- Marginal VaR shows per-position risk contribution
- Component VaR decomposes total VaR and sums approximately to total
- 6+ stress scenarios including BR Fiscal Crisis and Global Risk-Off (calibrated to 2015 and 2020 historical magnitudes)
- Reverse stress testing finds shock multipliers producing a configurable max loss (default -10%)
- Historical replay computes daily P&L from actual crisis-period returns
- All tests pass
- Existing VaRResult and StressResult dataclasses unchanged (backward compatibility with risk_monitor.py)
</success_criteria>

<output>
After completion, create `.planning/phases/17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization/17-02-SUMMARY.md`
</output>
