---
phase: 17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization
plan: 04
type: execute
wave: 2
depends_on:
  - 17-01
  - 17-02
files_modified:
  - src/portfolio/black_litterman.py
  - src/portfolio/position_sizer.py
  - src/portfolio/portfolio_optimizer.py
  - src/core/models/portfolio_state.py
  - alembic/versions/008_create_portfolio_state_table.py
  - src/api/routes/portfolio_api.py
  - tests/test_black_litterman.py
  - tests/test_position_sizer.py
  - tests/test_portfolio_api_v2.py
autonomous: true
requirements:
  - POPT-01
  - POPT-02
  - POPT-03
  - POPT-04
  - POPT-05

must_haves:
  truths:
    - "Black-Litterman model combines market equilibrium returns with agent views via P/Q matrices"
    - "View confidence is regime-adjusted: agent confidence * regime clarity (HMM probability)"
    - "Mean-variance optimization uses scipy.minimize with configurable constraints"
    - "PositionSizer offers 3 methods: vol_target, fractional_kelly (half Kelly 0.5x), risk_budget_size"
    - "portfolio_state table persists positions with strategy attribution JSON via Alembic migration 008"
    - "GET /portfolio/current, /portfolio/target, /portfolio/rebalance-trades, /portfolio/attribution return valid JSON"
    - "Rebalancing triggers daily at close but only executes when signal change exceeds threshold or drift > threshold"
  artifacts:
    - path: "src/portfolio/black_litterman.py"
      provides: "Black-Litterman model with regime-adjusted view confidence and P/Q matrices"
      min_lines: 150
    - path: "src/portfolio/position_sizer.py"
      provides: "PositionSizer with vol_target, fractional_kelly, risk_budget_size methods"
      min_lines: 100
    - path: "src/portfolio/portfolio_optimizer.py"
      provides: "Mean-variance optimizer with configurable constraints"
      min_lines: 100
    - path: "src/core/models/portfolio_state.py"
      provides: "PortfolioStateRecord ORM model"
      min_lines: 30
    - path: "alembic/versions/008_create_portfolio_state_table.py"
      provides: "Alembic migration for portfolio_state table"
      min_lines: 30
    - path: "src/api/routes/portfolio_api.py"
      provides: "Enhanced portfolio API with /target, /rebalance-trades, /attribution endpoints"
      min_lines: 150
    - path: "tests/test_black_litterman.py"
      provides: "Tests for Black-Litterman equilibrium, views, and regime adjustment"
      min_lines: 80
    - path: "tests/test_position_sizer.py"
      provides: "Tests for vol_target, kelly, risk_budget sizing"
      min_lines: 60
    - path: "tests/test_portfolio_api_v2.py"
      provides: "Tests for portfolio API endpoints"
      min_lines: 50
  key_links:
    - from: "src/portfolio/black_litterman.py"
      to: "src/agents/cross_asset_view.py"
      via: "CrossAssetView for agent views and regime clarity"
      pattern: "CrossAssetView|regime_prob|AssetClassView"
    - from: "src/portfolio/position_sizer.py"
      to: "src/risk/var_calculator.py"
      via: "VaR-based risk budget sizing"
      pattern: "VaRCalculator|component_var"
    - from: "src/portfolio/portfolio_optimizer.py"
      to: "src/portfolio/black_litterman.py"
      via: "BL posterior returns as optimization inputs"
      pattern: "black_litterman|posterior"
    - from: "src/api/routes/portfolio_api.py"
      to: "src/portfolio/portfolio_optimizer.py"
      via: "Optimizer for /target and /rebalance-trades"
      pattern: "PortfolioOptimizer|optimize"
---

<objective>
Build the Black-Litterman portfolio optimization model with regime-adjusted view confidence, mean-variance optimization with configurable constraints, PositionSizer with three sizing methods, portfolio_state table with Alembic migration, and expanded portfolio API endpoints.

Purpose: The existing PortfolioConstructor (Phase 12) uses risk parity + conviction overlay + regime scaling. This plan adds the proper academic portfolio optimization framework: Black-Litterman to blend market equilibrium with agent views, mean-variance optimization for weight computation, and Kelly-based position sizing -- the final layer that converts signals into actual portfolio targets.

Output: Three new portfolio modules, ORM model with migration, and 4 API endpoints.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/portfolio/portfolio_constructor.py
@src/portfolio/capital_allocator.py
@src/agents/cross_asset_view.py
@src/risk/var_calculator.py
@src/api/routes/portfolio_api.py
@src/core/models/strategy_state.py
@.planning/phases/17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization/17-01-SUMMARY.md
@.planning/phases/17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization/17-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Black-Litterman model, mean-variance optimizer, and PositionSizer</name>
  <files>src/portfolio/black_litterman.py, src/portfolio/portfolio_optimizer.py, src/portfolio/position_sizer.py, tests/test_black_litterman.py, tests/test_position_sizer.py</files>
  <action>
Create three new modules implementing the portfolio optimization layer.

**src/portfolio/black_litterman.py — Black-Litterman Model:**

`BlackLittermanConfig` frozen dataclass:
- risk_aversion: float = 2.5 — market risk aversion parameter (delta)
- tau: float = 0.05 — scaling factor for uncertainty in equilibrium
- default_view_confidence: float = 0.5 — when no regime info available

`AgentView` dataclass:
- instrument: str — target instrument
- expected_return: float — agent's view on expected return
- confidence: float — [0, 1] agent's raw confidence
- source: str — agent/strategy that generated the view

`BlackLitterman` class:
- `__init__(self, config: BlackLittermanConfig | None = None)`
- `compute_equilibrium_returns(self, covariance: np.ndarray, market_weights: np.ndarray) -> np.ndarray` — Equilibrium excess returns: pi = delta * Sigma * w_mkt. The implied returns from market capitalization weights.
- `build_views(self, views: list[AgentView], instrument_names: list[str], regime_clarity: float = 1.0) -> tuple[np.ndarray, np.ndarray, np.ndarray]` — Builds P (pick matrix), Q (view returns), and Omega (view uncertainty diagonal). Per user decision: "View confidence is regime-adjusted — agent confidence * regime clarity. High HMM probability + confident agent = tight view distribution. Uncertain regime discounts even confident agents." Omega_ii = 1 / (confidence * regime_clarity + epsilon) * tau * (p_i @ Sigma @ p_i). Returns (P, Q, Omega).
- `posterior_returns(self, equilibrium: np.ndarray, covariance: np.ndarray, P: np.ndarray, Q: np.ndarray, Omega: np.ndarray) -> tuple[np.ndarray, np.ndarray]` — Posterior expected returns and covariance using BL formula: mu_BL = inv(inv(tau*Sigma) + P^T Omega^-1 P) @ (inv(tau*Sigma) @ pi + P^T Omega^-1 Q). Returns (posterior_mu, posterior_sigma).
- `optimize(self, views: list[AgentView], covariance: np.ndarray, market_weights: np.ndarray, instrument_names: list[str], regime_clarity: float = 1.0) -> dict` — Full pipeline: equilibrium -> build_views -> posterior -> return {"posterior_returns": dict, "posterior_covariance": np.ndarray, "equilibrium_returns": dict, "regime_clarity": float}.

**src/portfolio/portfolio_optimizer.py — Mean-Variance Optimization:**

`OptimizationConstraints` frozen dataclass:
- min_weight: float = -0.25 — allow short positions (per existing convention)
- max_weight: float = 0.25 — max single position (per RiskLimitsConfig)
- max_leverage: float = 3.0 — sum of abs weights
- target_return: float | None = None — optional return target
- long_only: bool = False — if True, override min_weight to 0.0

`PortfolioOptimizer` class:
- `__init__(self, constraints: OptimizationConstraints | None = None)`
- `optimize(self, expected_returns: np.ndarray, covariance: np.ndarray, instrument_names: list[str]) -> dict[str, float]` — scipy.minimize with SLSQP. Objective: minimize 0.5 * w^T Sigma w - lambda * mu^T w (mean-variance utility). Constraints: weights sum constraint depends on leverage setting, individual weight bounds from constraints. Returns dict of instrument_name -> optimal weight.
- `optimize_with_bl(self, bl_result: dict, instrument_names: list[str]) -> dict[str, float]` — convenience wrapper using Black-Litterman posterior returns and covariance.

**Rebalancing logic (per user decision):**
- "Daily check + signal-driven threshold — run optimization daily at close, but only execute trades if aggregate signal change exceeds threshold OR position drift > X% from target."
- Add `should_rebalance(self, current_weights: dict[str, float], target_weights: dict[str, float], signal_change: float, signal_threshold: float = 0.15, drift_threshold: float = 0.05) -> bool` method on PortfolioOptimizer. Returns True if abs(signal_change) > signal_threshold OR max position drift > drift_threshold.

**src/portfolio/position_sizer.py — Position Sizing:**

`PositionSizer` class:
- `__init__(self, target_vol: float = 0.10, kelly_fraction: float = 0.5, max_position: float = 0.25)`
- `vol_target_size(self, instrument_vol: float) -> float` — size = target_vol / instrument_vol. Clamped to [0, max_position]. Per requirement: "target_vol/instrument_vol".
- `fractional_kelly_size(self, expected_return: float, return_variance: float) -> float` — full Kelly: f* = expected_return / return_variance. Apply fraction: size = kelly_fraction * f*. Clamped to [-max_position, max_position]. Per user decision: "half Kelly (0.5x) as the fixed fraction".
- `risk_budget_size(self, total_risk_budget: float, component_var: float, total_var: float) -> float` — size = total_risk_budget * (component_var / total_var) if total_var > 0 else 0. Clamped to [-max_position, max_position].
- `size_portfolio(self, positions: dict[str, dict], method: str = "vol_target") -> dict[str, float]` — applies chosen sizing method to each position. positions is dict of instrument -> {volatility, expected_return, variance, component_var, total_var}. Returns instrument -> sized weight.

**Position limits (per user decision):** "Soft limits with risk override — limits trigger warnings but can be exceeded by a fixed margin (e.g., 20%) when conviction is very high."
- In PositionSizer, if conviction > 0.8 (very high), allow max_position * 1.2 (20% override margin). Log a warning when override is used.

**Tests:**

tests/test_black_litterman.py:
- Test equilibrium returns are proportional to market weights for diagonal covariance
- Test posterior returns shift toward views when view confidence is high
- Test posterior returns stay near equilibrium when view confidence is low (uncertain regime)
- Test regime_clarity=0.2 (uncertain) produces wider Omega (less confident views)
- Test regime_clarity=0.9 (clear) produces tighter Omega (more confident views)
- Test empty views returns equilibrium unchanged
- Test single view on one instrument shifts only that instrument's return

tests/test_position_sizer.py:
- Test vol_target_size: 10% target / 20% instrument vol = 0.5 position
- Test vol_target_size clamped to max_position
- Test fractional_kelly: half Kelly produces 50% of full Kelly
- Test fractional_kelly with negative expected return produces short position
- Test risk_budget_size: proportional to component VaR share
- Test soft limit override: conviction > 0.8 allows up to 1.2x max_position
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_black_litterman.py tests/test_position_sizer.py -v</verify>
  <done>Black-Litterman produces regime-adjusted posterior returns; mean-variance optimizer finds optimal weights via scipy; PositionSizer offers vol_target, half-Kelly, and risk_budget methods with soft limit overrides</done>
</task>

<task type="auto">
  <name>Task 2: Portfolio state table migration and portfolio API endpoints</name>
  <files>src/core/models/portfolio_state.py, alembic/versions/008_create_portfolio_state_table.py, src/api/routes/portfolio_api.py, tests/test_portfolio_api_v2.py</files>
  <action>
Create the portfolio_state ORM model, Alembic migration, and expand the portfolio API with 3 new endpoints.

**src/core/models/portfolio_state.py — ORM Model:**

`PortfolioStateRecord(Base)` — maps to `portfolio_state` table:
- id: Mapped[int] — BigInteger, primary_key, part of composite PK
- timestamp: Mapped[datetime] — DateTime(timezone=True), primary_key, part of composite PK (hypertable time column)
- instrument: Mapped[str] — String(50), not nullable
- direction: Mapped[str] — String(10), not nullable (LONG/SHORT/NEUTRAL)
- notional: Mapped[float] — Float, not nullable
- weight: Mapped[float] — Float, not nullable
- entry_price: Mapped[float | None] — Float, nullable
- unrealized_pnl: Mapped[float | None] — Float, nullable
- strategy_attribution: Mapped[dict | None] — JSON, nullable — stores {"strategy_id": contribution_weight, ...}

Add UniqueConstraint on (timestamp, instrument) named "uq_portfolio_state_natural_key".
Add __tablename__ = "portfolio_state".

Register in src/core/models/__init__.py.

**alembic/versions/008_create_portfolio_state_table.py — Migration:**

Follow the project's Alembic pattern (manual migration with raw SQL for TimescaleDB):
- revision = "008"
- down_revision = "007"
- Create portfolio_state table with all columns above
- Create hypertable: `SELECT create_hypertable('portfolio_state', 'timestamp', migrate_data => true)`
- Create unique constraint on (timestamp, instrument)
- Add compression policy (compress after 30 days)

**Enhanced src/api/routes/portfolio_api.py — 3 new endpoints:**

Keep existing `/portfolio/current` and `/portfolio/risk` endpoints. Add:

**GET /api/v1/portfolio/target:**
- Returns target portfolio weights from optimization.
- Builds target weights by instantiating PortfolioOptimizer, running on sample/placeholder data.
- Response: {targets: [{instrument, direction, target_weight, current_weight, sizing_method}], optimization: {method: "black_litterman", regime_clarity, constraints}}.

**GET /api/v1/portfolio/rebalance-trades:**
- Computes required trades to move from current to target weights.
- Response: {trades: [{instrument, direction, current_weight, target_weight, trade_weight, trade_notional}], should_rebalance: bool, trigger_reason: str | null, estimated_cost: float}.
- Uses PortfolioOptimizer.should_rebalance() to determine if rebalancing is needed.

**GET /api/v1/portfolio/attribution:**
- Returns strategy attribution for current portfolio.
- Response: {attribution: [{instrument, strategies: [{strategy_id, contribution_weight, contribution_pnl}]}], total_pnl: float, by_strategy: {strategy_id: total_contribution}}.
- Reads from strategy_attribution JSON in portfolio_state records (or builds from in-memory state).

**Tests (tests/test_portfolio_api_v2.py):**
- Use TestClient with minimal FastAPI app containing portfolio router
- Test GET /portfolio/current returns 200 (existing, backward compat)
- Test GET /portfolio/target returns 200 with targets list
- Test GET /portfolio/rebalance-trades returns 200 with trades list and should_rebalance flag
- Test GET /portfolio/attribution returns 200 with attribution list
- Test response envelope format: {status: "ok", data: ..., meta: {timestamp: ...}}
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_portfolio_api_v2.py -v</verify>
  <done>PortfolioStateRecord ORM model persists positions with strategy attribution; Alembic migration 008 creates hypertable; 3 new portfolio API endpoints return target weights, rebalance trades, and strategy attribution</done>
</task>

</tasks>

<verification>
```bash
cd /home/user/Macro_Trading && python -m pytest tests/test_black_litterman.py tests/test_position_sizer.py tests/test_portfolio_api_v2.py -v --tb=short
```

Additional checks:
- `python -c "from src.portfolio.black_litterman import BlackLitterman; print('BL OK')"` — module imports
- `python -c "from src.portfolio.position_sizer import PositionSizer; print('Sizer OK')"` — module imports
- `python -c "from src.portfolio.portfolio_optimizer import PortfolioOptimizer; print('Optimizer OK')"` — module imports
- `python -c "from src.core.models.portfolio_state import PortfolioStateRecord; print('ORM OK')"` — model imports
- Verify migration file exists: `ls alembic/versions/008_*`
</verification>

<success_criteria>
- Black-Litterman combines equilibrium returns with agent views; regime clarity adjusts view confidence
- Mean-variance optimization via scipy.minimize finds optimal weights with configurable constraints
- PositionSizer: vol_target (target_vol/instrument_vol), fractional_kelly (0.5x), risk_budget_size
- Soft position limits allow 20% override when conviction > 0.8
- Rebalancing only triggers when signal change > threshold OR drift > threshold
- portfolio_state table created with hypertable, strategy_attribution JSON column
- GET /portfolio/target, /portfolio/rebalance-trades, /portfolio/attribution return 200
- Existing /portfolio/current and /portfolio/risk endpoints preserved
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization/17-04-SUMMARY.md`
</output>
