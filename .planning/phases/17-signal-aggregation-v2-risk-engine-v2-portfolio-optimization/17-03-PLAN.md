---
phase: 17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization
plan: 03
type: execute
wave: 2
depends_on:
  - 17-02
files_modified:
  - src/risk/risk_limits_v2.py
  - src/risk/risk_monitor.py
  - src/api/routes/risk_api.py
  - tests/test_risk_limits_v2.py
  - tests/test_risk_api_v2.py
autonomous: true
requirements:
  - RSKV-07
  - RSKV-08

must_haves:
  truths:
    - "RiskLimitsManager v2 tracks daily and weekly cumulative losses with configurable limits"
    - "Risk budget tracking shows available risk budget per position and per asset class"
    - "API GET /api/v1/risk/var returns VaR/CVaR at 95% and 99% for all methods"
    - "API GET /api/v1/risk/stress returns all 6 stress scenario results"
    - "API GET /api/v1/risk/limits returns current limit utilization and breach status"
    - "API GET /api/v1/risk/dashboard returns aggregated risk overview"
  artifacts:
    - path: "src/risk/risk_limits_v2.py"
      provides: "RiskLimitsManager v2 with daily/weekly loss tracking and risk budget"
      min_lines: 150
    - path: "src/api/routes/risk_api.py"
      provides: "4 risk API endpoints: /var, /stress, /limits, /dashboard"
      min_lines: 100
    - path: "tests/test_risk_limits_v2.py"
      provides: "Tests for daily/weekly loss tracking, risk budget computation"
      min_lines: 60
    - path: "tests/test_risk_api_v2.py"
      provides: "Tests for all 4 risk API endpoints returning 200"
      min_lines: 50
  key_links:
    - from: "src/risk/risk_limits_v2.py"
      to: "src/risk/risk_limits.py"
      via: "Extends RiskLimitChecker with loss tracking and risk budgeting"
      pattern: "RiskLimitChecker|RiskLimitsConfig"
    - from: "src/api/routes/risk_api.py"
      to: "src/risk/var_calculator.py"
      via: "VaRCalculator for /var endpoint"
      pattern: "VaRCalculator|compute_"
    - from: "src/api/routes/risk_api.py"
      to: "src/risk/stress_tester.py"
      via: "StressTester for /stress endpoint"
      pattern: "StressTester|run_all"
    - from: "src/api/routes/risk_api.py"
      to: "src/risk/risk_limits_v2.py"
      via: "RiskLimitsManager for /limits endpoint"
      pattern: "RiskLimitsManager"
---

<objective>
Build the RiskLimitsManager v2 with daily/weekly cumulative loss tracking, risk budget monitoring, and available risk budget reporting. Also expand the risk API routes to 4 dedicated endpoints: /var, /stress, /limits, and /dashboard.

Purpose: The existing RiskLimitChecker (Phase 12) provides point-in-time limit checks. The v2 adds temporal tracking (daily/weekly loss accumulation) and risk budget awareness -- essential for a PM to know how much risk capacity remains. The API routes make all risk data accessible to the dashboard and external systems.

Output: Enhanced risk limits module and 4 API endpoints with tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/risk/risk_limits.py
@src/risk/risk_monitor.py
@src/risk/var_calculator.py
@src/risk/stress_tester.py
@src/api/routes/risk_api.py
@.planning/phases/17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization/17-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: RiskLimitsManager v2 with daily/weekly loss tracking and risk budget</name>
  <files>src/risk/risk_limits_v2.py, tests/test_risk_limits_v2.py</files>
  <action>
Create `src/risk/risk_limits_v2.py` — extends the existing RiskLimitChecker with temporal loss tracking and risk budget management. The existing `risk_limits.py` is preserved; this adds a higher-level manager.

**RiskLimitsManagerConfig dataclass (frozen):**
- daily_loss_limit_pct: float = 0.02 — max daily portfolio loss (2%)
- weekly_loss_limit_pct: float = 0.05 — max weekly portfolio loss (5%)
- total_risk_budget: float = 1.0 — total risk budget (100% = fully allocated)
- risk_budget_per_position: float = 0.20 — max risk contribution per single position (20%)
- risk_budget_per_asset_class: float = 0.40 — max risk per asset class (40%)
- include existing RiskLimitsConfig fields via composition (not inheritance): embed a `limits_config: RiskLimitsConfig` field.

**LossRecord dataclass:**
- date: date
- daily_pnl: float — daily P&L as fraction of portfolio
- cumulative_weekly_pnl: float — rolling 5-day cumulative P&L
- strategies_pnl: dict[str, float] — per-strategy daily P&L
- breach_daily: bool
- breach_weekly: bool

**RiskBudgetReport dataclass:**
- total_risk_budget: float
- allocated_risk: float — sum of position risk contributions
- available_risk_budget: float — total - allocated
- utilization_pct: float — allocated / total * 100
- position_budgets: dict[str, dict] — per-position: {allocated, limit, utilization_pct, breached}
- asset_class_budgets: dict[str, dict] — per-asset-class: {allocated, limit, utilization_pct, breached}
- can_add_risk: bool — True if available_risk_budget > 0.05 (5% headroom)

**RiskLimitsManager class:**
- `__init__(self, config: RiskLimitsManagerConfig | None = None)` — stores config, initializes internal `_loss_history: list[LossRecord]` (max 30 entries) and creates a `RiskLimitChecker` from config.limits_config.
- `record_daily_pnl(self, date: date, daily_pnl: float, strategies_pnl: dict[str, float] | None = None) -> LossRecord` — records daily P&L, computes 5-business-day rolling sum for weekly, checks against daily/weekly limits. Stores in _loss_history (FIFO, max 30).
- `get_loss_history(self, n_days: int = 5) -> list[LossRecord]` — returns last n_days of loss records.
- `compute_risk_budget(self, risk_contributions: dict[str, float], asset_class_map: dict[str, str]) -> RiskBudgetReport` — takes per-position risk contributions (from component VaR in Plan 17-02) and a position->asset_class mapping, computes available budget. Aggregates by asset class for asset_class_budgets.
- `check_all_v2(self, portfolio_state: dict) -> dict` — calls the underlying RiskLimitChecker.check_all() and adds daily/weekly loss checks from _loss_history. Returns {"limit_results": list[LimitCheckResult], "loss_status": LossRecord | None, "risk_budget": RiskBudgetReport | None, "overall_status": str}.
- `available_risk_budget(self) -> float` — quick accessor returning total_risk_budget minus last known allocated risk.

**Tests (tests/test_risk_limits_v2.py):**
- Test record_daily_pnl: -3% daily loss breaches 2% limit
- Test weekly cumulative: 5 days of -1.2% each = -6% weekly, breaches 5% limit
- Test daily loss within limit: -1% does not breach
- Test compute_risk_budget: 3 positions with risk_contributions summing to 0.6 -> 0.4 available
- Test per-position budget breach: one position contributing 25% breaches 20% limit
- Test loss history FIFO: adding 35 records keeps only last 30
- Test check_all_v2 returns combined limit + loss + budget status
- Test available_risk_budget returns correct remaining budget
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_risk_limits_v2.py -v</verify>
  <done>RiskLimitsManager v2 tracks daily/weekly losses, computes risk budget allocation per position and asset class, reports available risk budget</done>
</task>

<task type="auto">
  <name>Task 2: Risk API routes for /var, /stress, /limits, and /dashboard</name>
  <files>src/api/routes/risk_api.py, tests/test_risk_api_v2.py</files>
  <action>
Replace the existing minimal `src/api/routes/risk_api.py` (currently just a /risk/report endpoint that delegates to portfolio_api) with 4 dedicated risk endpoints per requirement RSKV-08.

**Endpoint 1: GET /api/v1/risk/var**
- Query params: `method` (optional, one of "historical", "parametric", "monte_carlo", "all"; default "all"), `confidence` (optional, 95 or 99; default both reported)
- Builds synthetic portfolio returns from available strategies via asyncio.to_thread.
- Returns response envelope with VaRResult(s): {method, var_95, var_99, cvar_95, cvar_99, n_observations}.
- When method="all", returns dict keyed by method name.
- Imports VaRCalculator and uses generate sample portfolio returns (or placeholder returns for now — real data when DB available). Pattern: try to compute from real data, fall back to placeholder with a warning flag.

**Endpoint 2: GET /api/v1/risk/stress**
- Query params: `scenario` (optional, string name to filter a single scenario)
- Returns all stress scenario results (6 scenarios) from StressTester.run_all().
- Builds sample positions dict for stress testing.
- Response: {scenarios: [{scenario_name, portfolio_pnl, portfolio_pnl_pct, worst_position, positions_impacted}]}.

**Endpoint 3: GET /api/v1/risk/limits**
- No query params.
- Returns current limit utilization from RiskLimitsManager v2.
- Response: {limits: [{limit_name, limit_value, current_value, utilization_pct, breached}], loss_status: {daily_pnl, weekly_pnl, daily_breached, weekly_breached} | null, risk_budget: {total, allocated, available, utilization_pct} | null}.

**Endpoint 4: GET /api/v1/risk/dashboard**
- No query params.
- Aggregated risk overview combining VaR, stress, limits, and circuit breaker status.
- Delegates to RiskMonitor.generate_report() via asyncio.to_thread, then serializes the RiskReport into a JSON-friendly dict.
- Response: {overall_risk_level, portfolio_value, var: {historical: {...}, parametric: {...}}, worst_stress: {scenario_name, pnl_pct}, limits_breached: int, circuit_breaker: {state, scale, drawdown_pct}}.

**Keep the existing /risk/report endpoint** for backward compatibility (it already delegates to portfolio_api).

**Response envelope pattern (consistent with existing v2 endpoints):**
```python
def _envelope(data: Any) -> dict:
    return {"status": "ok", "data": data, "meta": {"timestamp": datetime.now(timezone.utc).isoformat()}}
```

**Error handling:** All endpoints wrap in try/except, return 500 with {status: "error", error: message} on failure. This follows the existing pattern in risk_api.py and portfolio_api.py.

**Tests (tests/test_risk_api_v2.py):**
- Use pytest + httpx TestClient pattern (same as existing API tests)
- Create minimal FastAPI app with risk router for testing (same pattern as test_dashboard.py)
- Test GET /risk/var returns 200 with var_95/var_99/cvar_95/cvar_99 keys
- Test GET /risk/stress returns 200 with scenarios list containing 6 entries
- Test GET /risk/limits returns 200 with limits list
- Test GET /risk/dashboard returns 200 with overall_risk_level key
- Test GET /risk/report still works (backward compat)
  </action>
  <verify>cd /home/user/Macro_Trading && python -m pytest tests/test_risk_api_v2.py -v</verify>
  <done>4 risk API endpoints return valid responses: /risk/var (VaR/CVaR), /risk/stress (6 scenarios), /risk/limits (utilization + budget), /risk/dashboard (aggregated overview); /risk/report preserved for backward compatibility</done>
</task>

</tasks>

<verification>
```bash
cd /home/user/Macro_Trading && python -m pytest tests/test_risk_limits_v2.py tests/test_risk_api_v2.py -v --tb=short
```

Additional checks:
- `python -c "from src.risk.risk_limits_v2 import RiskLimitsManager; print('Import OK')"` — module imports
- `python -c "from src.api.routes.risk_api import router; print(f'Routes: {len(router.routes)}')"` — router has 5+ routes
- Verify existing risk_limits.py is untouched (backward compat)
</verification>

<success_criteria>
- RiskLimitsManager v2 tracks daily loss (2% limit) and weekly cumulative loss (5% limit)
- Risk budget tracking reports available/allocated/utilization per position and asset class
- GET /risk/var returns VaR and CVaR at 95% and 99% for all methods
- GET /risk/stress returns all 6 scenario results
- GET /risk/limits returns limit utilization, breach status, and risk budget
- GET /risk/dashboard returns aggregated risk overview with overall risk level
- Existing /risk/report endpoint preserved
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/17-signal-aggregation-v2-risk-engine-v2-portfolio-optimization/17-03-SUMMARY.md`
</output>
