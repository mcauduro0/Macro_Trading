---
phase: 09-fiscal-fx-equilibrium-agents
plan: 02
type: execute
wave: 2
depends_on:
  - 09-01
files_modified:
  - src/agents/features/fx_features.py
  - src/agents/fx_agent.py
  - src/agents/features/__init__.py
  - tests/test_fx_agent.py
autonomous: true
requirements:
  - FXEQ-01
  - FXEQ-02
  - FXEQ-03
  - FXEQ-04
  - FXEQ-05

must_haves:
  truths:
    - "FxEquilibriumAgent.run(as_of_date) returns an AgentReport with exactly 5 AgentSignal objects (BEER, Carry-to-Risk, Flow, CIP Basis, Composite)"
    - "BeerModel fits OLS on available BEER predictors (2010-present), returns SHORT when USDBRL > fair value by 5%+ (BRL undervalued), LONG when overvalued, NO_SIGNAL when fewer than 2 predictors or < 24 obs"
    - "CarryToRiskModel z-scores the 12M rolling carry/vol ratio, fires SHORT when z > 1.0 (unusually attractive carry) and LONG when z < -1.0 (carry unwind risk)"
    - "FlowModel combines BCB FX flow z-score and CFTC 6L z-score at equal weight, returns directional composite"
    - "CipBasisModel returns LONG when basis is positive (DDI > offshore USD = funding friction = BRL less attractive)"
    - "All FX unit tests pass without a database connection"
  artifacts:
    - path: "src/agents/features/fx_features.py"
      provides: "FxFeatureEngine class with compute() method and private keys _beer_ols_data, _ptax_daily, _carry_ratio_history, _flow_combined, _as_of_date"
      contains: "class FxFeatureEngine"
    - path: "src/agents/fx_agent.py"
      provides: "FxEquilibriumAgent + BeerModel + CarryToRiskModel + FlowModel + CipBasisModel"
      exports: ["FxEquilibriumAgent", "BeerModel", "CarryToRiskModel", "FlowModel", "CipBasisModel"]
    - path: "src/agents/features/__init__.py"
      provides: "Updated package re-export to include FxFeatureEngine (conditional import after FiscalFeatureEngine)"
      contains: "FxFeatureEngine"
    - path: "tests/test_fx_agent.py"
      provides: "Unit tests for FxFeatureEngine keys and all 4 model direction cases"
      contains: "def test_fx_feature_engine_keys"
  key_links:
    - from: "src/agents/fx_agent.py"
      to: "src/agents/features/fx_features.py"
      via: "instantiation of FxFeatureEngine in FxEquilibriumAgent.__init__"
      pattern: "FxFeatureEngine"
    - from: "src/agents/fx_agent.py"
      to: "src/agents/base.py"
      via: "class FxEquilibriumAgent(BaseAgent)"
      pattern: "class FxEquilibriumAgent.*BaseAgent"
    - from: "src/agents/fx_agent.py"
      to: "statsmodels.api.OLS"
      via: "BeerModel fits log(USDBRL) = f(ToT, r_diff, NFA, productivity_diff) on full 2010-present history"
      pattern: "sm.OLS"
---

<objective>
Build FxFeatureEngine (BEER inputs, carry-to-risk, FX flows, CIP basis), all 4 FX models (BeerModel OLS, CarryToRiskModel, FlowModel, CipBasisModel), FxEquilibriumAgent orchestration with FX_BR_COMPOSITE, update features/__init__.py, and unit tests for the FX agent.

Purpose: FxEquilibriumAgent depends on 09-01 only because both plans modify features/__init__.py — the init update must be sequential. The FX logic itself is independent. After this plan, FxEquilibriumAgent.run() produces all 5 required signals and is registerable in AgentRegistry alongside FiscalAgent.
Output: src/agents/features/fx_features.py, src/agents/fx_agent.py (with 4 models), src/agents/features/__init__.py (updated), tests/test_fx_agent.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-agent-framework-data-loader/07-01-SUMMARY.md
@.planning/phases/08-inflation-monetary-policy-agents/08-03-SUMMARY.md
@.planning/phases/09-fiscal-fx-equilibrium-agents/09-01-SUMMARY.md
@src/agents/base.py
@src/agents/data_loader.py
@src/agents/features/__init__.py
@src/agents/monetary_agent.py
@src/core/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FxFeatureEngine, all 4 FX models, FxEquilibriumAgent, and update features/__init__.py</name>
  <files>
    src/agents/features/fx_features.py
    src/agents/fx_agent.py
    src/agents/features/__init__.py
  </files>
  <action>
**Part A — Create `src/agents/features/fx_features.py`:**

```python
class FxFeatureEngine:
    """Compute FX equilibrium features from raw point-in-time data."""

    def compute(self, data: dict, as_of_date: date) -> dict[str, Any]:
        """Return a flat dict of all FX features plus private model keys."""
```

All computations guard with try/except returning np.nan on failure — never raise.

**Scalar features to compute:**

Spot level:
- `usdbrl_spot`: latest USDBRL close from data["ptax"] (market_data "USDBRL_PTAX"), daily close resampled to latest.
- `usdbrl_yoy`: USDBRL YoY % change.

Carry fundamentals:
- `selic_rate`: latest BCB-432 value from data["selic"].
- `fed_funds_rate`: latest FRED-DFF value from data["fed_funds"].
- `carry_raw`: selic_rate - fed_funds_rate (raw carry differential %).
- `vol_30d_realized`: 30-day realized USDBRL vol (annualized %). Computed from data["ptax"] daily returns: `daily_returns = ptax_close.pct_change().dropna(); vol_30d = daily_returns.rolling(30).std().iloc[-1] * np.sqrt(252) * 100`.
- `carry_to_risk_ratio`: carry_raw / vol_30d_realized (carry divided by vol; NaN if vol=0).

BEER inputs (monthly, 2010-present):
- `real_rate_diff`: DI 5Y real rate minus UST 5Y real rate. DI 5Y: interpolate from data["di_curve_history"] at 1825 days tenor; US 5Y: from data["ust_5y_history"]; adjust each for local inflation expectations (focus_ipca_12m for BR, PCE core for US).
- `nfa_proxy`: latest FX reserves level from data["fx_reserves"] ("BR_RESERVES", BCB-13621, in USD bn). Use log transformation: log(reserves).
- `tot_proxy`: 12M % change in data["trade_balance"] ("BR_TRADE_BALANCE", BCB-22707, monthly BRL bn). Terms of trade proxy: improving trade balance = positive ToT shock.
- `cip_basis`: DI 1Y rate minus (fed_funds_rate + expected_depreciation_12m). Use Focus Câmbio 12M (data["focus_cambio"], series "BR_FOCUS_CAMBIO_12M_MEDIAN") for expected depreciation: `expected_dep = (focus_cambio - usdbrl_spot) / usdbrl_spot * 100`. `cip_basis = di_1y - (fed_funds_rate + expected_dep)`. If data missing, use simpler proxy: `di_1y - (fed_funds_rate + usdbrl_yoy)` (trailing realized depreciation as expectation).

Private keys for model classes:
- `features["_beer_ols_data"]`: Monthly DataFrame with columns `log_usdbrl`, `tot_proxy`, `real_rate_diff`, `nfa_proxy` (all available from 2010-present). Build by resampling data["ptax"] to monthly last, joining with monthly macro series. Compute `log_usdbrl = np.log(monthly_usdbrl_close)`. Drop rows where log_usdbrl is NaN. Keep other predictors with NaN (BeerModel will drop per-predictor).
- `features["_ptax_daily"]`: pd.Series of daily USDBRL close prices from data["ptax"], full history (lookback_days=756). Used for 30D vol and carry ratio history.
- `features["_carry_ratio_history"]`: pd.Series of monthly carry_to_risk_ratio (carry_raw / vol_30d_realized) over the trailing 12M+ history. Build from monthly resampled PTAX (for vol) and monthly selic/fed_funds. At minimum 13 months for z-score computation (12M rolling + 1 for z-score reference).
- `features["_flow_combined"]`: DataFrame with two columns: `bcb_flow_zscore` (z-scored BCB FX flow net) and `cftc_zscore` (z-scored CFTC 6L leveraged net positioning). Both z-scored over trailing 24M history. Source: data["bcb_flow"] (flow_data "BR_FX_FLOW_COMMERCIAL" + "BR_FX_FLOW_FINANCIAL") and data["cftc_brl"] (flow_data "CFTC_6L_LEVERAGED_NET"). If either is None/empty, substitute 0.0 in the combined DataFrame (with a NaN marker in metadata).
- `features["_di_1y_rate"]`: scalar float, DI 1Y rate from data["di_curve"] dict (tenor_days key closest to 252). Used by CipBasisModel.
- `features["_sofr_rate"]`: scalar float, latest SOFR from data["sofr"] ("FRED-SOFR"). Used by CipBasisModel as alternative CIP reference. If unavailable, use fed_funds_rate.
- `features["_as_of_date"]`: the as_of_date date object.

**Data keys expected in `data` dict (loaded by FxEquilibriumAgent.load_data):**
```
data["ptax"]             # DataFrame from get_market_data("USDBRL_PTAX", ..., lookback_days=5475)
data["selic"]            # DataFrame from get_macro_series("BCB-432", ...)
data["fed_funds"]        # DataFrame from get_macro_series("FRED-DFF", ...)
data["sofr"]             # DataFrame from get_macro_series("FRED-SOFR", ...) — may be None
data["fx_reserves"]      # DataFrame from get_macro_series("BR_RESERVES", ...)
data["trade_balance"]    # DataFrame from get_macro_series("BR_TRADE_BALANCE", ...)
data["focus_cambio"]     # DataFrame from get_macro_series("BR_FOCUS_CAMBIO_12M_MEDIAN", ...)
data["focus_ipca"]       # DataFrame from get_macro_series("FOCUS-IPCA-12M", ...)
data["di_curve"]         # dict from get_curve("DI", as_of_date) — {tenor_days: rate}
data["di_curve_history"] # DataFrame from get_curve_history("DI", 1825, as_of_date, lookback_days=5475)
data["ust_5y_history"]   # DataFrame from get_curve_history("UST", 1825, as_of_date, lookback_days=5475) — may be None
data["bcb_flow"]         # DataFrame from get_flow_data("BR_FX_FLOW_COMMERCIAL", ...) + get_flow_data("BR_FX_FLOW_FINANCIAL", ...)
data["cftc_brl"]         # DataFrame from get_flow_data("CFTC_6L_LEVERAGED_NET", ...)
```

**Part B — Create `src/agents/fx_agent.py`:**

Create the full file with all 4 model classes and FxEquilibriumAgent:

**BeerModel**:
```python
class BeerModel:
    """Behavioral Equilibrium Exchange Rate via OLS.

    log(USDBRL) = α + β1*tot_proxy + β2*real_rate_diff + β3*nfa_proxy + ε
    Refit with available predictors. NO_SIGNAL if fewer than 2 predictors survive.
    Misalignment threshold: ±5% (locked in CONTEXT.md).
    """
    SIGNAL_ID = "FX_BR_BEER"
    MIN_OBS = 24        # minimum monthly observations to fit
    THRESHOLD = 5.0     # % misalignment to fire signal (locked)
    PREDICTOR_COLS = ["tot_proxy", "real_rate_diff", "nfa_proxy"]
```

`run(features: dict, as_of_date: date) -> AgentSignal`:
- Inner `_no_signal(reason)` pattern.
- `df = features.get("_beer_ols_data")`. If None → `_no_signal("no_data")`.
- Determine available predictors: `available_preds = [c for c in PREDICTOR_COLS if c in df.columns and df[c].notna().sum() >= MIN_OBS]`. If len < 2 → `_no_signal("insufficient_predictors")`.
- `df_fit = df[["log_usdbrl"] + available_preds].dropna()`. If len < MIN_OBS → `_no_signal("insufficient_data")`.
- Fit: `X = sm.add_constant(df_fit[available_preds]); model = sm.OLS(df_fit["log_usdbrl"], X).fit()`.
- Predict fair value at latest row: `latest_X = sm.add_constant(df_fit[available_preds].iloc[[-1]], has_const=True); predicted_log = model.predict(latest_X).iloc[0]`. `fair_value = np.exp(predicted_log)`. `actual_usdbrl = np.exp(df_fit["log_usdbrl"].iloc[-1])`.
- `misalignment_pct = (actual_usdbrl / fair_value - 1) * 100`.
- **Signal direction (per locked CONTEXT.md — symmetric ±5%):**
  - `misalignment_pct > THRESHOLD` (USDBRL above fair, BRL undervalued) → SHORT USDBRL (mean reversion expected — sell USD vs BRL).
  - `misalignment_pct < -THRESHOLD` (USDBRL below fair, BRL overvalued) → LONG USDBRL (mean reversion — buy USD vs BRL).
  - Else NEUTRAL.
- `confidence = min(1.0, abs(misalignment_pct) / (THRESHOLD * 3))` (scales 0→1 over 0-15% misalignment).
- `strength = classify_strength(confidence)`.
- `value = round(misalignment_pct, 4)`.
- `horizon_days = 252` (12M mean reversion horizon).
- `metadata = {"fair_value": round(fair_value, 4), "actual_usdbrl": round(actual_usdbrl, 4), "misalignment_pct": round(misalignment_pct, 4), "n_obs": len(df_fit), "r_squared": round(model.rsquared, 4), "n_predictors": len(available_preds), "predictors_used": available_preds}`.

**CarryToRiskModel**:
```python
class CarryToRiskModel:
    """Carry-to-risk model: z-score of 12M rolling carry/vol ratio.

    carry_ratio = (selic - fed_funds) / vol_30d_realized
    Z-score of carry_ratio over 12M history. |z| > 1.0 fires signal.
    Positive z (unusually attractive carry) → SHORT USDBRL.
    Negative z (carry unwind risk) → LONG USDBRL.
    Denominator: 30D realized USDBRL vol from daily PTAX (locked in CONTEXT.md).
    """
    SIGNAL_ID = "FX_BR_CARRY_RISK"
    Z_FIRE = 1.0     # |z| threshold to fire
    ROLL_WINDOW = 12 # months for z-score
    MIN_OBS = 13     # need 12M of history plus current
```

`run(features: dict, as_of_date: date) -> AgentSignal`:
- Inner `_no_signal(reason)` pattern.
- `carry_history = features.get("_carry_ratio_history")`. If None or len < MIN_OBS → `_no_signal("insufficient_data")`.
- Latest carry_ratio: `current = carry_history.iloc[-1]`. If NaN → `_no_signal("nan_carry_ratio")`.
- Z-score: `roll_mean = carry_history.rolling(ROLL_WINDOW).mean().iloc[-1]`, `roll_std = carry_history.rolling(ROLL_WINDOW).std().iloc[-1]`. If roll_std == 0 or NaN → `_no_signal("zero_variance")`.
- `z = (current - roll_mean) / roll_std`.
- Direction (per locked CONTEXT.md): `z > Z_FIRE` → SHORT (attractive carry = BRL inflows expected = fade USD); `z < -Z_FIRE` → LONG (carry unwind risk = BRL outflows = buy USD). Else NEUTRAL.
- `confidence = min(1.0, abs(z) / 2.0)`.
- `strength = classify_strength(confidence)`.
- `value = round(float(z), 4)`.
- `horizon_days = 63` (3M carry trade horizon).
- `metadata = {"carry_ratio": round(float(current), 4), "z_score": round(float(z), 4), "roll_mean": round(float(roll_mean), 4), "carry_raw_pct": features.get("carry_raw", float("nan")), "vol_30d": features.get("vol_30d_realized", float("nan"))}`.

**FlowModel**:
```python
class FlowModel:
    """FX flow composite from BCB FX flows and CFTC BRL positioning.

    Equal-weight z-scores: BCB commercial + financial flow net (BCB FX flow)
    and CFTC 6L (BRL/USD futures) non-commercial leveraged net position.
    Positive composite (net inflows + long BRL positioning) → SHORT USDBRL.
    Negative composite → LONG USDBRL.
    """
    SIGNAL_ID = "FX_BR_FLOW"
    Z_FIRE = 0.5     # composite z-score threshold to fire
    MIN_OBS = 4      # minimum non-null observations per component
```

`run(features: dict, as_of_date: date) -> AgentSignal`:
- Inner `_no_signal(reason)` pattern.
- `flow_df = features.get("_flow_combined")`. If None or empty → `_no_signal("no_flow_data")`.
- Extract latest row: `bcb_z = flow_df["bcb_flow_zscore"].iloc[-1]`, `cftc_z = flow_df["cftc_zscore"].iloc[-1]`.
- Handle partial data: if bcb_z is NaN and cftc_z is NaN → `_no_signal("all_nan")`. If one is NaN, use the other alone (100% weight). If both available, equal-weight average: `composite_z = (bcb_z + cftc_z) / 2`.
- Direction: `composite_z > Z_FIRE` → SHORT (net BRL inflows = BRL demand = sell USD); `composite_z < -Z_FIRE` → LONG (outflows). Else NEUTRAL.
- `confidence = min(1.0, abs(composite_z) / 2.0)`.
- `strength = classify_strength(confidence)`.
- `value = round(float(composite_z), 4)`.
- `horizon_days = 21` (1M flow signal horizon — flows are short-term).
- `metadata = {"composite_z": round(float(composite_z), 4), "bcb_flow_z": float(bcb_z) if not np.isnan(bcb_z) else None, "cftc_z": float(cftc_z) if not np.isnan(cftc_z) else None}`.

**CipBasisModel**:
```python
class CipBasisModel:
    """CIP deviation: DI 1Y minus (USD offshore rate + expected depreciation).

    Proxy: cip_basis = di_1y - (fed_funds + expected_usdbrl_depreciation_12m)
    where expected_dep comes from Focus Câmbio 12M series.
    Positive basis (DDI > offshore USD cost) = capital flow friction = BRL less attractive.
    Direction (locked in CONTEXT.md): positive basis → LONG USDBRL.
    """
    SIGNAL_ID = "FX_BR_CIP_BASIS"
    Z_FIRE = 0.75    # z-score of basis history to fire signal
    ROLL_WINDOW = 24 # months for z-score baseline
```

`run(features: dict, as_of_date: date) -> AgentSignal`:
- Inner `_no_signal(reason)` pattern.
- `cip_basis = features.get("cip_basis")`. If NaN or None → `_no_signal("no_cip_data")`.
- For z-score: use `features.get("_cip_basis_history")` if available (pre-computed rolling basis series). If not available, use the scalar cip_basis alone with threshold-based signal instead of z-score.
- **Threshold approach when history unavailable:** `di_1y = features.get("_di_1y_rate", np.nan)`, `sofr = features.get("_sofr_rate", np.nan)`. `basis_simple = di_1y - sofr` (simplified CIP basis without depreciation adjustment). If both available: direction from sign: positive → LONG USDBRL (locked), negative → SHORT USDBRL. Threshold = 1.0% (fire if |basis_simple| > 1.0%).
- **Z-score approach when history available:** z = (cip_basis - history.mean()) / history.std(). |z| > Z_FIRE fires signal.
- Direction (locked in CONTEXT.md regardless of approach): positive basis → LONG USDBRL; negative basis → SHORT USDBRL.
- `confidence = min(1.0, abs(cip_basis if cip_basis is not None else 0) / 5.0)` (5% basis = full confidence).
- `strength = classify_strength(confidence)`.
- `value = round(float(cip_basis), 4)` (or basis_simple if cip_basis unavailable).
- `horizon_days = 21` (CIP basis is a short-term funding stress indicator).
- `metadata = {"basis_pct": round(float(cip_basis), 4), "di_1y": features.get("_di_1y_rate", float("nan")), "sofr": features.get("_sofr_rate", float("nan")), "interpretation": "positive_basis_means_brl_less_attractive"}`.

**FxEquilibriumAgent class**:
```python
class FxEquilibriumAgent(BaseAgent):
    AGENT_ID = "fx_agent"
    AGENT_NAME = "FX Equilibrium Agent"

    def __init__(self, loader: PointInTimeDataLoader) -> None:
        super().__init__(self.AGENT_ID, self.AGENT_NAME)
        self.loader = loader
        self.feature_engine = FxFeatureEngine()
        self.beer_model = BeerModel()
        self.carry_model = CarryToRiskModel()
        self.flow_model = FlowModel()
        self.cip_model = CipBasisModel()
```

`load_data(as_of_date: date) -> dict`: Use self.loader — wrap each call in try/except returning None on failure:
- `data["ptax"] = self.loader.get_market_data("USDBRL_PTAX", as_of_date, lookback_days=5475)` (15Y daily for BEER monthly + vol history)
- `data["selic"] = self.loader.get_macro_series("BCB-432", as_of_date, lookback_days=5475)`
- `data["fed_funds"] = self.loader.get_macro_series("FRED-DFF", as_of_date, lookback_days=5475)`
- `data["sofr"] = self.loader.get_macro_series("FRED-SOFR", as_of_date, lookback_days=1825)`
- `data["fx_reserves"] = self.loader.get_macro_series("BR_RESERVES", as_of_date, lookback_days=5475)`
- `data["trade_balance"] = self.loader.get_macro_series("BR_TRADE_BALANCE", as_of_date, lookback_days=5475)`
- `data["focus_cambio"] = self.loader.get_macro_series("BR_FOCUS_CAMBIO_12M_MEDIAN", as_of_date, lookback_days=1825)`
- `data["focus_ipca"] = self.loader.get_macro_series("FOCUS-IPCA-12M", as_of_date, lookback_days=5475)`
- `data["di_curve"] = self.loader.get_curve("DI", as_of_date)`
- `data["di_curve_history"] = self.loader.get_curve_history("DI", 1825, as_of_date, lookback_days=5475)`
- `data["ust_5y_history"] = self.loader.get_curve_history("UST", 1825, as_of_date, lookback_days=5475)`
- `data["bcb_flow"] = self.loader.get_flow_data("BR_FX_FLOW_COMMERCIAL", as_of_date, lookback_days=1825)` (1825 for 5Y flow history)
- `data["cftc_brl"] = self.loader.get_flow_data("CFTC_6L_LEVERAGED_NET", as_of_date, lookback_days=1825)`
- `data["_as_of_date"] = as_of_date`

`compute_features(data: dict) -> dict`:
```python
def compute_features(self, data: dict) -> dict:
    return self.feature_engine.compute(data, data.get("_as_of_date"))
```

`run_models(features: dict) -> list[AgentSignal]`:
```python
def run_models(self, features: dict) -> list[AgentSignal]:
    as_of_date = features["_as_of_date"]
    signals = []
    beer_sig = self.beer_model.run(features, as_of_date)
    signals.append(beer_sig)
    carry_sig = self.carry_model.run(features, as_of_date)
    signals.append(carry_sig)
    flow_sig = self.flow_model.run(features, as_of_date)
    signals.append(flow_sig)
    cip_sig = self.cip_model.run(features, as_of_date)
    signals.append(cip_sig)
    # Composite (locked weights per CONTEXT.md)
    signals.append(self._build_composite(signals, as_of_date))
    return signals
```

`_build_composite(sub_signals, as_of_date)`: Follow MonetaryPolicyAgent._build_composite pattern exactly:
- Signal ID: `"FX_BR_COMPOSITE"`. Agent ID: `"fx_agent"`.
- **Locked weights (CONTEXT.md):** BEER=0.40, Carry=0.30, Flow=0.20, CIP=0.10. Map to signal IDs: `base_weights = {"FX_BR_BEER": 0.40, "FX_BR_CARRY_RISK": 0.30, "FX_BR_FLOW": 0.20, "FX_BR_CIP_BASIS": 0.10}`.
- Filter to active (non-NO_SIGNAL, non-NEUTRAL) signals. Renormalize weights among active signals.
- If no active signals: return NO_SIGNAL composite.
- Plurality vote. Conflict dampening 0.70 when any active signal disagrees with plurality.
- `composite_confidence = sum(sig.confidence * w for sig, w in norm_weights) * dampening`.
- `strength = classify_strength(composite_confidence)`.
- `horizon_days = 63` (weighted average of sub-signal horizons).
- `metadata = {"weights": "BEER40_Carry30_Flow20_CIP10", "dampening": dampening, "n_active": len(active)}`.

`generate_narrative(signals, features)`: Return formatted string:
```
f"FX Equilibrium Assessment ({as_of_date}): BEER={beer_direction} ({misalignment_pct:+.1f}% misalignment). " +
f"Carry-to-Risk={carry_direction} (z={z:.2f}). Flow={flow_direction} (composite_z={composite_z:.2f}). " +
f"CIP Basis={cip_direction} ({basis:.2f}%). Composite={composite_direction}."
```

All imports at top of fx_agent.py:
```python
from __future__ import annotations
import logging
import numpy as np
import pandas as pd
import statsmodels.api as sm
from datetime import date, datetime
from typing import Any
from src.agents.base import AgentSignal, AgentReport, BaseAgent, classify_strength
from src.agents.data_loader import PointInTimeDataLoader
from src.agents.features.fx_features import FxFeatureEngine
from src.core.enums import SignalDirection, SignalStrength
```

**Update `src/agents/features/__init__.py`:**

Read the current file (which includes FiscalFeatureEngine from Plan 09-01) and add FxFeatureEngine conditional import:
```python
try:
    from src.agents.features.fx_features import FxFeatureEngine  # type: ignore[import]
    __all__ = [*__all__, "FxFeatureEngine"]
except ImportError:
    pass
```

Run `ruff check --fix src/agents/features/fx_features.py src/agents/fx_agent.py src/agents/features/__init__.py` after writing.
  </action>
  <verify>
    Run: `python -c "from src.agents.fx_agent import FxEquilibriumAgent, BeerModel, CarryToRiskModel, FlowModel, CipBasisModel; print('all OK')"`
    Run: `python -c "from src.agents.features.fx_features import FxFeatureEngine; print(FxFeatureEngine)"`
    Run: `python -c "from src.agents.features import FxFeatureEngine, FiscalFeatureEngine, MonetaryFeatureEngine, InflationFeatureEngine; print('all 4 OK')"`
    Run: `ruff check src/agents/features/fx_features.py src/agents/fx_agent.py src/agents/features/__init__.py`
  </verify>
  <done>
    All 5 FX classes importable without error. FxFeatureEngine importable from src.agents.features.
    All 4 feature engines (Inflation, Monetary, Fiscal, FX) importable from src.agents.features in a single import.
    BeerModel.SIGNAL_ID == "FX_BR_BEER". BeerModel.THRESHOLD == 5.0 (locked symmetric threshold).
    ruff check passes zero violations.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for FxEquilibriumAgent models</name>
  <files>
    tests/test_fx_agent.py
  </files>
  <action>
Create `tests/test_fx_agent.py` with unit tests using synthetic features dicts — no database required. Follow the exact pattern from tests/test_monetary_agent.py and tests/test_fiscal_agent.py (MagicMock loader, synthetic DataFrames/dicts, no DB imports).

**Test file imports:**
```python
from __future__ import annotations

import numpy as np
import pandas as pd
import pytest
from datetime import date, datetime
from unittest.mock import MagicMock

from src.agents.fx_agent import (
    FxEquilibriumAgent,
    BeerModel,
    CarryToRiskModel,
    FlowModel,
    CipBasisModel,
)
from src.agents.features.fx_features import FxFeatureEngine
from src.agents.base import AgentSignal
from src.core.enums import SignalDirection, SignalStrength
```

Helper builder:
```python
def make_signal(signal_id, direction, strength, confidence=0.7):
    return AgentSignal(
        signal_id=signal_id, agent_id="fx_agent",
        timestamp=datetime.utcnow(), as_of_date=date(2024, 1, 31),
        direction=direction, strength=strength, confidence=confidence,
        value=1.0, horizon_days=252,
    )
```

Build helper for synthetic monthly DataFrame:
```python
def make_monthly_df(values, col="value"):
    idx = pd.date_range("2010-01-31", periods=len(values), freq="ME")
    return pd.DataFrame({col: values}, index=idx)
```

**Tests to implement (15+ tests):**

1. `test_fx_feature_engine_keys`:
   - Build synthetic data: `ptax` DataFrame (daily close=5.0 for 756 rows), `selic` monthly df (value=13.75), `fed_funds` monthly df (value=5.25), `sofr` monthly df (value=5.10), `fx_reserves` monthly df (value=350.0), `trade_balance` monthly df (value=10.0), `focus_ipca` monthly df (value=4.5), `focus_cambio` monthly df (value=5.2), `di_curve` dict ({252: 12.5, 504: 12.8, 1260: 13.0}), `di_curve_history` empty df, `ust_5y_history` empty df, `bcb_flow` None, `cftc_brl` None.
   - Call `FxFeatureEngine().compute(data, date(2024, 1, 31))`.
   - Assert scalar keys present: `["usdbrl_spot", "carry_raw", "vol_30d_realized", "carry_to_risk_ratio"]`.
   - Assert private keys: `"_beer_ols_data"`, `"_ptax_daily"`, `"_carry_ratio_history"`, `"_flow_combined"`, `"_as_of_date"`.
   - Assert `features["_as_of_date"] == date(2024, 1, 31)`.
   - Assert `isinstance(features["_beer_ols_data"], pd.DataFrame)`.
   - Assert `"log_usdbrl"` in features["_beer_ols_data"].columns.

2. `test_beer_model_undervalued_short`:
   - Build `_beer_ols_data` with 60 monthly rows. `log_usdbrl` = log(5.5) constant (USDBRL=5.5). `tot_proxy` = 0.02 constant. `real_rate_diff` = 0.05 constant. `nfa_proxy` = log(350) constant.
   - After OLS fit, predicted fair value should be close to 5.5. To make USDBRL undervalued, override by using `log_usdbrl` = log(6.0) at last row while fair value stays ~5.5 → misalignment ≈ +9% → SHORT.
   - Method: Set all rows to log(5.5) except last row = log(6.0). OLS fit on first 59 rows, predict using last row's X values.
   - Assert signal.direction == SignalDirection.SHORT (USDBRL above fair = BRL undervalued = sell USD).
   - Assert signal.signal_id == "FX_BR_BEER".
   - Assert signal.value > 5.0 (>5% misalignment).

3. `test_beer_model_overvalued_long`:
   - `log_usdbrl` = log(4.8) at last row, fair value ~5.5 → misalignment ≈ -13% → LONG.
   - Assert signal.direction == SignalDirection.LONG.

4. `test_beer_model_no_signal_insufficient_predictors`:
   - `_beer_ols_data` with only 1 predictor column (drop 2 others).
   - Assert signal.strength == SignalStrength.NO_SIGNAL.
   - Assert "insufficient_predictors" in signal.metadata.get("reason", "").

5. `test_beer_model_no_signal_insufficient_data`:
   - `_beer_ols_data` with only 10 rows.
   - Assert signal.strength == SignalStrength.NO_SIGNAL.

6. `test_beer_model_neutral_within_threshold`:
   - Set last row `log_usdbrl` = log(5.1) where fair value ~5.0 → misalignment ≈ +2% (below 5% threshold).
   - Assert signal.direction == SignalDirection.NEUTRAL.

7. `test_carry_to_risk_short_high_carry`:
   - Build `_carry_ratio_history` as pd.Series of 24 monthly values. Set mean ~2.0, std ~0.5. Set last value = 4.0 → z = (4.0-2.0)/0.5 = 4.0 >> 1.0 → SHORT.
   - Assert signal.direction == SignalDirection.SHORT (attractive carry = BRL inflows).
   - Assert signal.signal_id == "FX_BR_CARRY_RISK".
   - Assert signal.value == pytest.approx(4.0, abs=0.1).

8. `test_carry_to_risk_long_low_carry`:
   - Last value = 0.0, mean=2.0, std=0.5 → z = -4.0 → LONG (carry unwind risk).
   - Assert signal.direction == SignalDirection.LONG.

9. `test_carry_to_risk_no_signal_insufficient_data`:
   - `_carry_ratio_history` with only 5 values.
   - Assert signal.strength == SignalStrength.NO_SIGNAL.

10. `test_flow_model_positive_composite_short`:
    - Build `_flow_combined` df: `bcb_flow_zscore=1.5, cftc_zscore=1.2` at last row → composite_z = 1.35 > 0.5 → SHORT.
    - Assert signal.direction == SignalDirection.SHORT.
    - Assert signal.signal_id == "FX_BR_FLOW".

11. `test_flow_model_negative_composite_long`:
    - `bcb_flow_zscore=-1.5, cftc_zscore=-1.0` → composite_z = -1.25 → LONG.
    - Assert signal.direction == SignalDirection.LONG.

12. `test_flow_model_one_component_nan`:
    - `bcb_flow_zscore=np.nan, cftc_zscore=1.5` → use cftc only → composite_z = 1.5 → SHORT.
    - Assert signal.direction == SignalDirection.SHORT (not NO_SIGNAL — partial data still signals).

13. `test_cip_basis_positive_long`:
    - features: `_di_1y_rate=12.5`, `_sofr_rate=5.3`, `cip_basis=7.2` (high positive basis = BRL less attractive).
    - Assert signal.direction == SignalDirection.LONG (locked in CONTEXT.md: positive basis → LONG USDBRL).
    - Assert signal.signal_id == "FX_BR_CIP_BASIS".

14. `test_cip_basis_negative_short`:
    - features: `_di_1y_rate=10.0`, `_sofr_rate=5.3`, `cip_basis=-1.5`.
    - Assert signal.direction == SignalDirection.SHORT.

15. `test_fx_composite_locked_weights`:
    - Build 4 signals: BEER=SHORT(0.8), Carry=SHORT(0.7), Flow=LONG(0.6), CIP=LONG(0.5).
    - Instantiate `FxEquilibriumAgent(loader=MagicMock())` and call `_build_composite(signals, date(2024,1,31))`.
    - Weights: BEER=0.40, Carry=0.30, Flow=0.20, CIP=0.10. Active renormalized: all 4 active, total=1.0.
    - Plurality: SHORT(0.40+0.30=0.70) vs LONG(0.20+0.10=0.30) → SHORT.
    - Disagreements: 2 signals (Flow+CIP) disagree → dampening=0.70.
    - Assert composite.direction == SignalDirection.SHORT.
    - Assert composite.metadata["dampening"] == pytest.approx(0.70, abs=0.01).
    - Assert composite.signal_id == "FX_BR_COMPOSITE".

16. `test_fx_composite_unanimous_no_dampening`:
    - 4 SHORT signals → dampening=1.0.
    - Assert composite.direction == SignalDirection.SHORT.
    - Assert composite.metadata["dampening"] == pytest.approx(1.0, abs=0.01).

After writing tests, run `pytest tests/test_fx_agent.py -v --tb=short` and fix any bugs in fx_agent.py or fx_features.py inline (do not defer). Fix until all 16+ tests pass.

Run `ruff check tests/test_fx_agent.py` before finishing.
  </action>
  <verify>
    Run: `pytest tests/test_fx_agent.py -v --tb=short 2>&1 | tail -30`
    Expected: 16+ tests pass, 0 failed.
    Run: `ruff check tests/test_fx_agent.py`
    Run: `pytest tests/test_fiscal_agent.py tests/test_fx_agent.py -v --tb=short 2>&1 | tail -10`
    Expected: Both test files pass together — no import conflicts.
  </verify>
  <done>
    pytest reports 16+ passed, 0 failed, no database required.
    BeerModel: SHORT when USDBRL >5% above fair (BRL undervalued), LONG when >5% below fair, NO_SIGNAL when < 2 predictors or < 24 obs.
    CarryToRiskModel: SHORT when z>1.0 (attractive carry), LONG when z<-1.0 (unwind risk).
    FlowModel: SHORT when composite_z>0.5, LONG when <-0.5, partial data handled gracefully.
    CipBasisModel: LONG for positive basis (locked), SHORT for negative basis.
    FX_BR_COMPOSITE: BEER 40% + Carry 30% + Flow 20% + CIP 10% weights; 0.70 dampening when conflict.
    All 4 feature engines importable from src.agents.features. ruff check passes.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.agents.fx_agent import FxEquilibriumAgent, BeerModel, CarryToRiskModel, FlowModel, CipBasisModel"` — clean import
2. `python -c "from src.agents.features import FxFeatureEngine, FiscalFeatureEngine, MonetaryFeatureEngine, InflationFeatureEngine"` — all 4 importable from single import
3. `pytest tests/test_fiscal_agent.py tests/test_fx_agent.py -v` — all tests pass (both agents tested together)
4. `ruff check src/agents/features/fx_features.py src/agents/fx_agent.py src/agents/features/__init__.py tests/test_fx_agent.py` — zero violations
5. `BeerModel.THRESHOLD == 5.0` (locked symmetric misalignment threshold)
6. `FxEquilibriumAgent.AGENT_ID == "fx_agent"` (matches AgentRegistry EXECUTION_ORDER entry)
7. `python -c "from src.agents.registry import AgentRegistry; print(AgentRegistry.EXECUTION_ORDER)"` — "fx_agent" appears in EXECUTION_ORDER
</verification>

<success_criteria>
- FxFeatureEngine.compute() returns dict with usdbrl_spot, carry_raw, vol_30d_realized, carry_to_risk_ratio, real_rate_diff, nfa_proxy, cip_basis, and private keys _beer_ols_data, _ptax_daily, _carry_ratio_history, _flow_combined, _as_of_date
- BeerModel fits OLS on available predictors with full 2010-present history, ±5% threshold symmetric (locked), NO_SIGNAL if < 2 predictors or < 24 obs (locked — no forward-fill)
- CarryToRiskModel uses 30D realized PTAX vol denominator (locked), fires at |z| > 1.0, SHORT for high carry attractiveness
- FlowModel combines BCB FX flow z-score and CFTC 6L z-score at equal weight, gracefully handles missing component
- CipBasisModel direction: positive basis → LONG USDBRL (locked)
- FX_BR_COMPOSITE uses locked weights BEER 40% + Carry 30% + Flow 20% + CIP 10% with 0.70 conflict dampening
- FxEquilibriumAgent produces 5 signals: BEER + Carry + Flow + CIP + Composite in run_models()
- All 16+ FX unit tests pass without DB
- All files pass ruff check with zero violations
- All 4 feature engines importable from src.agents.features
</success_criteria>

<output>
After completion, create `.planning/phases/09-fiscal-fx-equilibrium-agents/09-02-SUMMARY.md`
</output>
