---
phase: 09-fiscal-fx-equilibrium-agents
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/agents/features/fiscal_features.py
  - src/agents/fiscal_agent.py
  - src/agents/features/__init__.py
  - tests/test_fiscal_agent.py
  - src/connectors/cftc_cot.py
autonomous: true
requirements:
  - FISC-01
  - FISC-02
  - FISC-03
  - FISC-04

must_haves:
  truths:
    - "FiscalAgent.run(as_of_date) returns an AgentReport with exactly 4 AgentSignal objects (DSA, Impulse, DominanceRisk, and Composite)"
    - "DebtSustainabilityModel projects 5Y debt/GDP path under 4 scenarios using d_{t+1} = d_t*(1+r)/(1+g) - pb and returns LONG when baseline terminal debt rises >5pp"
    - "FiscalDominanceRisk produces a composite 0-100 score from 4 weighted components and maps to LONG/NEUTRAL/SHORT via locked thresholds (0-33, 33-66, 66-100)"
    - "FiscalImpulseModel returns LONG when 12M primary balance z-score is negative (fiscal expansion) and SHORT when positive (fiscal contraction)"
    - "All fiscal unit tests pass without a database connection"
  artifacts:
    - path: "src/agents/features/fiscal_features.py"
      provides: "FiscalFeatureEngine class with compute() method and private keys _dsa_raw_data, _pb_history, _as_of_date"
      contains: "class FiscalFeatureEngine"
    - path: "src/agents/fiscal_agent.py"
      provides: "FiscalAgent + DebtSustainabilityModel + FiscalImpulseModel + FiscalDominanceRisk + FiscalComposite"
      exports: ["FiscalAgent", "DebtSustainabilityModel", "FiscalImpulseModel", "FiscalDominanceRisk"]
    - path: "src/agents/features/__init__.py"
      provides: "Updated package re-export to include FiscalFeatureEngine (conditional import)"
      contains: "FiscalFeatureEngine"
    - path: "tests/test_fiscal_agent.py"
      provides: "Unit tests for FiscalFeatureEngine keys and all 3 model direction cases"
      contains: "def test_fiscal_feature_engine_keys"
  key_links:
    - from: "src/agents/fiscal_agent.py"
      to: "src/agents/features/fiscal_features.py"
      via: "instantiation of FiscalFeatureEngine in FiscalAgent.__init__"
      pattern: "FiscalFeatureEngine"
    - from: "src/agents/fiscal_agent.py"
      to: "src/agents/base.py"
      via: "class FiscalAgent(BaseAgent)"
      pattern: "class FiscalAgent.*BaseAgent"
    - from: "src/agents/fiscal_agent.py"
      to: "DebtSustainabilityModel"
      via: "_project_debt_path() using locked formula d_{t+1} = d_t*(1+r)/(1+g) - pb"
      pattern: "_project_debt_path"
---

<objective>
Build FiscalFeatureEngine (debt ratios, r-g dynamics, primary balance, CB credibility proxy), all 3 fiscal models (DebtSustainabilityModel with IMF 4-scenario DSA, FiscalImpulseModel, FiscalDominanceRisk), FiscalAgent orchestration with FISCAL_BR_COMPOSITE, add BRL futures to CftcCotConnector, and unit tests for the fiscal agent.

Purpose: FiscalAgent is independent of InflationAgent and MonetaryPolicyAgent — it can be built in Wave 1 in parallel with Phase 10. After this plan, FiscalAgent.run() produces all 4 required signals and is registerable in AgentRegistry.
Output: src/agents/features/fiscal_features.py, src/agents/fiscal_agent.py (with 3 models), src/agents/features/__init__.py (updated), src/connectors/cftc_cot.py (BRL added), tests/test_fiscal_agent.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-agent-framework-data-loader/07-01-SUMMARY.md
@.planning/phases/07-agent-framework-data-loader/07-02-SUMMARY.md
@.planning/phases/08-inflation-monetary-policy-agents/08-03-SUMMARY.md
@src/agents/base.py
@src/agents/data_loader.py
@src/agents/features/__init__.py
@src/agents/monetary_agent.py
@src/core/enums.py
@src/connectors/cftc_cot.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FiscalFeatureEngine, all 3 fiscal models, FiscalAgent, and update features/__init__.py; add BRL to CFTC connector</name>
  <files>
    src/agents/features/fiscal_features.py
    src/agents/fiscal_agent.py
    src/agents/features/__init__.py
    src/connectors/cftc_cot.py
  </files>
  <action>
**Part A — Add BRL futures to CftcCotConnector in `src/connectors/cftc_cot.py`:**

In `CftcCotConnector.CONTRACT_CODES`, add a 13th entry:
```python
"6L": "102741",   # Brazilian Real (BRL/USD)
```

This 2-line change enables `get_flow_data("CFTC_6L_LEVERAGED_NET", as_of_date)` for BRL non-commercial positioning in Plan 09-02's FxEquilibriumAgent. Add after the `"DX"` entry. No other changes to this file.

**Part B — Create `src/agents/features/fiscal_features.py`:**

```python
class FiscalFeatureEngine:
    """Compute Brazil fiscal features from raw point-in-time data."""

    def compute(self, data: dict, as_of_date: date) -> dict[str, Any]:
        """Return a flat dict of all fiscal features plus private model keys."""
```

The `compute()` method receives a `data` dict (keyed as described below) and returns a flat dict. All computations must guard with try/except returning np.nan on failure — never raise.

**Features to compute:**

Debt dynamics (from data["gross_debt"] and data["net_debt"]):
- `gross_debt_gdp`: latest gross debt/GDP % (BCB-13762, macro_series series `"BR_GROSS_DEBT_GDP"`)
- `net_debt_gdp`: latest net debt/GDP % (BCB-4513, series `"BR_NET_DEBT_GDP"`)
- `debt_gdp_12m_change`: gross_debt_gdp change over trailing 12M (current minus 12M-ago value)
- `debt_gdp_trend`: 12M rolling mean of gross_debt_gdp (smoothed level)

Primary balance (from data["primary_balance"]):
- `primary_balance_gdp`: latest primary balance as % of GDP — compute as: primary_balance_brl_mm / gdp_brl_mm * 100. Use `"BR_PRIMARY_BALANCE"` (BCB-5793, accumulated 12M BRL billions) and GDP estimate from `"BR_GDP_QOQ"` (BCB-22099, quarterly BRL billions, annualized = quarterly * 4).
- `pb_12m_change`: 12M change in primary_balance_gdp (for impulse model)

R-G dynamics (real interest rate minus real growth):
- `r_nominal`: Selic target from data["selic"] (BCB-432), latest value in %
- `g_real`: annualized real GDP growth from data["gdp_qoq"] — trailing 4Q average of `(1 + qoq/100)^4 - 1` * 100 (convert quarterly QoQ to annualized %). Use `"BR_GDP_QOQ"`.
- `r_real`: r_nominal - focus_ipca_12m (real Selic, stripped of inflation expectations)
- `r_g_spread`: r_real - g_real (positive = debt-stabilizing r > g creates fiscal drag)
- `focus_ipca_12m`: 12M ahead Focus median from data["focus"] (series `"FOCUS-IPCA-12M"`)

CB credibility proxy (per locked CONTEXT.md):
- `focus_ipca_12m_abs_dev`: abs(focus_ipca_12m - 3.0) — deviation from 3.0% target
- `cb_credibility_zscore`: z-score of focus_ipca_12m_abs_dev over trailing 36M history. Use rolling mean/std from data["focus"] history.

Private keys for model classes (follow Phase 8 _-prefix convention):
- `features["_dsa_raw_data"]`: dict with scalar keys: `"debt_gdp"` (latest gross_debt_gdp), `"r_nominal"` (latest Selic%), `"g_real"` (annualized real GDP growth%), `"pb_gdp"` (latest primary_balance_gdp), `"r_real"` (real Selic after inflation), `"focus_ipca_12m"`. Also include `"g_focus"` = average of current-year and next-year Focus PIB series if available (from data["focus_pib_cy"] and data["focus_pib_ny"]), else fall back to g_real.
- `features["_pb_history"]`: pd.Series of monthly primary_balance_gdp values, indexed by date, full history from data["primary_balance"] and data["gdp_qoq"].
- `features["_focus_history"]`: pd.Series of monthly focus_ipca_12m values, indexed by date.
- `features["_as_of_date"]`: the as_of_date date object (same pattern as Phase 8 agents).

**Data keys expected in `data` dict (loaded by FiscalAgent.load_data):**
```
data["gross_debt"]      # DataFrame from get_macro_series("BR_GROSS_DEBT_GDP", ...)
data["net_debt"]        # DataFrame from get_macro_series("BR_NET_DEBT_GDP", ...)
data["primary_balance"] # DataFrame from get_macro_series("BR_PRIMARY_BALANCE", ...)
data["gdp_qoq"]         # DataFrame from get_macro_series("BR_GDP_QOQ", ...)
data["selic"]           # DataFrame from get_macro_series("BCB-432", ...)
data["focus"]           # DataFrame from get_macro_series("FOCUS-IPCA-12M", ...)
data["focus_pib_cy"]    # DataFrame from get_macro_series("BR_FOCUS_PIB_{YEAR}_MEDIAN", current year) — may be None/empty
data["focus_pib_ny"]    # DataFrame from get_macro_series("BR_FOCUS_PIB_{YEAR}_MEDIAN", next year) — may be None/empty
data["di_curve"]        # dict from get_curve("DI", as_of_date) — {tenor_days: rate}
```

**Part C — Create `src/agents/fiscal_agent.py`:**

Create the full file with all 3 model classes and FiscalAgent:

**DebtSustainabilityModel**:
```python
class DebtSustainabilityModel:
    """IMF-style Debt Sustainability Analysis — 4-scenario, 5Y projection.

    Formula: d_{t+1} = d_t * (1 + r) / (1 + g) - pb
    Scenarios: baseline, stress (+200bps r, -1pp g, -0.5pp pb),
               adjustment (+1.5pp pb), tailwind (-100bps r, +1pp g).
    """
    SIGNAL_ID = "FISCAL_BR_DSA"
    HORIZON = 5       # 5-year projection
    MIN_OBS = 12      # months of data required (graceful degradation for early backtest)
    THRESHOLD = 5.0   # pp change in terminal debt/GDP to trigger signal

    SCENARIOS = {
        "baseline":   {"r_adj": 0.0,  "g_adj": 0.0,  "pb_adj":  0.0},
        "stress":     {"r_adj": 2.0,  "g_adj": -1.0, "pb_adj": -0.5},
        "adjustment": {"r_adj": 0.0,  "g_adj": 0.0,  "pb_adj":  1.5},
        "tailwind":   {"r_adj": -1.0, "g_adj": 1.0,  "pb_adj":  0.0},
    }
```

`run(features: dict, as_of_date: date) -> AgentSignal`:

Inner helper:
```python
def _no_signal(reason: str = "") -> AgentSignal:
    return AgentSignal(
        signal_id=self.SIGNAL_ID, agent_id="fiscal_agent",
        timestamp=datetime.utcnow(), as_of_date=as_of_date,
        direction=SignalDirection.NEUTRAL, strength=SignalStrength.NO_SIGNAL,
        confidence=0.0, value=0.0, horizon_days=252 * HORIZON,
        metadata={"reason": reason},
    )
```

```python
def _project_debt_path(d0, r, g, pb, horizon=5):
    """Project debt/GDP ratio for horizon years.
    d_{t+1} = d_t * (1+r/100) / (1+g/100) - pb/100
    """
    path = [d0]
    for _ in range(horizon):
        d_next = path[-1] * (1 + r / 100) / (1 + g / 100) - pb / 100
        path.append(d_next)
    return path  # list of length horizon+1
```

Implementation:
- Read from `features["_dsa_raw_data"]`. If None or any of `debt_gdp`, `r_nominal`, `g_real`, `pb_gdp` is NaN → return `_no_signal("missing_data")`.
- Check `features["_pb_history"]` length >= MIN_OBS → else return `_no_signal("insufficient_history")`.
- Extract: `d0 = features["_dsa_raw_data"]["debt_gdp"]`, `r_baseline = features["_dsa_raw_data"]["r_real"]`, `g_baseline = features["_dsa_raw_data"].get("g_focus") or features["_dsa_raw_data"]["g_real"]`, `pb = features["_dsa_raw_data"]["pb_gdp"]`.
- For r_baseline: use DI 5Y rate from di_curve if available (di_curve = `features.get("_di_curve", {})`, 5Y tenor ≈ 1825 days — find closest tenor to 1825d). Strip inflation: `r_baseline_real = di_5y - features["_dsa_raw_data"]["focus_ipca_12m"]`. Fall back to `features["_dsa_raw_data"]["r_real"]` if DI curve missing.
- Run 4 scenarios: for each `name, params` in `SCENARIOS.items()`: `path = _project_debt_path(d0, r_baseline_real + params["r_adj"], g_baseline + params["g_adj"], pb + params["pb_adj"])`. Store `terminal = path[-1]`, `delta = terminal - d0`.
- **Signal direction (Claude's discretion — baseline-as-primary approach):** `baseline_delta = scenarios["baseline"].delta`. If baseline_delta > THRESHOLD → direction LONG (rising debt = BRL bearish fiscal stress). If baseline_delta < -THRESHOLD → direction SHORT (debt declining = BRL-positive). Else NEUTRAL.
- **Confidence from scenario consensus:** Count how many of 4 scenarios show stabilizing (delta <= 0). Confidence mapping: 4/4→1.0, 3/4→0.70, 2/4→0.40, 1/4→0.20, 0/4→0.05.
- `value = round(baseline_delta, 4)` (5Y baseline debt change in pp).
- `strength = classify_strength(confidence)`.
- `horizon_days = 252 * HORIZON`.
- `metadata = {"d0": d0, "baseline_terminal": baseline_path[-1], "scenarios": {name: {"terminal": p[-1], "delta": p[-1]-d0} for name, p in all_paths.items()}, "r_baseline_real": r_baseline_real, "g_baseline": g_baseline, "pb": pb}`.

**FiscalImpulseModel**:
```python
class FiscalImpulseModel:
    """Fiscal impulse as 12M change in primary balance/GDP, z-scored.

    Direction: positive z (pb improving over 12M) = fiscal contraction = SHORT USDBRL.
    Negative z (pb deteriorating over 12M) = fiscal expansion = LONG USDBRL.
    """
    SIGNAL_ID = "FISCAL_BR_IMPULSE"
    Z_FIRE = 1.0      # |z| threshold to fire signal
    ROLL_WINDOW = 36  # months for z-score mean/std
    MIN_OBS = 24      # minimum pb_history length
```

`run(features: dict, as_of_date: date) -> AgentSignal`:
- Inner `_no_signal(reason)` same pattern.
- `pb_history = features.get("_pb_history")`. If None or len < MIN_OBS → `_no_signal("insufficient_data")`.
- `pb_12m_change = pb_history.diff(12).dropna()`. If empty → `_no_signal("insufficient_diff_data")`.
- Compute z-score: `rolling_mean = pb_12m_change.rolling(ROLL_WINDOW).mean()`, `rolling_std = pb_12m_change.rolling(ROLL_WINDOW).std()`. Latest: `z = (pb_12m_change.iloc[-1] - rolling_mean.iloc[-1]) / rolling_std.iloc[-1]`. If rolling_std is 0 or NaN → `_no_signal("zero_variance")`.
- Direction: `z > Z_FIRE` → SHORT (pb improving = fiscal contraction = BRL positive); `z < -Z_FIRE` → LONG (pb deteriorating = expansion = BRL bearish). Else NEUTRAL.
- `confidence = min(1.0, abs(z) / 2.0)` (scales 0→1 over ±2 z-score). If NEUTRAL: confidence = 0.0.
- `strength = classify_strength(confidence)`.
- `value = round(float(z), 4)`.
- `horizon_days = 126` (6M, fiscal impulse is a medium-term signal).
- `metadata = {"pb_12m_change": float(pb_12m_change.iloc[-1]), "z_score": float(z), "roll_window": ROLL_WINDOW}`.

**FiscalDominanceRisk**:
```python
class FiscalDominanceRisk:
    """Composite fiscal dominance risk score (0-100) from 4 components.

    Components and weights (locked in CONTEXT.md):
      debt_level    0.35  — gross debt/GDP absolute level
      r_g_spread    0.30  — r-g: positive and high = destabilizing
      pb_trend      0.20  — 12M trend in primary balance (deteriorating = bad)
      cb_credibility 0.15 — |Focus 12M - 3.0%| deviation from target

    Thresholds (locked in CONTEXT.md):
      0-33  → LOW risk   → SHORT USDBRL (BRL-positive fiscal conditions)
      33-66 → MODERATE   → NEUTRAL
      66-100 → HIGH risk  → LONG USDBRL (fiscal stress = BRL weakness)
    """
    SIGNAL_ID = "FISCAL_BR_DOMINANCE_RISK"

    WEIGHTS = {
        "debt_level":     0.35,
        "r_g_spread":     0.30,
        "pb_trend":       0.20,
        "cb_credibility": 0.15,
    }

    # Sub-score normalization anchors (Claude's discretion):
    # debt_level:    60% GDP -> 50pts; 90% GDP -> 100pts; 30% GDP -> 0pts
    # r_g_spread:    r-g=0 -> 50pts; r-g=+5 -> 100pts; r-g=-5 -> 0pts
    # pb_trend:      12M pb change of +1pp GDP -> 0pts; -1pp -> 100pts (deterioration = bad)
    # cb_credibility: |focus-3.0|=0 -> 0pts; |deviation|=3pp -> 100pts
```

`run(features: dict, as_of_date: date) -> AgentSignal`:
- Inner `_no_signal(reason)` same pattern.
- Compute subscores (each clamped 0-100):
  - `debt_score = clamp((gross_debt_gdp - 30) / (90 - 30) * 100, 0, 100)` — where `gross_debt_gdp = features.get("gross_debt_gdp", np.nan)`.
  - `rg_score = clamp((r_g_spread + 5) / 10 * 100, 0, 100)` — where `r_g_spread = features.get("r_g_spread", np.nan)`.
  - `pb_score = clamp((-pb_12m_change + 1) / 2 * 100, 0, 100)` — where `pb_12m_change = features.get("pb_12m_change", np.nan)`. Positive change (improving) = low score (0); negative (deteriorating) = high score (100). The formula: `(-x + 1) / 2 * 100` gives 0 at x=+1 (1pp improvement) and 100 at x=-1 (1pp deterioration).
  - `cred_score = clamp(features.get("focus_ipca_12m_abs_dev", np.nan) / 3.0 * 100, 0, 100)`.
- If any 3 of 4 subscores are NaN → `_no_signal("insufficient_features")`.
- For NaN subscores, substitute 50 (neutral midpoint) — partial signal is still valuable.
- `composite = sum(score * w for score, w in zip(subscores, WEIGHTS.values()) if not np.isnan(score))` renormalized by sum of available weights.
- Map to direction: composite < 33 → SHORT; composite > 66 → LONG; else NEUTRAL.
- `confidence = abs(composite - 50) / 50` (0 at midpoint, 1 at extremes). If NEUTRAL: confidence = 0.2 (low but not zero).
- `strength = classify_strength(confidence)`.
- `value = round(composite, 2)`.
- `horizon_days = 252`.
- `metadata = {"composite_score": round(composite, 2), "subscores": {"debt_level": debt_score, "r_g_spread": rg_score, "pb_trend": pb_score, "cb_credibility": cred_score}, "thresholds": {"low": 33, "high": 66}}`.

**FiscalAgent class**:
```python
class FiscalAgent(BaseAgent):
    AGENT_ID = "fiscal_agent"
    AGENT_NAME = "Fiscal Agent"

    def __init__(self, loader: PointInTimeDataLoader) -> None:
        super().__init__(self.AGENT_ID, self.AGENT_NAME)
        self.loader = loader
        self.feature_engine = FiscalFeatureEngine()
        self.dsa_model = DebtSustainabilityModel()
        self.impulse_model = FiscalImpulseModel()
        self.dominance_model = FiscalDominanceRisk()
```

`load_data(as_of_date: date) -> dict`: Use self.loader — wrap each call in try/except returning None on failure:
- `data["gross_debt"] = self.loader.get_macro_series("BR_GROSS_DEBT_GDP", as_of_date, lookback_days=5475)` (15Y for DSA history)
- `data["net_debt"] = self.loader.get_macro_series("BR_NET_DEBT_GDP", as_of_date, lookback_days=5475)`
- `data["primary_balance"] = self.loader.get_macro_series("BR_PRIMARY_BALANCE", as_of_date, lookback_days=5475)`
- `data["gdp_qoq"] = self.loader.get_macro_series("BR_GDP_QOQ", as_of_date, lookback_days=5475)`
- `data["selic"] = self.loader.get_macro_series("BCB-432", as_of_date, lookback_days=5475)`
- `data["focus"] = self.loader.get_macro_series("FOCUS-IPCA-12M", as_of_date, lookback_days=5475)`
- For Focus PIB: build current year and next year codes dynamically: `cy = as_of_date.year`, `ny = cy + 1`. Load `f"BR_FOCUS_PIB_{cy}_MEDIAN"` and `f"BR_FOCUS_PIB_{ny}_MEDIAN"`. Store as `data["focus_pib_cy"]` and `data["focus_pib_ny"]`.
- `data["di_curve"] = self.loader.get_curve("DI", as_of_date)`

`compute_features(data: dict) -> dict`: call `features = self.feature_engine.compute(data, as_of_date)`. Note: since compute() needs as_of_date, store it via `data["_as_of_date"] = as_of_date` in load_data before calling compute_features, OR override compute_features to pass as_of_date explicitly. Pattern: `features = self.feature_engine.compute(data, data.get("_as_of_date"))`.

`run_models(features: dict) -> list[AgentSignal]`:
```python
def run_models(self, features: dict) -> list[AgentSignal]:
    as_of_date = features["_as_of_date"]
    signals = []
    dsa_sig = self.dsa_model.run(features, as_of_date)
    signals.append(dsa_sig)
    impulse_sig = self.impulse_model.run(features, as_of_date)
    signals.append(impulse_sig)
    dominance_sig = self.dominance_model.run(features, as_of_date)
    signals.append(dominance_sig)
    # Composite (all 3 BR signals, equal-weight with conflict dampening)
    signals.append(self._build_composite(signals, as_of_date))
    return signals
```

`_build_composite(sub_signals, as_of_date)`: Follow exact MonetaryPolicyAgent._build_composite pattern:
- Signal ID: `"FISCAL_BR_COMPOSITE"`. Agent ID: `"fiscal_agent"`.
- Filter to active (non-NO_SIGNAL, non-NEUTRAL) signals.
- If no active signals: return NO_SIGNAL composite.
- Equal weights (1/3 each) since all 3 signals are independent fiscal indicators.
- Renormalize weights to active signals only.
- Plurality vote (LONG vs SHORT). Conflict dampening 0.70 when any active signal disagrees with plurality.
- `composite_confidence = sum(sig.confidence * w for sig, w in norm_weights) * dampening`.
- `strength = classify_strength(composite_confidence)`.
- `metadata = {"weights": "equal_1/3", "dampening": dampening, "n_active": len(active)}`.

`generate_narrative(signals, features)`: Return a formatted string:
```
f"Fiscal Assessment ({as_of_date}): " + per-signal summary lines.
e.g. "DSA: {direction} (5Y debt path {baseline_delta:+.1f}pp). Impulse: {direction} (z={z:.2f}). Dominance Risk: {direction} (score={score:.0f}/100). Composite: {direction}."
```

Also update `src/agents/features/__init__.py`: Add conditional import for FiscalFeatureEngine:
```python
try:
    from src.agents.features.fiscal_features import FiscalFeatureEngine  # type: ignore[import]
    __all__ = [*__all__, "FiscalFeatureEngine"]
except ImportError:
    pass
```

All imports at the top of fiscal_agent.py:
```python
from __future__ import annotations
import logging
import numpy as np
import pandas as pd
from datetime import date, datetime
from typing import Any
from src.agents.base import AgentSignal, AgentReport, BaseAgent, classify_strength
from src.agents.data_loader import PointInTimeDataLoader
from src.agents.features.fiscal_features import FiscalFeatureEngine
from src.core.enums import SignalDirection, SignalStrength
```

Run `ruff check --fix src/agents/features/fiscal_features.py src/agents/fiscal_agent.py src/agents/features/__init__.py` after writing.
  </action>
  <verify>
    Run: `python -c "from src.agents.fiscal_agent import FiscalAgent, DebtSustainabilityModel, FiscalImpulseModel, FiscalDominanceRisk; print('all OK')"`
    Run: `python -c "from src.agents.features.fiscal_features import FiscalFeatureEngine; print(FiscalFeatureEngine)"`
    Run: `python -c "from src.agents.features import FiscalFeatureEngine; print('import OK')"`
    Run: `python -c "from src.connectors.cftc_cot import CftcCotConnector; print('6L' in CftcCotConnector.CONTRACT_CODES)"`
    Run: `ruff check src/agents/features/fiscal_features.py src/agents/fiscal_agent.py src/agents/features/__init__.py`
  </verify>
  <done>
    All 4 fiscal classes importable without error. FiscalFeatureEngine importable from src.agents.features.
    CftcCotConnector.CONTRACT_CODES includes "6L": "102741". ruff check passes zero violations.
    DebtSustainabilityModel.SIGNAL_ID == "FISCAL_BR_DSA". FiscalDominanceRisk.SIGNAL_ID == "FISCAL_BR_DOMINANCE_RISK".
  </done>
</task>

<task type="auto">
  <name>Task 2: Write unit tests for FiscalAgent models</name>
  <files>
    tests/test_fiscal_agent.py
  </files>
  <action>
Create `tests/test_fiscal_agent.py` with unit tests using synthetic features dicts — no database required. Follow the exact pattern from tests/test_monetary_agent.py (MagicMock loader, synthetic DataFrames/dicts, no DB imports).

**Test file imports:**
```python
from __future__ import annotations

import numpy as np
import pandas as pd
import pytest
from datetime import date, datetime
from unittest.mock import MagicMock

from src.agents.fiscal_agent import (
    FiscalAgent,
    DebtSustainabilityModel,
    FiscalImpulseModel,
    FiscalDominanceRisk,
)
from src.agents.features.fiscal_features import FiscalFeatureEngine
from src.core.enums import SignalDirection, SignalStrength
```

Helper to build a synthetic AgentSignal:
```python
from src.agents.base import AgentSignal

def make_signal(signal_id, direction, strength, confidence=0.7):
    return AgentSignal(
        signal_id=signal_id, agent_id="fiscal_agent",
        timestamp=datetime.utcnow(), as_of_date=date(2024, 1, 31),
        direction=direction, strength=strength, confidence=confidence,
        value=1.0, horizon_days=252,
    )
```

**Tests to implement (12+ tests):**

1. `test_fiscal_feature_engine_keys`:
   - Build synthetic data dict: `gross_debt` DataFrame (60 monthly rows, value=85.0), `primary_balance` DataFrame (60 monthly rows, value=-200000.0 BRL bn), `gdp_qoq` DataFrame (60 quarterly rows, value=0.5), `selic` DataFrame (60 monthly rows, value=13.75), `focus` DataFrame (60 monthly rows, value=4.5), `net_debt` DataFrame (60 monthly rows, value=62.0), `di_curve` empty dict, `focus_pib_cy` None, `focus_pib_ny` None.
   - Call `FiscalFeatureEngine().compute(data, date(2024, 1, 31))`.
   - Assert all required scalar keys present: `["gross_debt_gdp", "net_debt_gdp", "r_g_spread", "r_real", "focus_ipca_12m", "focus_ipca_12m_abs_dev"]`.
   - Assert `"_dsa_raw_data"` key present and is a dict.
   - Assert `"_pb_history"` key present and is a pd.Series.
   - Assert `"_as_of_date"` == date(2024, 1, 31).
   - Assert `features["focus_ipca_12m_abs_dev"] == pytest.approx(abs(4.5 - 3.0), abs=0.01)`.

2. `test_dsa_rising_debt_long`:
   - Build `_dsa_raw_data` dict: `debt_gdp=85.0, r_real=6.5, g_real=1.5, pb_gdp=-1.0, focus_ipca_12m=4.5, g_focus=1.5`.
   - Build `_pb_history` as pd.Series with 24 values.
   - Build `_di_curve` as empty dict.
   - Call `DebtSustainabilityModel().run(features, date(2024, 1, 31))`.
   - Assert signal.direction == SignalDirection.LONG (r_real=6.5 > g_real=1.5 = positive r-g, plus primary deficit → debt rising).
   - Assert signal.signal_id == "FISCAL_BR_DSA".
   - Assert signal.horizon_days == 252 * 5.

3. `test_dsa_declining_debt_short`:
   - `_dsa_raw_data`: `debt_gdp=60.0, r_real=2.0, g_real=4.0, pb_gdp=2.0` (g > r, plus surplus → debt shrinks rapidly).
   - Assert signal.direction == SignalDirection.SHORT.

4. `test_dsa_stable_debt_neutral`:
   - `_dsa_raw_data`: `debt_gdp=75.0, r_real=3.0, g_real=3.0, pb_gdp=0.0` (r=g, pb=0 → debt stable, near-zero delta).
   - Assert signal.direction == SignalDirection.NEUTRAL (delta close to 0, below THRESHOLD=5pp).

5. `test_dsa_insufficient_data_no_signal`:
   - `_dsa_raw_data`: all NaN values.
   - Assert signal.strength == SignalStrength.NO_SIGNAL.

6. `test_dsa_min_obs_guard`:
   - `_pb_history` with only 5 values (< MIN_OBS=12).
   - Assert signal.strength == SignalStrength.NO_SIGNAL.
   - Assert "insufficient_history" in signal.metadata.get("reason", "").

7. `test_fiscal_impulse_expansionary_long`:
   - Build `_pb_history`: pd.Series of 60 monthly values. Make last 12M values clearly lower than prior 12M (fiscal expansion: pb deteriorating).
   - Use values: first 36 months at 1.0, last 24 months declining to -0.5. The 12M change of last obs should be clearly negative.
   - Assert signal.direction == SignalDirection.LONG (fiscal expansion = BRL bearish).
   - Assert signal.signal_id == "FISCAL_BR_IMPULSE".

8. `test_fiscal_impulse_contractionary_short`:
   - `_pb_history` with rising values (last 12M improvement).
   - Assert signal.direction == SignalDirection.SHORT.

9. `test_fiscal_impulse_no_signal_insufficient_data`:
   - `_pb_history` with only 10 values.
   - Assert signal.strength == SignalStrength.NO_SIGNAL.

10. `test_dominance_risk_low_score_short`:
    - features: `gross_debt_gdp=40.0` (low debt), `r_g_spread=-2.0` (r < g = stabilizing), `pb_12m_change=1.0` (improving), `focus_ipca_12m_abs_dev=0.2` (well anchored).
    - Expected composite < 33 → SHORT direction.
    - Assert signal.direction == SignalDirection.SHORT.
    - Assert signal.value < 33.

11. `test_dominance_risk_high_score_long`:
    - features: `gross_debt_gdp=88.0` (high debt), `r_g_spread=5.0` (highly destabilizing), `pb_12m_change=-1.5` (deteriorating), `focus_ipca_12m_abs_dev=3.0` (severely unanchored).
    - Expected composite > 66 → LONG direction.
    - Assert signal.direction == SignalDirection.LONG.
    - Assert signal.value > 66.
    - Assert "composite_score" in signal.metadata.

12. `test_dominance_risk_signal_id`:
    - Any valid features dict.
    - Assert signal.signal_id == "FISCAL_BR_DOMINANCE_RISK".

13. `test_fiscal_composite_conflict_dampening`:
    - Build 3 signals: DSA=LONG, Impulse=SHORT, DominanceRisk=LONG.
    - Instantiate `FiscalAgent(loader=MagicMock())` and call `_build_composite(signals, date(2024,1,31))`.
    - Assert composite.direction == SignalDirection.LONG (2 LONG vs 1 SHORT = plurality LONG).
    - Assert composite.metadata["dampening"] == pytest.approx(0.70, abs=0.01) (conflict detected: 1 SHORT disagrees).
    - Assert composite.signal_id == "FISCAL_BR_COMPOSITE".

14. `test_fiscal_composite_unanimous`:
    - 3 LONG signals.
    - Assert composite.direction == SignalDirection.LONG.
    - Assert composite.metadata["dampening"] == pytest.approx(1.0, abs=0.01).

Use `pytest.approx` for float comparisons. Build synthetic pd.Series for _pb_history with DatetimeIndex (monthly frequency) using `pd.date_range("2020-01-31", periods=60, freq="ME")`.

After writing tests, run `pytest tests/test_fiscal_agent.py -v --tb=short` and fix any bugs in fiscal_agent.py or fiscal_features.py inline (do not defer). Fix until all 14+ tests pass.

Run `ruff check tests/test_fiscal_agent.py` before finishing.
  </action>
  <verify>
    Run: `pytest tests/test_fiscal_agent.py -v --tb=short 2>&1 | tail -30`
    Expected: 14+ tests pass, 0 failed.
    Run: `ruff check tests/test_fiscal_agent.py`
  </verify>
  <done>
    pytest reports 14+ passed, 0 failed, no database required.
    DebtSustainabilityModel: LONG for rising debt (r-g>0, deficit), SHORT for declining debt, NEUTRAL for stable, NO_SIGNAL for insufficient data.
    FiscalImpulseModel: LONG for expansion (pb worsening), SHORT for contraction (pb improving).
    FiscalDominanceRisk: LONG (score>66), SHORT (score<33), composite_score in metadata.
    FiscalAgent composite: dampening=0.70 with conflict, 1.0 when unanimous.
    ruff check passes zero violations.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.agents.fiscal_agent import FiscalAgent, DebtSustainabilityModel, FiscalImpulseModel, FiscalDominanceRisk"` — clean import
2. `python -c "from src.agents.features import FiscalFeatureEngine, MonetaryFeatureEngine, InflationFeatureEngine"` — all 3 importable from features package
3. `python -c "from src.connectors.cftc_cot import CftcCotConnector; assert '6L' in CftcCotConnector.CONTRACT_CODES"` — BRL futures present
4. `pytest tests/test_fiscal_agent.py -v` — all 14+ tests pass
5. `ruff check src/agents/features/fiscal_features.py src/agents/fiscal_agent.py src/agents/features/__init__.py tests/test_fiscal_agent.py` — zero violations
6. `DebtSustainabilityModel.HORIZON == 5` and `DebtSustainabilityModel.THRESHOLD == 5.0`
7. `FiscalDominanceRisk.WEIGHTS["debt_level"] == 0.35` (locked weight confirmed)
</verification>

<success_criteria>
- FiscalFeatureEngine.compute() returns dict with gross_debt_gdp, net_debt_gdp, r_g_spread, r_real, focus_ipca_12m_abs_dev, and private keys _dsa_raw_data, _pb_history, _as_of_date
- DebtSustainabilityModel uses locked formula d_{t+1} = d_t*(1+r)/(1+g) - pb, 4 scenarios as specified, baseline-as-primary signal, MIN_OBS=12 guard
- FiscalImpulseModel fires LONG for deteriorating pb (fiscal expansion), SHORT for improving pb, NO_SIGNAL when < 24 obs
- FiscalDominanceRisk produces 0-100 composite from 4 components (weights 0.35/0.30/0.20/0.15), thresholds 33/66 locked
- FiscalAgent produces 4 signals (DSA + Impulse + DominanceRisk + Composite) in run_models()
- FISCAL_BR_COMPOSITE uses equal weights with 0.70 conflict dampening
- CftcCotConnector.CONTRACT_CODES now includes "6L": "102741" (Brazilian Real)
- All 14+ fiscal unit tests pass without DB
- All files pass ruff check with zero violations
</success_criteria>

<output>
After completion, create `.planning/phases/09-fiscal-fx-equilibrium-agents/09-01-SUMMARY.md`
</output>
