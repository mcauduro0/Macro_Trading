---
phase: 27-redis-cache-dagster-pms-go-live-verification
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestration/assets_pms.py
  - src/orchestration/definitions.py
autonomous: true
requirements:
  - PMS-DAG-01
  - PMS-DAG-02

must_haves:
  truths:
    - "Dagster PMS assets exist for MTM, proposals, morning pack, and attribution"
    - "Two scheduled runs: EOD (after market close) and pre-open (06:00 BRT)"
    - "Each pipeline step writes results to Redis after DB persistence"
    - "PMS assets are visible in Dagster UI under pms group"
  artifacts:
    - path: "src/orchestration/assets_pms.py"
      provides: "4 PMS Dagster asset definitions with Redis cache warming"
      contains: "@asset"
    - path: "src/orchestration/definitions.py"
      provides: "Updated Definitions with PMS assets, jobs, and schedules"
      contains: "pms_eod_job"
  key_links:
    - from: "src/orchestration/assets_pms.py"
      to: "src/pms/position_manager.py"
      via: "PositionManager.mark_to_market() call in MTM asset"
      pattern: "mark_to_market"
    - from: "src/orchestration/assets_pms.py"
      to: "src/pms/morning_pack.py"
      via: "MorningPackService.generate() call in morning pack asset"
      pattern: "generate"
    - from: "src/orchestration/assets_pms.py"
      to: "src/cache/pms_cache.py"
      via: "PMSCache write-through after each asset completes"
      pattern: "set_book|set_morning_pack|set_risk|set_attribution"
    - from: "src/orchestration/definitions.py"
      to: "src/orchestration/assets_pms.py"
      via: "Import and register PMS assets in Definitions"
      pattern: "from src.orchestration.assets_pms import"
---

<objective>
Dagster PMS daily pipeline with 4 assets integrated into existing orchestration, running on two schedules.

Purpose: Automate the daily PMS workflow so the manager sees fresh data (MTM, proposals, morning pack, attribution) when they log in each morning. Two schedules: EOD run (market close, ~18:00 BRT / 21:00 UTC) for MTM + attribution, and pre-open run (06:00 BRT / 09:00 UTC) for morning pack + proposals. Each step warms the Redis cache after DB persistence per locked decision.

Output: `src/orchestration/assets_pms.py` with 4 asset definitions, updated `definitions.py` with PMS jobs and schedules.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

@src/orchestration/definitions.py
@src/orchestration/assets_bronze.py
@src/pms/__init__.py
@src/cache/pms_cache.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: PMS Dagster assets with cache warming</name>
  <files>src/orchestration/assets_pms.py</files>
  <action>
Create `src/orchestration/assets_pms.py` with 4 Dagster asset definitions following the existing pattern from `assets_bronze.py` (no `from __future__ import annotations`, use asyncio.run for async bridges).

All assets in `group_name="pms"` and use `RetryPolicy(max_retries=2, delay=30)` for transient failures.

**Asset 1: `pms_mark_to_market`**
- No upstream Dagster deps (runs independently against current market data)
- Description: "Mark-to-market all open positions using latest prices"
- Implementation:
  1. Import PositionManager, instantiate
  2. Call `position_manager.mark_to_market()` via asyncio.run or sync wrapper
  3. Get updated book via `position_manager.get_book()`
  4. Warm Redis cache: create PMSCache from get_redis(), call `set_book(book_data)`
  5. Log context.log.info with positions_updated count and total_pnl
  6. Return Output with metadata (positions_updated, total_unrealized_pnl)

**Asset 2: `pms_trade_proposals`**
- Deps: `["pms_mark_to_market"]` (needs fresh MTM before generating proposals)
- Description: "Generate trade proposals from aggregated signals"
- Implementation:
  1. Import TradeWorkflowService, instantiate
  2. Call `trade_workflow.generate_proposals_from_signals()`
  3. Log proposals_count
  4. Return Output with metadata (proposals_generated)

**Asset 3: `pms_morning_pack`**
- Deps: `["pms_mark_to_market", "pms_trade_proposals"]` (needs MTM + proposals)
- Description: "Generate daily morning pack briefing"
- Implementation:
  1. Import MorningPackService, instantiate
  2. Call `morning_pack.generate()` for today's date
  3. Warm Redis cache: `set_morning_pack(today_str, briefing_data)`
  4. Log sections_generated count
  5. Return Output with metadata (date, sections_count)

**Asset 4: `pms_performance_attribution`**
- Deps: `["pms_mark_to_market"]` (needs fresh MTM for P&L data)
- Description: "Compute daily performance attribution"
- Implementation:
  1. Import PerformanceAttributionEngine, instantiate
  2. Call `attribution.compute()` for today's date
  3. Warm Redis cache: `set_attribution("daily_" + today_str, attribution_data)`
  4. Log dimensions computed
  5. Return Output with metadata (date, total_pnl)

Each asset wraps its async calls in a sync function using asyncio.run() for Dagster compatibility (matching the pattern from assets_bronze.py). Each asset has error handling: try/except that logs the error and re-raises so Dagster retry policy kicks in.
  </action>
  <verify>
Run: `python -c "from src.orchestration.assets_pms import pms_mark_to_market, pms_trade_proposals, pms_morning_pack, pms_performance_attribution; print('All 4 PMS assets importable')"` -- should print success message.
  </verify>
  <done>4 PMS Dagster assets created with correct dependency chain, cache warming after each step, retry policy, and pms group name</done>
</task>

<task type="auto">
  <name>Task 2: Register PMS assets in Definitions with two scheduled jobs</name>
  <files>src/orchestration/definitions.py</files>
  <action>
Update `src/orchestration/definitions.py` to add PMS assets, jobs, and schedules.

**Imports**: Add at the top (after existing imports):
```python
from src.orchestration.assets_pms import (
    pms_mark_to_market,
    pms_trade_proposals,
    pms_morning_pack,
    pms_performance_attribution,
)
```

**PMS asset list**: Add after `all_assets`:
```python
pms_assets = [
    pms_mark_to_market,
    pms_trade_proposals,
    pms_morning_pack,
    pms_performance_attribution,
]
```

**Update `all_assets`**: Extend with PMS assets (add comment `# PMS (4)` and append all 4).

**EOD Job** (after market close):
```python
pms_eod_job = define_asset_job(
    name="pms_eod_pipeline",
    selection=[pms_mark_to_market, pms_performance_attribution],
    description="PMS End-of-Day: MTM all positions + compute attribution",
)
```

**Pre-Open Job** (morning):
```python
pms_preopen_job = define_asset_job(
    name="pms_preopen_pipeline",
    selection=pms_assets,  # All 4 -- MTM first, then proposals + pack + attribution
    description="PMS Pre-Open: MTM + generate proposals + morning pack + attribution",
)
```

**Schedules** (per locked decision: two runs):
```python
# EOD: 21:00 UTC = 18:00 BRT, weekdays
pms_eod_schedule = ScheduleDefinition(
    job=pms_eod_job,
    cron_schedule="0 21 * * 1-5",
    name="pms_eod_schedule",
)

# Pre-open: 09:00 UTC = 06:00 BRT, weekdays
pms_preopen_schedule = ScheduleDefinition(
    job=pms_preopen_job,
    cron_schedule="0 9 * * 1-5",
    name="pms_preopen_schedule",
)
```

**Update Definitions**: Add PMS schedules and jobs:
```python
defs = Definitions(
    assets=all_assets,  # Now includes PMS assets
    schedules=[daily_schedule, pms_eod_schedule, pms_preopen_schedule],
    jobs=[daily_pipeline_job, bronze_job, pms_eod_job, pms_preopen_job],
)
```

Update module docstring to mention 26 total assets (22 + 4 PMS).
  </action>
  <verify>
Run: `python -c "from src.orchestration.definitions import defs; print(f'Assets: {len(defs.get_all_asset_keys())}, Jobs: {len(list(defs.get_all_job_defs()))}, Schedules: {len(list(defs.get_all_schedule_defs()))}')"` -- should show 26 assets, 4 jobs, 3 schedules.
  </verify>
  <done>definitions.py updated with 26 total assets (22 existing + 4 PMS), 4 jobs (daily_pipeline, bronze_ingest, pms_eod, pms_preopen), 3 schedules (daily, EOD, pre-open)</done>
</task>

</tasks>

<verification>
1. `python -c "from src.orchestration.assets_pms import pms_mark_to_market; print('OK')"` passes
2. `python -c "from src.orchestration.definitions import defs; print(len(defs.get_all_asset_keys()), 'assets')"` shows 26
3. PMS assets have correct dependency chain: proposals and morning_pack depend on MTM
4. Both EOD and pre-open schedules registered with weekday cron expressions
5. Each PMS asset includes Redis cache warming step
</verification>

<success_criteria>
- 4 PMS Dagster assets in pms group with dependency chain
- Two scheduled jobs: EOD (18:00 BRT) and pre-open (06:00 BRT)
- Each pipeline step writes to Redis after DB persistence
- definitions.py registers all PMS assets, jobs, and schedules
</success_criteria>

<output>
After completion, create `.planning/phases/27-redis-cache-dagster-pms-go-live-verification/27-02-SUMMARY.md`
</output>
