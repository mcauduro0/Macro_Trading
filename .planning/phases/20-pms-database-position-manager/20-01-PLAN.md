---
phase: 20-pms-database-position-manager
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/models/pms_models.py
  - src/core/models/__init__.py
  - alembic/versions/009_create_pms_tables.py
  - tests/test_pms_models.py
autonomous: true
requirements:
  - PMS-DB-01
  - PMS-DB-02
  - PMS-DB-03

must_haves:
  truths:
    - "5 PMS SQLAlchemy models exist with correct columns matching locked decisions"
    - "Alembic migration 009 creates all 5 tables with position_pnl_history as TimescaleDB hypertable"
    - "DecisionJournal has SHA256 content_hash column and DB-level immutability trigger"
    - "All 5 new models are importable from src.core.models"
    - "PortfolioPosition has dual notional (notional_brl, notional_usd) and full risk snapshot (dv01, delta, convexity, var_contribution, spread_duration)"
  artifacts:
    - path: "src/core/models/pms_models.py"
      provides: "5 PMS ORM models"
      contains: "class PortfolioPosition"
    - path: "alembic/versions/009_create_pms_tables.py"
      provides: "Migration creating 5 tables + hypertable + trigger"
      contains: "create_hypertable"
    - path: "src/core/models/__init__.py"
      provides: "Model re-exports for PMS"
      contains: "PortfolioPosition"
    - path: "tests/test_pms_models.py"
      provides: "Model unit tests"
      contains: "test_portfolio_position"
  key_links:
    - from: "src/core/models/pms_models.py"
      to: "src/core/models/base.py"
      via: "Base inheritance"
      pattern: "from .base import Base"
    - from: "src/core/models/__init__.py"
      to: "src/core/models/pms_models.py"
      via: "re-export"
      pattern: "from .pms_models import"
    - from: "alembic/versions/009_create_pms_tables.py"
      to: "portfolio_positions table"
      via: "op.create_table"
      pattern: "op.create_table.*portfolio_positions"
---

<objective>
Create 5 PMS SQLAlchemy models (PortfolioPosition, TradeProposal, DecisionJournal, DailyBriefing, PositionPnLHistory) and the Alembic migration that creates the corresponding tables, including TimescaleDB hypertable for position_pnl_history and a PostgreSQL trigger for DecisionJournal immutability.

Purpose: Establishes the database foundation for the entire v4.0 Portfolio Management System. All subsequent PMS services (PositionManager, TradeWorkflow, MorningPack) depend on these models.
Output: 5 ORM models in pms_models.py, migration 009, updated __init__.py, model tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/20-pms-database-position-manager/20-CONTEXT.md
@src/core/models/base.py
@src/core/models/__init__.py
@src/core/models/portfolio_state.py
@alembic/versions/008_create_portfolio_state_table.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create 5 PMS SQLAlchemy models in pms_models.py</name>
  <files>src/core/models/pms_models.py, src/core/models/__init__.py</files>
  <action>
Create `src/core/models/pms_models.py` with 5 SQLAlchemy 2.0 ORM models inheriting from Base (from .base import Base). Follow the Mapped[] type hints pattern used in portfolio_state.py and other models.

**1. PortfolioPosition** (table: `portfolio_positions`)
- `id`: BigInteger, primary_key, autoincrement
- `created_at`: DateTime(timezone=True), server_default=func.now()
- `updated_at`: DateTime(timezone=True), server_default=func.now(), onupdate=func.now()
- `instrument`: String(50), not null, indexed
- `asset_class`: String(30), not null (RATES, FX, INFLATION, CUPOM, SOVEREIGN, CROSS_ASSET)
- `direction`: String(10), not null (LONG, SHORT)
- `quantity`: Float, nullable (contracts for DI futures)
- `notional_brl`: Float, not null (source of truth per locked decision)
- `notional_usd`: Float, nullable (derived from PTAX at entry)
- `entry_price`: Float, not null
- `entry_date`: Date, not null
- `entry_fx_rate`: Float, nullable (USDBRL at entry for USD P&L computation)
- `current_price`: Float, nullable (updated on MTM)
- `unrealized_pnl_brl`: Float, nullable, default 0.0
- `unrealized_pnl_usd`: Float, nullable, default 0.0
- `realized_pnl_brl`: Float, nullable, default 0.0
- `realized_pnl_usd`: Float, nullable, default 0.0
- `transaction_cost_brl`: Float, nullable, default 0.0
- `is_open`: Boolean, not null, default True, indexed
- `closed_at`: DateTime(timezone=True), nullable
- `close_price`: Float, nullable
- Risk snapshot at entry (all nullable Float):
  - `entry_dv01`: DV01 for rates instruments
  - `entry_delta`: Delta for FX instruments
  - `entry_convexity`: Convexity for rates
  - `entry_var_contribution`: VaR contribution at entry
  - `entry_spread_duration`: Spread duration for credit
- `strategy_ids`: JSONB, nullable (list of strategy IDs linked to this position)
- `strategy_weights`: JSONB, nullable (dict of {strategy_id: conviction_weight} for attribution)
- `notes`: Text, nullable
- `metadata_json`: JSONB, nullable (extensible extra data)
- Indexes: on `instrument`, on `is_open`, composite on (`is_open`, `asset_class`)
- No composite PK needed (not a hypertable)

**2. TradeProposal** (table: `trade_proposals`)
- `id`: BigInteger, primary_key, autoincrement
- `created_at`: DateTime(timezone=True), server_default=func.now()
- `updated_at`: DateTime(timezone=True), server_default=func.now()
- `instrument`: String(50), not null
- `asset_class`: String(30), not null
- `direction`: String(10), not null
- `suggested_notional_brl`: Float, not null
- `suggested_quantity`: Float, nullable
- `conviction`: Float, not null (0.0 to 1.0)
- `signal_source`: String(100), nullable (strategy ID or "discretionary")
- `strategy_ids`: JSONB, nullable
- `rationale`: Text, nullable (LLM or template narrative)
- `risk_impact`: JSONB, nullable (pre-trade risk impact estimate)
- `status`: String(20), not null, default 'PENDING' (PENDING, APPROVED, REJECTED, MODIFIED, EXPIRED)
- `reviewed_by`: String(100), nullable
- `reviewed_at`: DateTime(timezone=True), nullable
- `execution_price`: Float, nullable
- `execution_notional_brl`: Float, nullable
- `position_id`: BigInteger, nullable (FK to portfolio_positions.id, set after execution)
- `notes`: Text, nullable
- `metadata_json`: JSONB, nullable
- Index on `status`

**3. DecisionJournal** (table: `decision_journal`)
- `id`: BigInteger, primary_key, autoincrement
- `created_at`: DateTime(timezone=True), server_default=func.now(), not null
- `entry_type`: String(30), not null (OPEN, CLOSE, MODIFY, REJECT, NOTE, SYSTEM_EVENT)
- `position_id`: BigInteger, nullable (FK to portfolio_positions.id)
- `proposal_id`: BigInteger, nullable (FK to trade_proposals.id)
- `instrument`: String(50), nullable
- `direction`: String(10), nullable
- `notional_brl`: Float, nullable
- `entry_price`: Float, nullable
- `manager_notes`: Text, nullable
- `system_notes`: Text, nullable
- `market_snapshot`: JSONB, nullable (key indicators: SELIC, USDBRL, VIX, DI rates)
- `portfolio_snapshot`: JSONB, nullable (AUM, leverage, VaR)
- `content_hash`: String(64), not null (SHA256 hex digest of content fields)
- `is_locked`: Boolean, not null, default True
- `metadata_json`: JSONB, nullable
- Index on `entry_type`, index on `position_id`, index on `created_at`

**4. DailyBriefing** (table: `daily_briefings`)
- `id`: BigInteger, primary_key, autoincrement
- `briefing_date`: Date, not null, unique
- `created_at`: DateTime(timezone=True), server_default=func.now()
- `market_snapshot`: JSONB, nullable
- `regime_assessment`: JSONB, nullable
- `agent_views`: JSONB, nullable
- `top_signals`: JSONB, nullable
- `signal_changes`: JSONB, nullable
- `portfolio_state`: JSONB, nullable
- `trade_proposals`: JSONB, nullable
- `risk_summary`: JSONB, nullable
- `macro_narrative`: Text, nullable
- `action_items`: JSONB, nullable
- `metadata_json`: JSONB, nullable

**5. PositionPnLHistory** (table: `position_pnl_history`)
- TimescaleDB hypertable. Composite PK on (id, snapshot_date).
- `id`: BigInteger, primary_key, autoincrement
- `snapshot_date`: Date, primary_key, not null
- `position_id`: BigInteger, not null (references portfolio_positions.id but NO FK constraint for hypertable compat)
- `instrument`: String(50), not null
- `mark_price`: Float, not null
- `unrealized_pnl_brl`: Float, not null
- `unrealized_pnl_usd`: Float, nullable
- `daily_pnl_brl`: Float, nullable
- `daily_pnl_usd`: Float, nullable
- `cumulative_pnl_brl`: Float, nullable
- `dv01`: Float, nullable (recomputed on MTM)
- `delta`: Float, nullable
- `var_contribution`: Float, nullable
- `fx_rate`: Float, nullable (current USDBRL for USD conversion)
- `is_manual_override`: Boolean, default False
- `metadata_json`: JSONB, nullable
- UniqueConstraint on (snapshot_date, position_id) as natural key
- segmentby=position_id for compression

Then update `src/core/models/__init__.py`:
- Import all 5 new models from `.pms_models`
- Add them to `__all__` list
- Update module docstring to reflect 20 model classes (15 existing + 5 new)
  </action>
  <verify>
Run: `python -c "from src.core.models import PortfolioPosition, TradeProposal, DecisionJournal, DailyBriefing, PositionPnLHistory; print('All 5 PMS models importable')"` passes without error. Verify each model has correct `__tablename__` attribute.
  </verify>
  <done>
5 PMS SQLAlchemy models defined in pms_models.py with all columns matching locked decisions (dual notional, risk snapshot, SHA256 hash, JSONB snapshots). All models importable from src.core.models.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration 009 with hypertable and immutability trigger, plus model tests</name>
  <files>alembic/versions/009_create_pms_tables.py, tests/test_pms_models.py</files>
  <action>
**Migration 009**: Create `alembic/versions/009_create_pms_tables.py` following the pattern from migration 008 (portfolio_state). Revision chain: down_revision = "h8i9j0k1l2m3" (the 008 revision ID). Use revision ID "i9j0k1l2m3n4".

The upgrade() function must:

1. Create `portfolio_positions` table with all columns from PortfolioPosition model. Use sa.BigInteger for id, sa.Boolean for is_open, sa.Float for numeric, sa.String for text, sa.Text for notes, JSONB for JSON fields. PrimaryKeyConstraint on id only (not hypertable). Add indexes:
   - Index on instrument
   - Index on is_open
   - Composite index on (is_open, asset_class)

2. Create `trade_proposals` table. Add FK to portfolio_positions.id for position_id column. Index on status.

3. Create `decision_journal` table. Add FKs to portfolio_positions.id and trade_proposals.id. Indexes on entry_type, position_id, created_at.

4. Create `daily_briefings` table. UniqueConstraint on briefing_date.

5. Create `position_pnl_history` table with composite PK on (id, snapshot_date) for TimescaleDB hypertable compatibility. UniqueConstraint on (snapshot_date, position_id). Then:
   ```sql
   SELECT create_hypertable('position_pnl_history', 'snapshot_date', migrate_data => true, chunk_time_interval => INTERVAL '90 days')
   ```
   Set compression:
   ```sql
   ALTER TABLE position_pnl_history SET (
     timescaledb.compress,
     timescaledb.compress_segmentby = 'position_id'
   )
   ```
   Add compression policy (compress after 60 days):
   ```sql
   SELECT add_compression_policy('position_pnl_history', INTERVAL '60 days')
   ```

6. Create PostgreSQL trigger for DecisionJournal immutability (locked decision: DB-level enforcement):
   ```sql
   CREATE OR REPLACE FUNCTION prevent_journal_modification()
   RETURNS TRIGGER AS $$
   BEGIN
     IF OLD.is_locked = TRUE THEN
       RAISE EXCEPTION 'Cannot modify or delete locked decision journal entry (id=%)', OLD.id;
     END IF;
     RETURN NEW;
   END;
   $$ LANGUAGE plpgsql;

   CREATE TRIGGER trg_decision_journal_immutable
   BEFORE UPDATE OR DELETE ON decision_journal
   FOR EACH ROW
   EXECUTE FUNCTION prevent_journal_modification();
   ```

The downgrade() function must reverse everything in correct order: drop trigger, drop function, remove compression policy, drop tables in reverse dependency order (position_pnl_history, daily_briefings, decision_journal, trade_proposals, portfolio_positions).

**Tests**: Create `tests/test_pms_models.py` with pytest tests that do NOT require a database:

1. `test_portfolio_position_tablename` -- assert __tablename__ == "portfolio_positions"
2. `test_portfolio_position_has_risk_snapshot_fields` -- verify entry_dv01, entry_delta, entry_convexity, entry_var_contribution, entry_spread_duration columns exist on the model
3. `test_portfolio_position_has_dual_notional` -- verify notional_brl and notional_usd columns
4. `test_trade_proposal_tablename` -- assert __tablename__ == "trade_proposals"
5. `test_trade_proposal_status_values` -- verify default status is conceptually PENDING (check column default)
6. `test_decision_journal_tablename` -- assert __tablename__ == "decision_journal"
7. `test_decision_journal_has_content_hash` -- verify content_hash column exists
8. `test_decision_journal_has_snapshots` -- verify market_snapshot and portfolio_snapshot JSONB columns
9. `test_daily_briefing_tablename` -- assert __tablename__ == "daily_briefings"
10. `test_position_pnl_history_tablename` -- assert __tablename__ == "position_pnl_history"
11. `test_position_pnl_history_composite_pk` -- verify both id and snapshot_date are in primary key
12. `test_all_models_in_init` -- import from src.core.models and verify all 5 PMS models present in module
13. `test_portfolio_position_repr` -- instantiate model and verify __repr__ works (add __repr__ to PortfolioPosition)

Use `inspect(ModelClass)` from sqlalchemy to check columns and primary keys where needed. Tests should verify schema definition, not runtime behavior.
  </action>
  <verify>
Run: `cd /home/user/Macro_Trading && python -m pytest tests/test_pms_models.py -v` -- all tests pass. Verify migration file exists and has correct revision chain.
  </verify>
  <done>
Alembic migration 009 creates 5 PMS tables with position_pnl_history as TimescaleDB hypertable (90-day chunks, compression after 60 days, segmentby=position_id). DecisionJournal has DB-level immutability trigger. 13+ model tests pass validating schema definitions.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.core.models import PortfolioPosition, TradeProposal, DecisionJournal, DailyBriefing, PositionPnLHistory"` succeeds
2. `python -m pytest tests/test_pms_models.py -v` all green
3. Migration file at alembic/versions/009_create_pms_tables.py with correct down_revision chain
4. PortfolioPosition has notional_brl and notional_usd (dual tracking)
5. PortfolioPosition has all 5 risk snapshot fields (entry_dv01, entry_delta, entry_convexity, entry_var_contribution, entry_spread_duration)
6. DecisionJournal has content_hash (String(64)), is_locked, market_snapshot, portfolio_snapshot
7. PositionPnLHistory has composite PK (id, snapshot_date) for hypertable
8. Migration includes prevent_journal_modification trigger function
</verification>

<success_criteria>
- 5 PMS models defined with all columns per locked decisions
- Migration 009 with hypertable, compression, and immutability trigger
- All models registered in __init__.py
- 13+ unit tests passing without database dependency
</success_criteria>

<output>
After completion, create `.planning/phases/20-pms-database-position-manager/20-01-SUMMARY.md`
</output>
