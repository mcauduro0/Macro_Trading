---
phase: 11-trading-strategies
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/strategies/__init__.py
  - src/strategies/base.py
  - src/strategies/rates_br_01_carry.py
  - src/strategies/rates_br_02_taylor.py
  - tests/test_strategies/__init__.py
  - tests/test_strategies/test_base.py
  - tests/test_strategies/test_rates_br_01.py
  - tests/test_strategies/test_rates_br_02.py
autonomous: true
requirements:
  - STRAT-01
  - STRAT-02
  - STRAT-03

must_haves:
  truths:
    - "BaseStrategy ABC enforces StrategyConfig and generate_signals(as_of_date) contract on all subclasses"
    - "signals_to_positions converts agent signals to StrategyPosition list respecting weight [-1,1], confidence [0,1], and position limits"
    - "RATES_BR_01 computes carry-to-risk at each DI curve tenor and goes long at optimal point when ratio exceeds threshold"
    - "RATES_BR_02 trades DI direction when gap between Taylor-implied rate and market pricing exceeds 100bps"
    - "Weight formula implements strength_base x confidence x max_size with STRONG=1.0, MODERATE=0.6, WEAK=0.3"
    - "NEUTRAL signals produce 50% scale-down of existing position weight"
  artifacts:
    - path: "src/strategies/base.py"
      provides: "BaseStrategy ABC, StrategyConfig, StrategyPosition dataclasses"
      exports: ["BaseStrategy", "StrategyConfig", "StrategyPosition"]
    - path: "src/strategies/rates_br_01_carry.py"
      provides: "RATES_BR_01 Carry & Roll-Down strategy"
      exports: ["RatesBR01CarryStrategy"]
    - path: "src/strategies/rates_br_02_taylor.py"
      provides: "RATES_BR_02 Taylor Rule Misalignment strategy"
      exports: ["RatesBR02TaylorStrategy"]
    - path: "tests/test_strategies/test_base.py"
      provides: "Tests for BaseStrategy ABC and constraint enforcement"
      min_lines: 60
  key_links:
    - from: "src/strategies/base.py"
      to: "src/agents/base.py"
      via: "imports AgentSignal, AgentReport for signal consumption"
      pattern: "from src\\.agents\\.base import"
    - from: "src/strategies/base.py"
      to: "src/core/enums.py"
      via: "imports SignalDirection, SignalStrength, AssetClass, Frequency"
      pattern: "from src\\.core\\.enums import"
    - from: "src/strategies/rates_br_01_carry.py"
      to: "src/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class RatesBR01CarryStrategy\\(BaseStrategy\\)"
    - from: "src/strategies/rates_br_02_taylor.py"
      to: "src/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class RatesBR02TaylorStrategy\\(BaseStrategy\\)"
---

<objective>
Create the BaseStrategy abstraction with StrategyConfig and StrategyPosition dataclasses, the signals_to_positions constraint enforcement engine, and two initial rates strategies: RATES_BR_01 (Carry & Roll-Down) and RATES_BR_02 (Taylor Rule Misalignment).

Purpose: Establish the strategy framework that all 8 trading strategies will inherit from, with locked signal-to-position mapping (weight = strength_base x confidence x max_size) and position limit enforcement. Deliver the first two strategies consuming agent signals and producing tradeable DI positions.

Output: src/strategies/ package with base.py, two strategy modules, and comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-trading-strategies/11-CONTEXT.md
@.planning/phases/07-agent-framework-data-loader/07-01-SUMMARY.md
@.planning/phases/07-agent-framework-data-loader/07-02-SUMMARY.md

# Key source files to reference
@src/agents/base.py        # AgentSignal, AgentReport, BaseAgent patterns
@src/agents/data_loader.py # PointInTimeDataLoader — strategies use this for data access
@src/core/enums.py         # SignalDirection, SignalStrength, AssetClass, Frequency
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BaseStrategy ABC with StrategyConfig, StrategyPosition, and constraint engine</name>
  <files>
    src/strategies/__init__.py
    src/strategies/base.py
    tests/test_strategies/__init__.py
    tests/test_strategies/test_base.py
  </files>
  <action>
Create `src/strategies/__init__.py` and `src/strategies/base.py`.

**StrategyConfig dataclass** (frozen=True):
- `strategy_id: str` — unique ID like "RATES_BR_01"
- `strategy_name: str` — human-readable name
- `asset_class: AssetClass` — from src.core.enums
- `instruments: list[str]` — tradeable instrument IDs (e.g. ["DI_PRE"])
- `rebalance_frequency: Frequency` — DAILY for all Phase 11 strategies
- `max_position_size: float` — max absolute weight per position (e.g. 1.0)
- `max_leverage: float` — max sum of absolute weights (e.g. 3.0)
- `stop_loss_pct: float` — stop loss in percentage (e.g. 0.05 = 5%)
- `take_profit_pct: float` — take profit in percentage (e.g. 0.10 = 10%)

**StrategyPosition dataclass**:
- `strategy_id: str` — source strategy
- `instrument: str` — instrument identifier
- `weight: float` — position weight in [-1, 1] (negative = short)
- `confidence: float` — signal confidence in [0, 1]
- `direction: SignalDirection` — LONG, SHORT, or NEUTRAL
- `entry_signal: str` — signal_id that triggered this position
- `metadata: dict` — strategy-specific details (default_factory=dict)

**BaseStrategy ABC** (follows BaseAgent pattern with structlog):
- `__init__(self, config: StrategyConfig)` — stores config, creates structlog logger
- Abstract method: `generate_signals(self, as_of_date: date) -> list[StrategyPosition]` — subclasses implement to produce positions
- Concrete method: `signals_to_positions(self, agent_signals: list[AgentSignal], existing_weights: dict[str, float] | None = None) -> list[StrategyPosition]` — converts agent signals to positions using locked weight formula:
  - STRENGTH_MAP: STRONG=1.0, MODERATE=0.6, WEAK=0.3, NO_SIGNAL=0.0
  - For each signal: `raw_weight = STRENGTH_MAP[signal.strength] * signal.confidence * config.max_position_size`
  - If direction is SHORT: `raw_weight = -raw_weight`
  - If direction is NEUTRAL and existing_weights has the instrument: `raw_weight = existing_weights[instrument] * 0.5` (50% scale-down per locked decision)
  - If direction is NEUTRAL and no existing position: `raw_weight = 0.0`
  - Clamp weight to [-config.max_position_size, config.max_position_size]
  - Enforce max_leverage: if sum of abs(weights) exceeds max_leverage, scale all weights proportionally
  - Return list[StrategyPosition] with validated weight and confidence
- Concrete method: `validate_position(self, position: StrategyPosition) -> StrategyPosition` — enforces weight in [-1,1], confidence in [0,1], returns clamped copy
- Property: `strategy_id -> str` returns config.strategy_id

**Package __init__.py**: Export BaseStrategy, StrategyConfig, StrategyPosition.

**Tests** (tests/test_strategies/test_base.py):
- Test StrategyConfig is frozen (immutable)
- Test StrategyPosition fields and defaults
- Test STRENGTH_MAP values match locked decisions (STRONG=1.0, MODERATE=0.6, WEAK=0.3)
- Test signals_to_positions with LONG signal: weight = strength_base * confidence * max_size
- Test signals_to_positions with SHORT signal: weight is negative
- Test signals_to_positions with NEUTRAL: 50% of existing position
- Test signals_to_positions with NEUTRAL and no existing position: weight = 0
- Test weight clamping at max_position_size
- Test leverage enforcement: weights scale down proportionally
- Test validate_position clamps out-of-range values
- Test BaseStrategy is abstract (cannot instantiate directly)
- Create a concrete DummyStrategy subclass for testing (follows test agent pattern from Phase 7)
  </action>
  <verify>
Run `python -m pytest tests/test_strategies/test_base.py -v` — all tests pass.
Run `python -c "from src.strategies import BaseStrategy, StrategyConfig, StrategyPosition; print('OK')"` — imports succeed.
Run `ruff check src/strategies/ tests/test_strategies/` — no lint errors.
  </verify>
  <done>
BaseStrategy ABC enforces StrategyConfig and generate_signals contract. signals_to_positions implements locked weight formula (strength_base x confidence x max_size) with NEUTRAL 50% scale-down. All position limits and leverage constraints enforced. 12+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement RATES_BR_01 Carry & Roll-Down and RATES_BR_02 Taylor Misalignment strategies with tests</name>
  <files>
    src/strategies/rates_br_01_carry.py
    src/strategies/rates_br_02_taylor.py
    tests/test_strategies/test_rates_br_01.py
    tests/test_strategies/test_rates_br_02.py
    src/strategies/__init__.py
  </files>
  <action>
**RATES_BR_01 Carry & Roll-Down** (src/strategies/rates_br_01_carry.py):

`RatesBR01CarryStrategy(BaseStrategy)` with StrategyConfig:
- strategy_id: "RATES_BR_01"
- strategy_name: "BR DI Carry & Roll-Down"
- asset_class: AssetClass.FIXED_INCOME
- instruments: ["DI_PRE"]
- rebalance_frequency: Frequency.DAILY
- max_position_size: 1.0
- stop_loss_pct: 0.03 (3%)
- take_profit_pct: 0.08 (8%)

Constructor takes `data_loader: PointInTimeDataLoader` and `carry_threshold: float = 1.5` (carry-to-risk ratio threshold).

`generate_signals(self, as_of_date: date) -> list[StrategyPosition]`:
1. Load DI curve via `data_loader.get_curve("DI_PRE", as_of_date)` — returns {tenor_days: rate}
2. Load DI curve history for each tenor via `data_loader.get_curve_history("DI_PRE", tenor_days, as_of_date, lookback_days=252)` to compute volatility
3. For each tenor pair (t, t+1): compute carry = rate[t+1] - rate[t] (annualized)
4. Compute risk = rolling std of rate changes for each tenor (252d window, annualized sqrt(252))
5. carry_to_risk ratio = carry / risk for each tenor
6. Identify optimal tenor = tenor with max carry_to_risk ratio
7. If max carry_to_risk > carry_threshold: go LONG at optimal tenor
   - confidence = min(1.0, carry_to_risk / (carry_threshold * 2)) — scales linearly from threshold to 2x threshold
   - strength = classify_strength(confidence)
   - weight via signals_to_positions
8. If carry_to_risk < -carry_threshold: go SHORT (inverse)
9. Else: NEUTRAL (no position)
10. Return list with single StrategyPosition for the optimal tenor

Handle edge cases: empty curve (return []), fewer than 2 tenors (return []), zero risk (skip tenor).

**RATES_BR_02 Taylor Rule Misalignment** (src/strategies/rates_br_02_taylor.py):

`RatesBR02TaylorStrategy(BaseStrategy)` with StrategyConfig:
- strategy_id: "RATES_BR_02"
- strategy_name: "BR Taylor Rule Misalignment"
- asset_class: AssetClass.FIXED_INCOME
- instruments: ["DI_PRE"]
- rebalance_frequency: Frequency.DAILY
- max_position_size: 1.0
- stop_loss_pct: 0.04 (4%)
- take_profit_pct: 0.10 (10%)

Constructor takes `data_loader: PointInTimeDataLoader` and `gap_threshold_bps: float = 100.0` (policy gap threshold in basis points).

`generate_signals(self, as_of_date: date) -> list[StrategyPosition]`:
1. Load current Selic target via `data_loader.get_latest_macro_value("BR_SELIC_TARGET", as_of_date)`
2. Load inflation expectations (Focus IPCA) via `data_loader.get_latest_macro_value("BR_FOCUS_IPCA_CY_MEDIAN", as_of_date)`
3. Load DI curve (short-end, 252 days / 1Y tenor) via `data_loader.get_curve("DI_PRE", as_of_date)`
4. Compute Taylor-implied rate: `taylor_rate = r_star + pi_e + alpha * (pi_e - pi_target) + beta * output_gap`
   - r_star: 4.5% (BCB neutral rate estimate, hard-coded default with constructor override)
   - pi_target: 3.0% (BCB inflation target center)
   - alpha: 1.5 (inflation response coefficient)
   - beta: 0.5 (output gap coefficient)
   - output_gap: 0.0 (default — use data_loader if available, else 0)
   - pi_e: inflation expectation from Focus
5. Compute gap = taylor_rate - market_rate (1Y DI rate from curve)
6. gap_bps = gap * 100 (convert to basis points)
7. If abs(gap_bps) > gap_threshold_bps:
   - If gap > 0 (Taylor says higher than market): SHORT DI (rates should rise = DI prices fall) — i.e., the market is too dovish
   - If gap < 0 (Taylor says lower than market): LONG DI (rates should fall = DI prices rise) — i.e., the market is too hawkish
   - confidence = min(1.0, abs(gap_bps) / (gap_threshold_bps * 3)) — scales up to 3x threshold
   - strength = classify_strength(confidence)
   - weight via signals_to_positions
8. Else: NEUTRAL (gap within threshold)
9. Return list with single StrategyPosition

Handle edge cases: missing Selic (return []), missing Focus (return []), missing DI curve (return []).

**Update __init__.py**: Add exports for RatesBR01CarryStrategy, RatesBR02TaylorStrategy.

**Tests** (test_rates_br_01.py and test_rates_br_02.py):
- Use mock PointInTimeDataLoader (mock.patch or mock object with return_value set to synthetic data)
- RATES_BR_01 tests:
  - Test with mock curve where carry-to-risk exceeds threshold -> LONG position
  - Test with negative carry-to-risk below -threshold -> SHORT position
  - Test with carry-to-risk within threshold -> no position (empty list)
  - Test with empty curve -> empty list
  - Test weight is in [-1, 1] and confidence in [0, 1]
  - Test optimal tenor selection (highest carry-to-risk)
- RATES_BR_02 tests:
  - Test Taylor rate > market by >100bps -> SHORT DI position
  - Test Taylor rate < market by >100bps -> LONG DI position
  - Test gap within 100bps -> no position
  - Test missing data (None Selic) -> empty list
  - Test weight and confidence bounds
  - Test with custom gap_threshold_bps
  </action>
  <verify>
Run `python -m pytest tests/test_strategies/ -v` — all tests pass (base + both strategies).
Run `python -c "from src.strategies import RatesBR01CarryStrategy, RatesBR02TaylorStrategy; print('OK')"` — imports succeed.
Run `ruff check src/strategies/ tests/test_strategies/` — no lint errors.
  </verify>
  <done>
RATES_BR_01 computes carry-to-risk at each DI curve tenor and goes long at optimal point when ratio exceeds threshold. RATES_BR_02 trades DI direction when Taylor-market gap exceeds 100bps. Both strategies produce valid StrategyPosition outputs with weight in [-1,1] and confidence in [0,1]. 10+ strategy-specific tests passing.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_strategies/ -v` — ALL tests pass
2. `python -c "from src.strategies import BaseStrategy, StrategyConfig, StrategyPosition, RatesBR01CarryStrategy, RatesBR02TaylorStrategy; print('ALL IMPORTS OK')"` — succeeds
3. `ruff check src/strategies/ tests/test_strategies/` — zero errors
4. Verify StrategyConfig is a frozen dataclass (immutable)
5. Verify weight formula: STRONG signal with confidence 0.8 and max_size 1.0 -> weight = 1.0 * 0.8 * 1.0 = 0.8
6. Verify NEUTRAL produces 50% scale-down
7. Verify leverage enforcement clamps total weight
</verification>

<success_criteria>
- BaseStrategy ABC exists and cannot be instantiated directly
- StrategyConfig is frozen with all 9 fields
- StrategyPosition has weight in [-1,1] and confidence in [0,1]
- signals_to_positions implements locked weight formula exactly
- RATES_BR_01 selects optimal DI tenor by carry-to-risk and trades when above threshold
- RATES_BR_02 computes Taylor-market gap and trades DI when gap exceeds 100bps
- Both strategies handle missing data gracefully (return empty list)
- All tests pass, all imports work, zero lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-trading-strategies/11-01-SUMMARY.md`
</output>
