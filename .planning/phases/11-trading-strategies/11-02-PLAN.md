---
phase: 11-trading-strategies
plan: 02
type: execute
wave: 2
depends_on:
  - 11-01
files_modified:
  - src/strategies/rates_br_03_slope.py
  - src/strategies/rates_br_04_spillover.py
  - src/strategies/inf_br_01_breakeven.py
  - tests/test_strategies/test_rates_br_03.py
  - tests/test_strategies/test_rates_br_04.py
  - tests/test_strategies/test_inf_br_01.py
  - src/strategies/__init__.py
autonomous: true
requirements:
  - STRAT-04
  - STRAT-05
  - STRAT-06

must_haves:
  truths:
    - "RATES_BR_03 trades DI 2Y-5Y slope (flattener/steepener) based on monetary cycle position and inflation expectations"
    - "RATES_BR_04 fades DI-UST spread overshoot after large weekly UST moves via mean reversion"
    - "INF_BR_01 trades breakeven inflation (DI_PRE minus NTN_B_REAL) when agent forecast diverges from market-implied inflation"
    - "All three strategies produce valid StrategyPosition outputs with weight in [-1,1] and confidence in [0,1]"
    - "All three strategies handle missing data gracefully returning empty position lists"
  artifacts:
    - path: "src/strategies/rates_br_03_slope.py"
      provides: "RATES_BR_03 Curve Slope (flattener/steepener) strategy"
      exports: ["RatesBR03SlopeStrategy"]
    - path: "src/strategies/rates_br_04_spillover.py"
      provides: "RATES_BR_04 US Rates Spillover strategy"
      exports: ["RatesBR04SpilloverStrategy"]
    - path: "src/strategies/inf_br_01_breakeven.py"
      provides: "INF_BR_01 Breakeven Inflation Trade strategy"
      exports: ["InfBR01BreakevenStrategy"]
    - path: "tests/test_strategies/test_rates_br_03.py"
      provides: "Tests for RATES_BR_03 Curve Slope strategy"
      min_lines: 40
    - path: "tests/test_strategies/test_rates_br_04.py"
      provides: "Tests for RATES_BR_04 US Rates Spillover strategy"
      min_lines: 40
    - path: "tests/test_strategies/test_inf_br_01.py"
      provides: "Tests for INF_BR_01 Breakeven Inflation strategy"
      min_lines: 40
  key_links:
    - from: "src/strategies/rates_br_03_slope.py"
      to: "src/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class RatesBR03SlopeStrategy\\(BaseStrategy\\)"
    - from: "src/strategies/rates_br_04_spillover.py"
      to: "src/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class RatesBR04SpilloverStrategy\\(BaseStrategy\\)"
    - from: "src/strategies/inf_br_01_breakeven.py"
      to: "src/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class InfBR01BreakevenStrategy\\(BaseStrategy\\)"
    - from: "src/strategies/rates_br_04_spillover.py"
      to: "src/agents/data_loader.py"
      via: "uses get_curve_history for DI and UST spread computation"
      pattern: "data_loader\\.get_curve_history"
---

<objective>
Implement three more trading strategies: RATES_BR_03 (Curve Slope flattener/steepener), RATES_BR_04 (US Rates Spillover mean reversion), and INF_BR_01 (Breakeven Inflation Trade), each inheriting from BaseStrategy and producing valid StrategyPosition outputs.

Purpose: Expand the strategy suite with curve-shape, cross-market, and inflation-relative-value strategies, covering different macro themes within the Brazilian rates and inflation space.

Output: Three new strategy modules in src/strategies/ with comprehensive tests.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-trading-strategies/11-CONTEXT.md
@.planning/phases/11-trading-strategies/11-01-SUMMARY.md

# Key source files to reference
@src/strategies/base.py         # BaseStrategy, StrategyConfig, StrategyPosition (from Plan 01)
@src/agents/data_loader.py      # PointInTimeDataLoader query methods
@src/agents/base.py             # AgentSignal, classify_strength
@src/core/enums.py              # AssetClass, Frequency, SignalDirection, SignalStrength
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement RATES_BR_03 Curve Slope and RATES_BR_04 US Rates Spillover strategies with tests</name>
  <files>
    src/strategies/rates_br_03_slope.py
    src/strategies/rates_br_04_spillover.py
    tests/test_strategies/test_rates_br_03.py
    tests/test_strategies/test_rates_br_04.py
    src/strategies/__init__.py
  </files>
  <action>
**RATES_BR_03 Curve Slope** (src/strategies/rates_br_03_slope.py):

`RatesBR03SlopeStrategy(BaseStrategy)` with StrategyConfig:
- strategy_id: "RATES_BR_03"
- strategy_name: "BR DI Curve Slope"
- asset_class: AssetClass.FIXED_INCOME
- instruments: ["DI_PRE"]
- rebalance_frequency: Frequency.DAILY
- max_position_size: 1.0
- stop_loss_pct: 0.03 (3%)
- take_profit_pct: 0.06 (6%)

Constructor takes `data_loader: PointInTimeDataLoader`, `slope_z_threshold: float = 1.5` (z-score threshold for slope signal).

`generate_signals(self, as_of_date: date) -> list[StrategyPosition]`:
1. Load DI curve via `data_loader.get_curve("DI_PRE", as_of_date)` — get full term structure
2. Identify 2Y tenor (~504 days, find closest) and 5Y tenor (~1260 days, find closest) from available curve points
3. Compute current slope = rate_5Y - rate_2Y (positive = steep, negative = inverted)
4. Load 2Y and 5Y rate history via `data_loader.get_curve_history("DI_PRE", tenor_2y, as_of_date)` and same for 5Y
5. Compute historical slope series = 5Y_history - 2Y_history (aligned by date)
6. Compute z-score of current slope vs rolling 252-day mean and std of historical slope
7. Load monetary cycle signals: get Selic via `data_loader.get_macro_series("BR_SELIC_TARGET", as_of_date, lookback_days=756)` to detect easing/tightening (direction of last 2 changes)
8. Load inflation expectations via `data_loader.get_latest_macro_value("BR_FOCUS_IPCA_CY_MEDIAN", as_of_date)`
9. Strategy logic:
   - If z-score > slope_z_threshold (slope is unusually steep):
     - In easing cycle (Selic declining): FLATTENER (short 5Y, long 2Y) — easing compresses front-end more
     - In tightening cycle (Selic rising): FLATTENER (short 5Y, long 2Y) — front-end rises faster
     - Represent as weight = positive for flattener (long short-end relative to long-end)
   - If z-score < -slope_z_threshold (slope unusually flat/inverted):
     - STEEPENER (long 5Y, short 2Y) — expect normalization
     - Represent as weight = negative (opposite of flattener)
   - Else: NEUTRAL
   - confidence = min(1.0, abs(z_score) / (slope_z_threshold * 2.5))
   - Apply signals_to_positions for constraint enforcement
10. Return list with single StrategyPosition representing the slope trade

Handle edge cases: missing curve (return []), fewer than 2 relevant tenors (return []), insufficient history for z-score (return []).

**RATES_BR_04 US Rates Spillover** (src/strategies/rates_br_04_spillover.py):

`RatesBR04SpilloverStrategy(BaseStrategy)` with StrategyConfig:
- strategy_id: "RATES_BR_04"
- strategy_name: "US Rates Spillover to BR DI"
- asset_class: AssetClass.FIXED_INCOME
- instruments: ["DI_PRE"]
- rebalance_frequency: Frequency.DAILY
- max_position_size: 1.0
- stop_loss_pct: 0.04 (4%)
- take_profit_pct: 0.08 (8%)

Constructor takes `data_loader: PointInTimeDataLoader`, `spread_z_threshold: float = 2.0` (z-score threshold for spread overshoot), `ust_weekly_move_bps: float = 15.0` (minimum UST weekly move to trigger).

`generate_signals(self, as_of_date: date) -> list[StrategyPosition]`:
1. Load DI 1Y rate history via `data_loader.get_curve_history("DI_PRE", 252, as_of_date, lookback_days=756)`
2. Load UST 1Y rate history via `data_loader.get_curve_history("UST_NOM", 365, as_of_date, lookback_days=756)`
3. Compute DI-UST spread = DI_1Y - UST_1Y (aligned by date, forward-fill for holidays)
4. Compute weekly UST change = UST_1Y[-1] - UST_1Y[-5] (5 business days)
5. Compute z-score of current spread vs rolling 252-day mean and std
6. Strategy logic (mean reversion on spread overshoot):
   - If abs(weekly_ust_change) * 10000 < ust_weekly_move_bps: no signal (UST did not move enough)
   - If spread z-score > spread_z_threshold (DI overreacted to UST move — DI-UST spread too wide):
     - SHORT DI (expect spread to compress — DI rates to fall back)
     - This fades the overreaction
   - If spread z-score < -spread_z_threshold (DI underreacted — spread too narrow):
     - LONG DI (wait, actually this means DI did not adjust enough — BUY DI expecting rates to rise, widening the spread)
     - Correction: If spread is too narrow, DI hasn't risen enough relative to UST — but we want mean reversion so we LONG DI expecting spread to widen back (rates rise)
     - Actually, for DI bond price: SHORT DI means rates rise. Reconsider: If spread (DI-UST) is too high (z>2), DI rates overshot -> expect DI rates to fall -> LONG DI position (rates falling = bond price rising). If spread too low (z<-2), DI rates undershot -> expect DI rates to rise -> SHORT DI position.
   - confidence = min(1.0, abs(spread_z_score) / (spread_z_threshold * 2))
   - Apply signals_to_positions
7. Return single StrategyPosition

Handle edge cases: missing DI history, missing UST history, insufficient overlap for spread computation.

**Update __init__.py**: Add exports for RatesBR03SlopeStrategy, RatesBR04SpilloverStrategy.

**Tests** (using mock PointInTimeDataLoader):
- RATES_BR_03 tests:
  - Test steep slope (z > threshold) in easing cycle -> flattener position
  - Test flat slope (z < -threshold) -> steepener position
  - Test slope within threshold -> no position
  - Test missing curve -> empty list
  - Test weight and confidence bounds
- RATES_BR_04 tests:
  - Test spread overshoot (z > threshold) after large UST move -> LONG DI (fade)
  - Test spread undershoot (z < -threshold) after large UST move -> SHORT DI (fade)
  - Test small UST move (below ust_weekly_move_bps) -> no signal
  - Test spread within threshold -> no position
  - Test missing data -> empty list
  </action>
  <verify>
Run `python -m pytest tests/test_strategies/test_rates_br_03.py tests/test_strategies/test_rates_br_04.py -v` — all tests pass.
Run `python -c "from src.strategies import RatesBR03SlopeStrategy, RatesBR04SpilloverStrategy; print('OK')"` — imports succeed.
Run `ruff check src/strategies/rates_br_03_slope.py src/strategies/rates_br_04_spillover.py` — no lint errors.
  </verify>
  <done>
RATES_BR_03 trades DI 2Y-5Y slope using z-score of historical spread, considering monetary cycle for flattener/steepener direction. RATES_BR_04 fades DI-UST spread overshoot after large weekly UST moves. Both produce valid StrategyPosition with bounded weight and confidence. 10+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement INF_BR_01 Breakeven Inflation Trade strategy with tests</name>
  <files>
    src/strategies/inf_br_01_breakeven.py
    tests/test_strategies/test_inf_br_01.py
    src/strategies/__init__.py
  </files>
  <action>
**INF_BR_01 Breakeven Inflation Trade** (src/strategies/inf_br_01_breakeven.py):

`InfBR01BreakevenStrategy(BaseStrategy)` with StrategyConfig:
- strategy_id: "INF_BR_01"
- strategy_name: "BR Breakeven Inflation Trade"
- asset_class: AssetClass.FIXED_INCOME
- instruments: ["DI_PRE", "NTN_B_REAL"]
- rebalance_frequency: Frequency.DAILY
- max_position_size: 1.0
- stop_loss_pct: 0.03 (3%)
- take_profit_pct: 0.06 (6%)

Constructor takes `data_loader: PointInTimeDataLoader`, `divergence_threshold_bps: float = 50.0` (minimum divergence between agent forecast and market breakeven).

`generate_signals(self, as_of_date: date) -> list[StrategyPosition]`:
1. Load DI_PRE curve via `data_loader.get_curve("DI_PRE", as_of_date)` — nominal rates
2. Load NTN_B_REAL curve via `data_loader.get_curve("NTN_B_REAL", as_of_date)` — real rates
3. Compute market-implied breakeven at matching tenors: breakeven = nominal_rate - real_rate
   - Match tenors by finding closest available NTN-B tenor for each DI tenor
   - Focus on 2Y tenor (~504 days) as primary signal — most liquid and responsive
4. Load agent inflation forecast (if available) via `data_loader.get_latest_macro_value("BR_FOCUS_IPCA_CY_MEDIAN", as_of_date)` — proxy for agent inflation composite
5. Compute divergence = agent_forecast - market_breakeven (in percentage points)
6. divergence_bps = divergence * 100
7. Strategy logic:
   - If divergence_bps > divergence_threshold_bps (agent sees higher inflation than market):
     - Market underpricing inflation -> LONG breakeven (long NTN-B/real, short DI/nominal)
     - Positive weight = long inflation
   - If divergence_bps < -divergence_threshold_bps (agent sees lower inflation than market):
     - Market overpricing inflation -> SHORT breakeven (short NTN-B/real, long DI/nominal)
     - Negative weight = short inflation
   - Else: NEUTRAL (market and forecast aligned)
   - confidence = min(1.0, abs(divergence_bps) / (divergence_threshold_bps * 3))
   - strength = classify_strength(confidence)
8. Apply signals_to_positions for constraint enforcement
9. Return list with single StrategyPosition (direction indicates breakeven trade direction)

Handle edge cases: missing DI curve (return []), missing NTN-B curve (return []), no matching tenors (return []), missing Focus forecast (return []).

**Update __init__.py**: Add InfBR01BreakevenStrategy to exports.

**Tests** (tests/test_strategies/test_inf_br_01.py using mock data_loader):
- Test agent forecast > market breakeven by >50bps -> LONG breakeven position
- Test agent forecast < market breakeven by >50bps -> SHORT breakeven position
- Test divergence within 50bps -> no position (empty list)
- Test missing DI curve -> empty list
- Test missing NTN-B curve -> empty list
- Test missing Focus forecast -> empty list
- Test weight in [-1, 1] and confidence in [0, 1]
- Test with custom divergence_threshold_bps
  </action>
  <verify>
Run `python -m pytest tests/test_strategies/test_inf_br_01.py -v` — all tests pass.
Run `python -c "from src.strategies import InfBR01BreakevenStrategy; print('OK')"` — imports succeed.
Run `ruff check src/strategies/inf_br_01_breakeven.py tests/test_strategies/test_inf_br_01.py` — no lint errors.
  </verify>
  <done>
INF_BR_01 trades breakeven inflation (nominal DI minus NTN-B real) when Focus forecast diverges from market-implied breakeven by more than 50bps. Produces valid StrategyPosition with bounded weight and confidence. 8+ tests passing.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_strategies/ -v` — ALL tests pass (including base + RATES_BR_01 + RATES_BR_02 from Plan 01)
2. `python -c "from src.strategies import RatesBR03SlopeStrategy, RatesBR04SpilloverStrategy, InfBR01BreakevenStrategy; print('ALL IMPORTS OK')"` — succeeds
3. `ruff check src/strategies/ tests/test_strategies/` — zero errors
4. Verify all three strategies inherit from BaseStrategy
5. Verify all positions have weight in [-1,1] and confidence in [0,1]
</verification>

<success_criteria>
- RATES_BR_03 computes 2Y-5Y slope z-score and trades flattener/steepener based on monetary cycle
- RATES_BR_04 detects DI-UST spread overshoot after large UST moves and fades via mean reversion
- INF_BR_01 compares agent inflation forecast to market-implied breakeven and trades the divergence
- All strategies handle missing data gracefully (return empty list)
- All positions respect configured limits via BaseStrategy constraint engine
- All tests pass, all imports work, zero lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-trading-strategies/11-02-SUMMARY.md`
</output>
