---
phase: 11-trading-strategies
plan: 03
type: execute
wave: 2
depends_on:
  - 11-01
files_modified:
  - src/strategies/fx_br_01_carry_fundamental.py
  - src/strategies/cupom_01_cip_basis.py
  - src/strategies/sov_br_01_fiscal_risk.py
  - tests/test_strategies/test_fx_br_01.py
  - tests/test_strategies/test_cupom_01.py
  - tests/test_strategies/test_sov_br_01.py
  - src/strategies/__init__.py
autonomous: true
requirements:
  - STRAT-07
  - STRAT-08
  - STRAT-09

must_haves:
  truths:
    - "FX_BR_01 composites carry-to-risk (40%), BEER misalignment (35%), and flow score (25%) with regime adjustment"
    - "CUPOM_01 fades extreme z-scores in cupom cambial minus SOFR basis via mean reversion"
    - "SOV_BR_01 trades long-end DI and USDBRL based on fiscal dominance risk vs sovereign spread level"
    - "ALL_STRATEGIES dict exports all 8 strategies by ID for backtesting and pipeline integration"
    - "All three strategies produce valid StrategyPosition outputs with weight in [-1,1] and confidence in [0,1]"
    - "Regime adjustment scales position sizes when CrossAssetAgent regime is unfavorable"
  artifacts:
    - path: "src/strategies/fx_br_01_carry_fundamental.py"
      provides: "FX_BR_01 Carry & Fundamental composite strategy"
      exports: ["FxBR01CarryFundamentalStrategy"]
    - path: "src/strategies/cupom_01_cip_basis.py"
      provides: "CUPOM_01 CIP Basis Mean Reversion strategy"
      exports: ["Cupom01CipBasisStrategy"]
    - path: "src/strategies/sov_br_01_fiscal_risk.py"
      provides: "SOV_BR_01 Fiscal Risk Premium strategy"
      exports: ["SovBR01FiscalRiskStrategy"]
    - path: "src/strategies/__init__.py"
      provides: "ALL_STRATEGIES registry dict and full strategy exports"
      exports: ["ALL_STRATEGIES"]
    - path: "tests/test_strategies/test_fx_br_01.py"
      provides: "Tests for FX_BR_01 composite strategy"
      min_lines: 50
    - path: "tests/test_strategies/test_cupom_01.py"
      provides: "Tests for CUPOM_01 CIP basis strategy"
      min_lines: 40
    - path: "tests/test_strategies/test_sov_br_01.py"
      provides: "Tests for SOV_BR_01 fiscal risk strategy"
      min_lines: 40
  key_links:
    - from: "src/strategies/fx_br_01_carry_fundamental.py"
      to: "src/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class FxBR01CarryFundamentalStrategy\\(BaseStrategy\\)"
    - from: "src/strategies/cupom_01_cip_basis.py"
      to: "src/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class Cupom01CipBasisStrategy\\(BaseStrategy\\)"
    - from: "src/strategies/sov_br_01_fiscal_risk.py"
      to: "src/strategies/base.py"
      via: "inherits BaseStrategy"
      pattern: "class SovBR01FiscalRiskStrategy\\(BaseStrategy\\)"
    - from: "src/strategies/__init__.py"
      to: "all strategy modules"
      via: "ALL_STRATEGIES dict mapping strategy_id to strategy class"
      pattern: "ALL_STRATEGIES.*=.*\\{"
---

<objective>
Implement three final strategies — FX_BR_01 (Carry & Fundamental composite), CUPOM_01 (CIP Basis Mean Reversion), and SOV_BR_01 (Fiscal Risk Premium) — and create the ALL_STRATEGIES registry dict exporting all 8 strategies by ID.

Purpose: Complete the Phase 11 strategy suite with FX, cross-currency basis, and sovereign risk strategies. The ALL_STRATEGIES registry enables the backtesting engine (Phase 10) and daily pipeline (Phase 13) to discover and instantiate strategies programmatically.

Output: Three new strategy modules, the complete ALL_STRATEGIES registry in __init__.py, and comprehensive tests for each strategy.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-trading-strategies/11-CONTEXT.md
@.planning/phases/11-trading-strategies/11-01-SUMMARY.md

# Key source files to reference
@src/strategies/base.py                  # BaseStrategy, StrategyConfig, StrategyPosition (from Plan 01)
@src/strategies/rates_br_01_carry.py     # Pattern reference for constructor/data_loader usage
@src/agents/data_loader.py              # PointInTimeDataLoader query methods
@src/agents/base.py                     # AgentSignal, classify_strength
@src/core/enums.py                      # AssetClass, Frequency, SignalDirection, SignalStrength
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement FX_BR_01 Carry & Fundamental composite strategy with tests</name>
  <files>
    src/strategies/fx_br_01_carry_fundamental.py
    tests/test_strategies/test_fx_br_01.py
    src/strategies/__init__.py
  </files>
  <action>
**FX_BR_01 Carry & Fundamental** (src/strategies/fx_br_01_carry_fundamental.py):

`FxBR01CarryFundamentalStrategy(BaseStrategy)` with StrategyConfig:
- strategy_id: "FX_BR_01"
- strategy_name: "USDBRL Carry & Fundamental"
- asset_class: AssetClass.FX
- instruments: ["USDBRL"]
- rebalance_frequency: Frequency.DAILY
- max_position_size: 1.0
- stop_loss_pct: 0.05 (5%)
- take_profit_pct: 0.10 (10%)

Constructor takes `data_loader: PointInTimeDataLoader` and optional weight parameters:
- `carry_weight: float = 0.40` (40% per locked decision)
- `beer_weight: float = 0.35` (35% per locked decision)
- `flow_weight: float = 0.25` (25% per locked decision)
- `regime_scale: float = 0.50` (50% scale-down in unfavorable regime per locked decision)

`generate_signals(self, as_of_date: date) -> list[StrategyPosition]`:

**Component 1: Carry-to-Risk Score (40%)**
1. Load BR Selic target via `data_loader.get_latest_macro_value("BR_SELIC_TARGET", as_of_date)`
2. Load US Fed Funds proxy via `data_loader.get_latest_macro_value("US_FED_FUNDS", as_of_date)` — if unavailable, try "US_SOFR"
3. Compute carry = BR_rate - US_rate (positive = BRL carry advantage)
4. Load USDBRL volatility: `data_loader.get_market_data("USDBRL", as_of_date, lookback_days=63)` — compute 21-day realized vol (annualized)
5. carry_to_risk = carry / (usdbrl_vol * 100) if vol > 0, else 0
6. Normalize carry score to [-1, 1]: carry_score = tanh(carry_to_risk / 2) (positive = long BRL = short USDBRL)

**Component 2: BEER Misalignment Score (35%)**
1. Load USDBRL spot via `data_loader.get_market_data("USDBRL", as_of_date)` — latest close
2. Load terms-of-trade proxy via `data_loader.get_latest_macro_value("BR_TERMS_OF_TRADE", as_of_date)` — if unavailable, use commodity index proxy from market_data
3. Compute a simplified BEER fair value: use rolling 252-day mean of USDBRL as a rough equilibrium proxy (full BEER model is in FxEquilibriumAgent from Phase 9; strategy uses simplified version)
4. misalignment_pct = (spot - fair_value) / fair_value * 100
5. beer_score: if USDBRL > fair value (BRL undervalued) -> positive score (long BRL = short USDBRL); tanh(misalignment_pct / 10) capped to [-1, 1]

**Component 3: Flow Score (25%)**
1. Load FX flow data via `data_loader.get_flow_data("BR_FX_FLOW_NET", as_of_date, lookback_days=63)`
2. Compute cumulative net flow over last 21 days
3. Compute z-score of 21-day flow vs 252-day history
4. flow_score = tanh(flow_z_score / 2) — positive flow = long BRL = short USDBRL

**Composite Signal:**
1. composite = carry_score * carry_weight + beer_score * beer_weight + flow_score * flow_weight
2. If abs(composite) < 0.1: NEUTRAL, no position
3. Direction: composite > 0 -> SHORT USDBRL (long BRL); composite < 0 -> LONG USDBRL (short BRL)
4. confidence = min(1.0, abs(composite))
5. strength = classify_strength(confidence)

**Regime Adjustment (per locked decision):**
1. Check if regime is unfavorable: look for cross-asset regime signal
   - Try loading latest macro value for a cross-asset regime indicator (e.g., if available from Phase 10 CrossAssetAgent signal stored in signals table)
   - For now: accept optional `regime_score: float | None` parameter in generate_signals (default None). If provided and regime_score < -0.3 (risk-off), scale position by regime_scale (0.50)
   - This allows Phase 12 to pass regime context without hard coupling
2. Apply scale: if regime is unfavorable, multiply weight by regime_scale

6. Apply signals_to_positions for constraint enforcement
7. Return single StrategyPosition

Handle edge cases: missing Selic (use DI 1Y rate from curve), missing USDBRL data (return []), insufficient vol history (return []).

**Update __init__.py**: Add FxBR01CarryFundamentalStrategy export.

**Tests** (tests/test_strategies/test_fx_br_01.py):
- Test carry component: high BR-US rate differential -> positive carry score
- Test BEER component: USDBRL above 252-day mean -> positive beer_score (BRL undervalued)
- Test flow component: positive cumulative net flow -> positive flow_score
- Test composite weights sum correctly (0.40 + 0.35 + 0.25 = 1.0)
- Test composite > 0 -> SHORT USDBRL position
- Test composite < 0 -> LONG USDBRL position
- Test small composite (< 0.1) -> no position
- Test regime adjustment: unfavorable regime scales weight by 0.5
- Test missing data returns empty list
- Test weight in [-1,1] and confidence in [0,1]
  </action>
  <verify>
Run `python -m pytest tests/test_strategies/test_fx_br_01.py -v` — all tests pass.
Run `python -c "from src.strategies import FxBR01CarryFundamentalStrategy; print('OK')"` — imports succeed.
Run `ruff check src/strategies/fx_br_01_carry_fundamental.py` — no lint errors.
  </verify>
  <done>
FX_BR_01 composites carry-to-risk (40%), BEER misalignment (35%), and flow score (25%) into a USDBRL directional signal. Regime adjustment scales positions by 50% in risk-off. Produces valid StrategyPosition with bounded weight and confidence. 10+ tests passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement CUPOM_01, SOV_BR_01 strategies and ALL_STRATEGIES registry with tests</name>
  <files>
    src/strategies/cupom_01_cip_basis.py
    src/strategies/sov_br_01_fiscal_risk.py
    tests/test_strategies/test_cupom_01.py
    tests/test_strategies/test_sov_br_01.py
    src/strategies/__init__.py
  </files>
  <action>
**CUPOM_01 CIP Basis Mean Reversion** (src/strategies/cupom_01_cip_basis.py):

`Cupom01CipBasisStrategy(BaseStrategy)` with StrategyConfig:
- strategy_id: "CUPOM_01"
- strategy_name: "Cupom Cambial CIP Basis Mean Reversion"
- asset_class: AssetClass.FIXED_INCOME
- instruments: ["DI_PRE", "USDBRL"]
- rebalance_frequency: Frequency.DAILY
- max_position_size: 1.0
- stop_loss_pct: 0.03 (3%)
- take_profit_pct: 0.06 (6%)

Constructor takes `data_loader: PointInTimeDataLoader`, `basis_z_threshold: float = 2.0` (z-score threshold for basis signal).

`generate_signals(self, as_of_date: date) -> list[StrategyPosition]`:
1. Load DI_PRE curve: `data_loader.get_curve("DI_PRE", as_of_date)` — BR nominal rates
2. Load UST_NOM curve: `data_loader.get_curve("UST_NOM", as_of_date)` — US nominal rates
3. Load USDBRL forward points proxy: compute cupom cambial = DI_PRE_1Y - UST_1Y (simplified; cupom cambial is the implied FX-adjusted rate)
   - Find 1Y tenor (~252 or ~365 days, closest available) in both curves
4. Load SOFR rate proxy: `data_loader.get_latest_macro_value("US_SOFR", as_of_date)` — if unavailable, use US_FED_FUNDS
5. Compute CIP basis = cupom_cambial - sofr_rate (deviation from covered interest parity)
6. Load historical CIP basis: compute from DI and UST curve history at 1Y tenor
   - `data_loader.get_curve_history("DI_PRE", di_1y_tenor, as_of_date, lookback_days=756)`
   - `data_loader.get_curve_history("UST_NOM", ust_1y_tenor, as_of_date, lookback_days=756)`
   - Historical basis = DI_history - UST_history - sofr_rate (simplified)
7. Compute z-score of current basis vs 252-day rolling mean/std of historical basis
8. Strategy logic (mean reversion on CIP basis extremes):
   - If z-score > basis_z_threshold (basis is extremely wide — BRL funding premium too high):
     - SHORT basis (expect compression) — receive cupom, pay SOFR
     - Weight is negative (short the basis)
   - If z-score < -basis_z_threshold (basis extremely narrow — BRL funding premium too low):
     - LONG basis (expect widening) — pay cupom, receive SOFR
     - Weight is positive
   - Else: NEUTRAL
   - confidence = min(1.0, abs(z_score) / (basis_z_threshold * 2))
   - Apply signals_to_positions
9. Return single StrategyPosition

Handle edge cases: missing curves, missing SOFR, insufficient history.

**SOV_BR_01 Fiscal Risk Premium** (src/strategies/sov_br_01_fiscal_risk.py):

`SovBR01FiscalRiskStrategy(BaseStrategy)` with StrategyConfig:
- strategy_id: "SOV_BR_01"
- strategy_name: "BR Fiscal Risk Premium"
- asset_class: AssetClass.FIXED_INCOME
- instruments: ["DI_PRE", "USDBRL"]
- rebalance_frequency: Frequency.DAILY
- max_position_size: 1.0
- stop_loss_pct: 0.05 (5%)
- take_profit_pct: 0.12 (12%)

Constructor takes `data_loader: PointInTimeDataLoader`, `debt_gdp_warning: float = 80.0` (debt-to-GDP % threshold), `spread_z_threshold: float = 1.5`.

`generate_signals(self, as_of_date: date) -> list[StrategyPosition]`:
1. Load debt-to-GDP: `data_loader.get_latest_macro_value("BR_GROSS_DEBT_GDP", as_of_date)` — if unavailable, try "BR_NET_DEBT_GDP"
2. Load primary balance: `data_loader.get_latest_macro_value("BR_PRIMARY_BALANCE_GDP", as_of_date)`
3. Load long-end DI rate: `data_loader.get_curve("DI_PRE", as_of_date)` — get 5Y or 10Y tenor (longest available)
4. Load USDBRL spot: latest close from `data_loader.get_market_data("USDBRL", as_of_date)`
5. Load CDS/sovereign spread proxy: `data_loader.get_latest_macro_value("BR_CDS_5Y", as_of_date)` — if unavailable, compute DI_5Y - UST_5Y as spread proxy
6. Compute fiscal risk score (0-100):
   - debt_risk = min(100, max(0, (debt_gdp - 60) / 40 * 100)) — linear 60-100% GDP mapping
   - balance_risk: if primary_balance < 0 (deficit): risk += abs(primary_balance) * 20, else risk -= primary_balance * 10
   - fiscal_risk = clamp(debt_risk + balance_risk, 0, 100) / 100 — normalized to [0, 1]
7. Compute spread z-score: compare current sovereign spread to 252-day rolling stats
   - Use long-end DI rate history from `data_loader.get_curve_history`
8. Strategy logic:
   - **High fiscal risk + spread below average** (fiscal_risk > 0.6 and spread_z < -spread_z_threshold):
     - Fiscal stress not yet priced -> SHORT DI long-end (expect rates to rise as market re-prices risk)
     - Also LONG USDBRL (expect BRL depreciation from fiscal stress)
     - Position represents: fiscal dominance risk trade
   - **Low fiscal risk + spread above average** (fiscal_risk < 0.3 and spread_z > spread_z_threshold):
     - Over-pricing fiscal risk -> LONG DI long-end (expect rates to fall)
     - Also SHORT USDBRL (expect BRL appreciation)
   - Else: NEUTRAL
   - confidence = min(1.0, (fiscal_risk if shorting else (1 - fiscal_risk)) * abs(spread_z) / spread_z_threshold)
   - Apply signals_to_positions
9. Return list of StrategyPosition(s) — may produce 1-2 positions (DI + USDBRL if both triggered)

Handle edge cases: missing fiscal data (return []), missing curve (return []), missing USDBRL data (return []).

**ALL_STRATEGIES Registry** (update src/strategies/__init__.py):

Create `ALL_STRATEGIES: dict[str, type[BaseStrategy]]` mapping strategy_id to strategy class:
```python
ALL_STRATEGIES: dict[str, type[BaseStrategy]] = {
    "RATES_BR_01": RatesBR01CarryStrategy,
    "RATES_BR_02": RatesBR02TaylorStrategy,
    "RATES_BR_03": RatesBR03SlopeStrategy,
    "RATES_BR_04": RatesBR04SpilloverStrategy,
    "INF_BR_01": InfBR01BreakevenStrategy,
    "FX_BR_01": FxBR01CarryFundamentalStrategy,
    "CUPOM_01": Cupom01CipBasisStrategy,
    "SOV_BR_01": SovBR01FiscalRiskStrategy,
}
```

Update `__all__` to include ALL_STRATEGIES and all 8 strategy classes plus base types.

**Tests** (tests/test_strategies/test_cupom_01.py and test_sov_br_01.py):
- CUPOM_01 tests:
  - Test basis z-score > threshold -> SHORT basis position
  - Test basis z-score < -threshold -> LONG basis position
  - Test basis within threshold -> no position
  - Test missing curves -> empty list
  - Test weight and confidence bounds
- SOV_BR_01 tests:
  - Test high fiscal risk + underpriced spread -> SHORT DI, LONG USDBRL
  - Test low fiscal risk + overpriced spread -> LONG DI, SHORT USDBRL
  - Test moderate fiscal risk / normal spread -> no position
  - Test missing fiscal data -> empty list
  - Test weight and confidence bounds
- ALL_STRATEGIES test (add to test_base.py or inline):
  - Verify ALL_STRATEGIES has exactly 8 entries
  - Verify all values are BaseStrategy subclasses
  - Verify all expected strategy IDs are present
  </action>
  <verify>
Run `python -m pytest tests/test_strategies/ -v` — ALL tests pass (all 8 strategies + base).
Run `python -c "from src.strategies import ALL_STRATEGIES; assert len(ALL_STRATEGIES) == 8; print(f'ALL_STRATEGIES: {list(ALL_STRATEGIES.keys())}')"` — prints all 8 IDs.
Run `ruff check src/strategies/ tests/test_strategies/` — zero errors.
  </verify>
  <done>
CUPOM_01 fades extreme CIP basis z-scores via mean reversion. SOV_BR_01 trades fiscal dominance risk vs sovereign spread mispricing. ALL_STRATEGIES registry exports all 8 strategies by ID. All strategies produce valid StrategyPosition with weight in [-1,1] and confidence in [0,1]. 10+ tests passing for this task, 40+ total across the test suite.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/test_strategies/ -v` — ALL tests pass across all 8 strategies and base
2. `python -c "from src.strategies import ALL_STRATEGIES; print(len(ALL_STRATEGIES), list(ALL_STRATEGIES.keys()))"` — prints 8 and all strategy IDs
3. `python -c "from src.strategies import BaseStrategy; assert all(issubclass(v, BaseStrategy) for v in __import__('src.strategies', fromlist=['ALL_STRATEGIES']).ALL_STRATEGIES.values()); print('ALL SUBCLASS CHECK OK')"` — confirms all are BaseStrategy subclasses
4. `ruff check src/strategies/ tests/test_strategies/` — zero errors
5. Verify ALL_STRATEGIES contains: RATES_BR_01, RATES_BR_02, RATES_BR_03, RATES_BR_04, INF_BR_01, FX_BR_01, CUPOM_01, SOV_BR_01
</verification>

<success_criteria>
- FX_BR_01 composites carry (40%), BEER (35%), flow (25%) with regime adjustment for USDBRL trading
- CUPOM_01 fades extreme CIP basis z-scores via mean reversion
- SOV_BR_01 trades fiscal dominance risk vs sovereign spread level on long-end DI and USDBRL
- ALL_STRATEGIES dict has exactly 8 entries, all BaseStrategy subclasses
- All positions respect configured limits via BaseStrategy constraint engine
- All strategies handle missing data gracefully (return empty list)
- All tests pass, all imports work, zero lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-trading-strategies/11-03-SUMMARY.md`
</output>
