---
phase: 18-dagster-orchestration-monitoring-reporting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/orchestration/__init__.py
  - src/orchestration/assets_bronze.py
  - src/orchestration/assets_silver.py
  - src/orchestration/assets_agents.py
  - src/orchestration/definitions.py
  - docker-compose.yml
  - Makefile
autonomous: true
requirements:
  - ORCH-01
  - ORCH-03
  - ORCH-04

must_haves:
  truths:
    - "Dagster-webserver UI starts at port 3001 and shows all Bronze, Silver, and Agent asset definitions"
    - "User can run `make dagster` to start dagster-webserver and `make dagster-run-all` to trigger materialization"
    - "Bronze assets map to the 6 existing connectors (bcb_sgs, fred, yahoo, bcb_ptax, b3_market_data, treasury_gov) with cron schedules"
    - "Silver assets depend on Bronze assets and wrap existing transforms (curves, returns, macro calculations)"
    - "Agent assets depend on Silver assets and run the 5 analytical agents in dependency order"
  artifacts:
    - path: "src/orchestration/__init__.py"
      provides: "Package init with version"
    - path: "src/orchestration/assets_bronze.py"
      provides: "6 Bronze layer Dagster asset definitions for data connectors"
      min_lines: 100
    - path: "src/orchestration/assets_silver.py"
      provides: "Silver transform Dagster asset definitions"
      min_lines: 60
    - path: "src/orchestration/assets_agents.py"
      provides: "5 Agent Dagster asset definitions with dependency chain"
      min_lines: 80
    - path: "src/orchestration/definitions.py"
      provides: "Dagster Definitions object registering all assets, schedules, and resources"
      min_lines: 40
    - path: "docker-compose.yml"
      provides: "dagster-webserver service on port 3001"
      contains: "dagster"
    - path: "Makefile"
      provides: "dagster and dagster-run-all targets"
      contains: "dagster"
  key_links:
    - from: "src/orchestration/assets_bronze.py"
      to: "src/connectors/"
      via: "import and call connector.fetch()"
      pattern: "from src\\.connectors"
    - from: "src/orchestration/assets_agents.py"
      to: "src/agents/registry.py"
      via: "AgentRegistry.run_all()"
      pattern: "AgentRegistry"
    - from: "src/orchestration/definitions.py"
      to: "src/orchestration/assets_*.py"
      via: "Dagster Definitions aggregation"
      pattern: "Definitions"
---

<objective>
Create the Dagster orchestration foundation: Bronze layer asset definitions for 6 data connectors, Silver transform assets, Agent assets with dependency chain, the central Definitions module, dagster-webserver Docker Compose service, and Makefile targets.

Purpose: Replace the custom DailyPipeline with Dagster's production-grade orchestration, giving the system scheduling, retry with backoff, dependency management, and a web UI for monitoring pipeline runs.

Output: `src/orchestration/` package with Bronze/Silver/Agent assets, Dagster definitions module, Docker service, and Makefile targets.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/connectors/__init__.py
@src/agents/registry.py
@src/pipeline/daily_pipeline.py
@docker-compose.yml
@Makefile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Bronze, Silver, and Agent Dagster asset definitions</name>
  <files>
    src/orchestration/__init__.py
    src/orchestration/assets_bronze.py
    src/orchestration/assets_silver.py
    src/orchestration/assets_agents.py
  </files>
  <action>
Create `src/orchestration/` package.

**src/orchestration/__init__.py**: Package init with `__version__ = "1.0.0"`.

**src/orchestration/assets_bronze.py**: Define 6 Dagster `@asset` functions for the Bronze layer. Each asset wraps the corresponding connector's `fetch()` method:

1. `bronze_bcb_sgs` — wraps BcbSgsConnector (BCB SGS macro series)
2. `bronze_fred` — wraps FredConnector (US macro series)
3. `bronze_yahoo` — wraps YahooFinanceConnector (market data)
4. `bronze_bcb_ptax` — wraps BcbPtaxConnector (FX fixing rates)
5. `bronze_b3_market_data` — wraps B3MarketDataConnector (DI curve, NTN-B)
6. `bronze_treasury_gov` — wraps TreasuryGovConnector (US yield curves)

Each asset function:
- Uses `@asset(group_name="bronze", retry_policy=RetryPolicy(max_retries=3, delay=30))` with exponential backoff per user decision (retry 3 times with backoff)
- Accepts a `context: AssetExecutionContext` parameter for logging via `context.log.info()`
- Uses `DailyPartitionsDefinition(start_date="2010-01-01")` for partition support (user decision: support date range backfills)
- Calls the connector and on success returns `{"status": "success", "records_fetched": N}`. On failure, logs the error via `context.log.error()` then **re-raises the exception** so Dagster's RetryPolicy triggers retries natively. Do NOT catch and swallow exceptions — let Dagster handle retry orchestration. Only catch specific non-fatal cases (e.g., empty data for a weekend date) for soft status returns
- Uses `asyncio.run()` to execute the async connector's fetch method (connectors are async)

Import connectors from `src.connectors` package.

**src/orchestration/assets_silver.py**: Define Silver transform assets that depend on Bronze assets:

1. `silver_curves` — depends on `bronze_b3_market_data` and `bronze_treasury_gov`, wraps curve transforms (Nelson-Siegel etc.)
2. `silver_returns` — depends on `bronze_yahoo`, wraps returns/vol/z-score computation
3. `silver_macro` — depends on `bronze_bcb_sgs`, `bronze_fred`, wraps macro calculation transforms

Each uses `@asset(group_name="silver", deps=[...])` with appropriate Bronze asset dependencies. RetryPolicy same as Bronze. Returns status dict.

**src/orchestration/assets_agents.py**: Define 5 Agent assets with the correct dependency chain (matching AgentRegistry.EXECUTION_ORDER):

1. `agent_inflation` — depends on all Silver assets
2. `agent_monetary_policy` — depends on `agent_inflation` + Silver assets
3. `agent_fiscal` — depends on Silver assets
4. `agent_fx_equilibrium` — depends on Silver assets
5. `agent_cross_asset` — depends on all 4 prior agents + Silver assets

Each agent asset:
- Uses `@asset(group_name="agents")` with appropriate deps
- Calls the agent via `AgentRegistry.get(agent_name).backtest_run(as_of_date)` for partition-aware runs
- Returns AgentReport summary dict (signal_count, regime, etc.)
- Uses RetryPolicy(max_retries=3, delay=30)

All asset modules use `from dagster import asset, AssetExecutionContext, RetryPolicy, DailyPartitionsDefinition`.
  </action>
  <verify>
Run `python -c "from src.orchestration.assets_bronze import *; from src.orchestration.assets_silver import *; from src.orchestration.assets_agents import *; print('All asset modules import OK')"` — must succeed without ImportError.
  </verify>
  <done>
6 Bronze assets, 3 Silver assets, and 5 Agent assets defined as Dagster @asset functions with retry policies, daily partitions, and correct dependency chains.
  </done>
</task>

<task type="auto">
  <name>Task 2: Dagster Definitions module, Docker Compose service, Makefile targets</name>
  <files>
    src/orchestration/definitions.py
    docker-compose.yml
    Makefile
  </files>
  <action>
**src/orchestration/definitions.py**: Create the central Dagster Definitions object:

```python
from dagster import Definitions, ScheduleDefinition, define_asset_job

# Import all assets
from src.orchestration.assets_bronze import (
    bronze_bcb_sgs, bronze_fred, bronze_yahoo,
    bronze_bcb_ptax, bronze_b3_market_data, bronze_treasury_gov,
)
from src.orchestration.assets_silver import (
    silver_curves, silver_returns, silver_macro,
)
from src.orchestration.assets_agents import (
    agent_inflation, agent_monetary_policy, agent_fiscal,
    agent_fx_equilibrium, agent_cross_asset,
)

all_assets = [
    # Bronze
    bronze_bcb_sgs, bronze_fred, bronze_yahoo,
    bronze_bcb_ptax, bronze_b3_market_data, bronze_treasury_gov,
    # Silver
    silver_curves, silver_returns, silver_macro,
    # Agents
    agent_inflation, agent_monetary_policy, agent_fiscal,
    agent_fx_equilibrium, agent_cross_asset,
]

# Full pipeline job
daily_pipeline_job = define_asset_job(
    name="daily_pipeline",
    selection=all_assets,
    description="Full daily pipeline: Bronze -> Silver -> Agents",
)

# Cron schedule: 6:00 AM BRT (09:00 UTC) per user decision
daily_schedule = ScheduleDefinition(
    job=daily_pipeline_job,
    cron_schedule="0 9 * * 1-5",  # 09:00 UTC = 06:00 BRT, weekdays only
    name="daily_pipeline_schedule",
)

defs = Definitions(
    assets=all_assets,
    schedules=[daily_schedule],
    jobs=[daily_pipeline_job],
)
```

Note: The `defs` variable is the Dagster convention for the Definitions entry point. Dagster automatically discovers it.

**docker-compose.yml**: Add dagster-webserver service after the existing minio service (before the volumes section). The service should:
- Use `dagster/dagster-k8s:latest` image (or `python:3.11-slim` with dagster installed via pip)
- Actually, use a build context approach: add a Dockerfile.dagster or use the existing project with dagster installed
- Simpler approach: use `python:3.11-slim` with a command that installs dagster and runs dagster-webserver
- Best approach for this project: mount the project directory and run dagster-webserver pointing to the definitions module

```yaml
  dagster-webserver:
    image: python:3.11-slim
    container_name: macro_dagster
    working_dir: /app
    volumes:
      - .:/app
    ports:
      - "3001:3001"
    environment:
      DAGSTER_HOME: /app/.dagster
      DATABASE_URL: postgresql://macro_user:macro_pass@timescaledb:5432/macro_trading
      REDIS_URL: redis://redis:6379/0
    command: >
      bash -c "pip install -q dagster dagster-webserver dagster-postgres &&
               pip install -q -e /app &&
               mkdir -p /app/.dagster &&
               dagster-webserver -h 0.0.0.0 -p 3001 -m src.orchestration.definitions"
    depends_on:
      timescaledb:
        condition: service_healthy
      redis:
        condition: service_healthy
    profiles:
      - dagster
    restart: unless-stopped
```

Use the `dagster` profile so it does not start by default with `docker compose up`. Create `.dagster/dagster.yaml` config file with:
```yaml
telemetry:
  enabled: false
```

**Makefile**: Add two targets after the existing "Integration Tests" section:

```makefile
# ── Dagster Orchestration ────────────────────────────────────────────
# Start Dagster webserver (UI at http://localhost:3001)
dagster:
	docker compose --profile dagster up -d dagster-webserver
	@echo "Dagster UI available at http://localhost:3001"

# Run full pipeline (materialize all assets in dependency order)
dagster-run-all:
	docker compose --profile dagster exec dagster-webserver dagster asset materialize --select '*' -m src.orchestration.definitions
```

Update the `.PHONY` line at the top of Makefile to include `dagster dagster-run-all`.
  </action>
  <verify>
1. Run `python -c "from src.orchestration.definitions import defs; print(f'Assets: {len(defs.get_asset_graph().all_asset_keys)}'); print('Definitions OK')"` — must show 14 assets.
2. Run `grep -c 'dagster' Makefile` — must be >= 2 (the two targets).
3. Run `grep 'dagster-webserver' docker-compose.yml` — must find the service.
  </verify>
  <done>
Dagster Definitions module registers all 14 assets (6 Bronze + 3 Silver + 5 Agents) with a daily cron schedule at 06:00 BRT, Docker Compose service runs dagster-webserver on port 3001, and Makefile has `dagster` and `dagster-run-all` targets.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.orchestration.definitions import defs; print('OK')"` succeeds
2. `grep -q 'dagster-webserver' docker-compose.yml && echo "Docker service OK"`
3. `grep -q 'dagster-run-all' Makefile && echo "Makefile OK"`
4. All imports resolve without errors
</verification>

<success_criteria>
- 14 Dagster asset definitions (6 Bronze + 3 Silver + 5 Agents) are importable and registered in the Definitions object
- Docker Compose has dagster-webserver service on port 3001 under `dagster` profile
- Makefile has `make dagster` and `make dagster-run-all` targets
- Bronze assets have DailyPartitionsDefinition for backfill support
- All assets have RetryPolicy(max_retries=3) per user decision
- Daily schedule runs at 09:00 UTC (06:00 BRT) on weekdays
</success_criteria>

<output>
After completion, create `.planning/phases/18-dagster-orchestration-monitoring-reporting/18-01-SUMMARY.md`
</output>
