---
phase: 18-dagster-orchestration-monitoring-reporting
plan: 04
type: execute
wave: 2
depends_on:
  - 18-01
  - 18-03
files_modified:
  - src/monitoring/__init__.py
  - src/monitoring/alert_manager.py
  - src/monitoring/alert_rules.py
  - src/api/routes/monitoring_api.py
  - src/reporting/__init__.py
  - src/reporting/daily_report.py
  - src/reporting/templates.py
  - src/api/routes/reports_api.py
  - src/api/main.py
autonomous: true
requirements:
  - MNTR-03
  - MNTR-04
  - REPT-01
  - REPT-02
  - REPT-03

must_haves:
  truths:
    - "AlertManager evaluates 10 rules and sends notifications to both Slack and email per user decision"
    - "30-minute cooldown per alert type prevents notification flooding"
    - "Alert rules are runtime configurable via API endpoints without redeployment"
    - "GET /api/v1/monitoring/alerts returns active alerts, /pipeline-status returns pipeline health, /system-health returns overall system status"
    - "POST /api/v1/monitoring/test-alert triggers a test notification"
    - "DailyReportGenerator produces 7 sections (Market Snapshot, Regime, Agent Views, Signals, Portfolio, Risk, Actions) in markdown and HTML"
    - "Actions section includes concrete trade recommendations with sizing, instruments, and rationale"
    - "GET /api/v1/reports/daily/latest returns the most recent daily report"
    - "POST /api/v1/reports/daily/send delivers full HTML via email and condensed summary to Slack"
  artifacts:
    - path: "src/monitoring/__init__.py"
      provides: "Monitoring package init"
    - path: "src/monitoring/alert_manager.py"
      provides: "AlertManager with cooldown, Slack, email dispatch"
      min_lines: 120
    - path: "src/monitoring/alert_rules.py"
      provides: "10 alert rule definitions with configurable thresholds"
      min_lines: 100
    - path: "src/api/routes/monitoring_api.py"
      provides: "4 monitoring API endpoints"
      min_lines: 80
    - path: "src/reporting/__init__.py"
      provides: "Reporting package init"
    - path: "src/reporting/daily_report.py"
      provides: "DailyReportGenerator with 7 sections and 4 output methods"
      min_lines: 200
    - path: "src/reporting/templates.py"
      provides: "HTML and Slack templates for report rendering"
      min_lines: 100
    - path: "src/api/routes/reports_api.py"
      provides: "3 report API endpoints"
      min_lines: 60
  key_links:
    - from: "src/monitoring/alert_manager.py"
      to: "src/monitoring/alert_rules.py"
      via: "AlertManager loads and evaluates rules"
      pattern: "alert_rules"
    - from: "src/monitoring/alert_manager.py"
      to: "Slack webhook / SMTP"
      via: "send_slack() and send_email() dispatch"
      pattern: "send_slack|send_email"
    - from: "src/reporting/daily_report.py"
      to: "src/reporting/templates.py"
      via: "HTML template rendering"
      pattern: "from src\\.reporting\\.templates"
    - from: "src/api/routes/monitoring_api.py"
      to: "src/monitoring/alert_manager.py"
      via: "AlertManager instance for API"
      pattern: "AlertManager"
    - from: "src/api/routes/reports_api.py"
      to: "src/reporting/daily_report.py"
      via: "DailyReportGenerator for API"
      pattern: "DailyReportGenerator"
    - from: "src/api/main.py"
      to: "src/api/routes/monitoring_api.py"
      via: "Router inclusion"
      pattern: "monitoring_api"
---

<objective>
Implement the AlertManager with 10 configurable alert rules (Slack + email notification), monitoring API endpoints, DailyReportGenerator with 7 sections in markdown/HTML formats, and report API endpoints.

Purpose: AlertManager makes the system proactively notify operators of risk breaches and pipeline issues. DailyReportGenerator produces comprehensive daily reports with concrete trade recommendations, delivered via email (full HTML) and Slack (condensed summary). Together they complete the "see" and "read" pillars of observability.

Output: `src/monitoring/` package (AlertManager, 10 rules), `src/reporting/` package (DailyReportGenerator, templates), monitoring + report API routes, updated main.py.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/18-dagster-orchestration-monitoring-reporting/18-01-SUMMARY.md
@src/risk/var_calculator.py
@src/risk/risk_limits_v2.py
@src/risk/drawdown_manager.py
@src/portfolio/signal_aggregator.py
@src/narrative/generator.py
@src/api/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: AlertManager with 10 rules, Slack + email notifications, and monitoring API</name>
  <files>
    src/monitoring/__init__.py
    src/monitoring/alert_manager.py
    src/monitoring/alert_rules.py
    src/api/routes/monitoring_api.py
    src/api/main.py
  </files>
  <action>
Create `src/monitoring/` package.

**src/monitoring/__init__.py**: Package init exporting `AlertManager`, `AlertRule`.

**src/monitoring/alert_rules.py**: Define the 10 alert rules as data-driven rule definitions.

Create an `AlertRule` dataclass:
```python
@dataclass
class AlertRule:
    rule_id: str           # e.g., "STALE_DATA"
    name: str              # Human-readable name
    description: str       # What this rule detects
    severity: str          # "warning" or "critical"
    enabled: bool          # Runtime toggle (default True)
    threshold: float       # Configurable threshold value
    cooldown_minutes: int  # Default 30 per user decision
    check_fn: Callable     # Function(context_dict) -> bool (True = alert fires)
```

Define 10 rules in a `DEFAULT_RULES` list:
1. `STALE_DATA` — severity: warning, threshold: 3600 (seconds). Fires when any connector's last successful run is older than threshold. check_fn examines pipeline_status dict for `last_run_age > threshold`.
2. `VAR_BREACH` — severity: warning, threshold: 0.05 (5%). Fires when VaR 95% exceeds threshold.
3. `VAR_CRITICAL` — severity: critical, threshold: 0.08 (8%). Fires when VaR 99% exceeds threshold.
4. `DRAWDOWN_WARNING` — severity: warning, threshold: 0.05 (5%). Fires when current drawdown exceeds threshold.
5. `DRAWDOWN_CRITICAL` — severity: critical, threshold: 0.10 (10%). Fires when drawdown exceeds threshold.
6. `LIMIT_BREACH` — severity: critical, threshold: 1.0 (100% utilization). Fires when any risk limit utilization >= threshold.
7. `SIGNAL_FLIP` — severity: warning, threshold: 1 (count). Fires when signal flip count in last 24h >= threshold.
8. `CONVICTION_SURGE` — severity: warning, threshold: 0.3. Fires when any signal conviction change > threshold (matching Phase 17 SignalMonitor definition).
9. `PIPELINE_FAILURE` — severity: critical, threshold: 0 (any failure). Fires when pipeline run status = "FAILED".
10. `AGENT_STALE` — severity: warning, threshold: 86400 (24h in seconds). Fires when any agent's last report is older than threshold.

Each rule's `check_fn` is a standalone function that receives a `context: dict` (containing latest pipeline status, risk metrics, signal monitor output, agent timestamps) and returns `bool`.

**src/monitoring/alert_manager.py**: Implement AlertManager class:

```python
class AlertManager:
    def __init__(self, rules: list[AlertRule] | None = None,
                 slack_webhook_url: str | None = None,
                 email_config: dict | None = None):
        self.rules = {r.rule_id: r for r in (rules or DEFAULT_RULES)}
        self.slack_webhook_url = slack_webhook_url or os.environ.get("SLACK_WEBHOOK_URL")
        self.email_config = email_config or self._load_email_config()
        self._last_fired: dict[str, datetime] = {}  # rule_id -> last fire time
        self._logger = structlog.get_logger("alert_manager")
```

Methods:
- `evaluate(context: dict) -> list[dict]`: Iterate enabled rules, call check_fn(context), check cooldown (30 min per user decision). For each triggered alert not in cooldown: create alert dict, dispatch to Slack and email (per user decision: all alerts go to both channels regardless of severity), update _last_fired. Returns list of fired alert dicts.
- `send_slack(alert: dict)`: POST to SLACK_WEBHOOK_URL using `urllib.request.urlopen()` (matching Phase 12 AlertDispatcher pattern). Format message with alert name, severity, description, timestamp. Use Slack Block Kit with section blocks for structured message.
- `send_email(alert: dict)`: Send via `smtplib.SMTP` using email_config (host, port, user, password, recipients). HTML email with alert details. Use `email.mime.multipart.MIMEMultipart` for formatting. Graceful fallback: log warning if SMTP config missing, do not crash.
- `enable_rule(rule_id: str)`: Set rule.enabled = True. Runtime configurable per user decision.
- `disable_rule(rule_id: str)`: Set rule.enabled = False.
- `update_threshold(rule_id: str, threshold: float)`: Update rule threshold at runtime.
- `get_active_alerts() -> list[dict]`: Return all alerts fired within the last cooldown window.
- `_in_cooldown(rule_id: str) -> bool`: Check if rule was fired within cooldown_minutes.
- `_load_email_config() -> dict`: Load from env vars (SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS, ALERT_RECIPIENTS).

**src/api/routes/monitoring_api.py**: Create 4 monitoring API endpoints using FastAPI APIRouter:

```python
router = APIRouter(prefix="/api/v1/monitoring", tags=["monitoring"])
```

1. `GET /api/v1/monitoring/alerts` — Returns active alerts from AlertManager. Response: `{"status": "ok", "data": {"alerts": [...], "total": N}, "meta": {"timestamp": "..."}}`
2. `GET /api/v1/monitoring/pipeline-status` — Returns pipeline health summary (per-connector last run time, status, duration). Uses sample data for now (similar to Phase 17 API pattern).
3. `GET /api/v1/monitoring/system-health` — Returns overall system health: database connectivity, Redis ping, pipeline last run, agent freshness, risk status. Aggregate into overall status (healthy/degraded/unhealthy).
4. `POST /api/v1/monitoring/test-alert` — Triggers a test alert notification to both Slack and email channels. Accepts optional `{"channel": "slack|email|both"}` body.

Follow the response envelope pattern from Phase 13: `{status: "ok", data: ..., meta: {timestamp: ...}}`.

**src/api/main.py**: Add the monitoring router import and include:
```python
from src.api.routes.monitoring_api import router as monitoring_router
app.include_router(monitoring_router)
```
  </action>
  <verify>
1. Run `python -c "from src.monitoring.alert_rules import DEFAULT_RULES; print(f'Rules: {len(DEFAULT_RULES)}'); assert len(DEFAULT_RULES) == 10"` — must show 10 rules.
2. Run `python -c "from src.monitoring.alert_manager import AlertManager; am = AlertManager(); print(f'AlertManager with {len(am.rules)} rules OK')"` — must succeed.
3. Run `python -c "from src.api.routes.monitoring_api import router; print(f'Monitoring routes: {len(router.routes)}')"` — must show 4 routes.
  </verify>
  <done>
AlertManager evaluates 10 rules with 30-minute cooldown, dispatches to both Slack and email, supports runtime enable/disable and threshold adjustment via API. 4 monitoring API endpoints serve alerts, pipeline status, system health, and test alerts.
  </done>
</task>

<task type="auto">
  <name>Task 2: DailyReportGenerator with 7 sections, markdown/HTML/email/Slack output, and report API</name>
  <files>
    src/reporting/__init__.py
    src/reporting/daily_report.py
    src/reporting/templates.py
    src/api/routes/reports_api.py
    src/api/main.py
  </files>
  <action>
Create `src/reporting/` package.

**src/reporting/__init__.py**: Package init exporting `DailyReportGenerator`, `ReportSection`.

**src/reporting/templates.py**: HTML and Slack templates for report rendering.

Define HTML template as a multi-line string constant `HTML_REPORT_TEMPLATE` with:
- Professional email-friendly HTML (inline CSS, max-width 800px, sans-serif font)
- Header with report date and generation timestamp
- 7 section containers with section headers, tables, and embedded chart placeholders
- Color-coded elements: green for positive, red for negative, yellow for warnings
- Base64 image embedding support via `{chart_placeholder}` markers
- Footer with "Generated by Macro Trading System"

Define `SLACK_SUMMARY_TEMPLATE` as a Slack Block Kit JSON structure (Claude's discretion on formatting):
- Header block with report date
- Section blocks for key metrics: portfolio return, VaR, regime, top signals
- Divider blocks between sections
- Context block with link to full HTML report URL
- Keep condensed: 6-8 blocks max for quick scan per user decision (condensed summary, not full report)

Helper functions:
- `render_html(sections: dict, charts: dict[str, str]) -> str`: Fill HTML template with section data and base64 chart images
- `render_slack_blocks(summary: dict) -> list[dict]`: Generate Slack Block Kit blocks from summary data
- `render_markdown(sections: dict) -> str`: Generate markdown report with tables and headers

**src/reporting/daily_report.py**: Implement DailyReportGenerator class.

```python
class DailyReportGenerator:
    def __init__(self, as_of_date: date | None = None):
        self.as_of_date = as_of_date or date.today()
        self.sections: dict[str, ReportSection] = {}
        self._logger = structlog.get_logger("daily_report")
```

Define `ReportSection` dataclass:
```python
@dataclass
class ReportSection:
    title: str
    content: dict[str, Any]  # Section-specific structured data
    charts: list[str]  # Base64-encoded chart images
    commentary: str  # Text commentary for this section
```

Methods:
- `generate(pipeline_context: dict | None = None) -> dict`: Build all 7 sections from pipeline context (or sample data if no context). Returns dict with all sections populated. Sections:

  1. **Market Snapshot** (`_build_market_snapshot`): Key market levels (IBOV, USDBRL, DI 1Y, Selic, IPCA, VIX, SPX, UST 10Y), daily changes, weekly changes. Source: latest market_data and macro_series. Table format.

  2. **Regime Assessment** (`_build_regime`): Current regime classification (Goldilocks/Reflation/Stagflation/Deflation), regime probabilities, key drivers, transition risk. Source: CrossAssetAgent view.

  3. **Agent Views** (`_build_agent_views`): Per-agent summary: signal direction, strength, confidence, key drivers, and narrative excerpt. Table with 5 rows (one per agent). Source: AgentRegistry results.

  4. **Signal Summary** (`_build_signals`): Aggregated signals by asset class, top 5 highest-conviction signals, signal flips in last 24h, crowding warnings. Source: SignalAggregatorV2 and SignalMonitor.

  5. **Portfolio Status** (`_build_portfolio`): Current positions, target weights vs actual, leverage, rebalance trades needed, P&L attribution by strategy. Source: PortfolioOptimizer and PositionSizer.

  6. **Risk Metrics** (`_build_risk`): VaR (95%/99%), CVaR, worst stress scenario impact, limit utilization summary, circuit breaker status, risk budget remaining. Source: VaRCalculator, StressTester, RiskLimitsManagerV2.

  7. **Action Items** (`_build_actions`): Concrete trade recommendations per user decision ("Increase DI1 short by 20 contracts" not "DI1 signal shifted bearish"). Include instrument, direction, size, rationale, priority (high/medium/low). Source: Synthesized from portfolio targets, signal changes, and risk constraints.

- `to_markdown() -> str`: Call `templates.render_markdown(self.sections)`. Returns formatted markdown string.
- `to_html() -> str`: Generate charts via matplotlib (equity curve, VaR gauge, etc.) as base64 PNG strings. Call `templates.render_html(self.sections, charts)`. Returns complete HTML document.
- `send_email(recipients: list[str] | None = None) -> bool`: Generate HTML via `to_html()`, send via smtplib. Use SMTP config from env vars (SMTP_HOST, SMTP_PORT, SMTP_USER, SMTP_PASS). Subject: f"Macro Trading Daily Report - {self.as_of_date}". Return True on success, log error on failure.
- `send_slack(webhook_url: str | None = None) -> bool`: Generate condensed summary dict (portfolio return, VaR, regime, top 3 signals, action count). Call `templates.render_slack_blocks(summary)`. POST to webhook_url using urllib.request. Per user decision: condensed summary + link to full report, not inline. Return True on success.

Each section builder returns a `ReportSection` instance. Use sample/placeholder data when pipeline_context is None (same pattern as Phase 17 API endpoints with deterministic seed=42 for consistent demos).

**src/api/routes/reports_api.py**: Create 3 report API endpoints:

```python
router = APIRouter(prefix="/api/v1/reports", tags=["reports"])
```

1. `GET /api/v1/reports/daily` — List recent daily reports (last 7 days). Returns list of report metadata (date, generation time, section count).
2. `GET /api/v1/reports/daily/latest` — Returns the most recent daily report. Calls `DailyReportGenerator().generate()` and returns the full report data as JSON (sections with content and commentary). Also includes `html_url` and `markdown_url` links.
3. `POST /api/v1/reports/daily/send` — Triggers report generation and delivery. Accepts body `{"channels": ["email", "slack"], "recipients": ["..."], "date": "YYYY-MM-DD"}`. Calls `generate()`, then `send_email()` and/or `send_slack()` based on channels. Returns delivery status.

Follow response envelope: `{status: "ok", data: ..., meta: {timestamp: ...}}`.

**src/api/main.py**: Add the reports router import and include:
```python
from src.api.routes.reports_api import router as reports_router
app.include_router(reports_router)
```

Make sure to not duplicate the monitoring_router include from Task 1 — if both tasks run in sequence, only add the reports_router in this task.
  </action>
  <verify>
1. Run `python -c "from src.reporting.daily_report import DailyReportGenerator; rg = DailyReportGenerator(); report = rg.generate(); print(f'Sections: {len(report)}'); assert len(report) == 7"` — must show 7 sections.
2. Run `python -c "from src.reporting.daily_report import DailyReportGenerator; rg = DailyReportGenerator(); md = rg.to_markdown(); print(f'Markdown length: {len(md)} chars'); assert len(md) > 500"` — must produce substantial markdown.
3. Run `python -c "from src.reporting.daily_report import DailyReportGenerator; rg = DailyReportGenerator(); html = rg.to_html(); print(f'HTML length: {len(html)} chars'); assert '<html' in html.lower()"` — must produce valid HTML.
4. Run `python -c "from src.api.routes.reports_api import router; print(f'Report routes: {len(router.routes)}')"` — must show 3 routes.
5. Run `python -c "from src.monitoring.alert_rules import DEFAULT_RULES; from src.reporting.daily_report import DailyReportGenerator; print('Both packages import OK')"` — cross-package imports work.
  </verify>
  <done>
DailyReportGenerator produces 7 sections (Market Snapshot, Regime, Agent Views, Signals, Portfolio, Risk, Actions) with concrete trade recommendations in the Actions section. Outputs in markdown (to_markdown), HTML (to_html with embedded base64 charts), email (send_email with full HTML), and Slack (send_slack with condensed summary + link). 3 report API endpoints serve daily reports and trigger delivery. All new routers registered in main.py.
  </done>
</task>

</tasks>

<verification>
1. `python -c "from src.monitoring.alert_manager import AlertManager; print('AlertManager OK')"` succeeds
2. `python -c "from src.reporting.daily_report import DailyReportGenerator; print('DailyReportGenerator OK')"` succeeds
3. AlertManager has 10 rules, 30-minute cooldown, Slack + email dispatch
4. DailyReportGenerator produces 7 sections with markdown, HTML, email, and Slack output
5. All 7 API endpoints (4 monitoring + 3 reports) are registered in main.py
6. Actions section contains concrete trade recommendations (instrument + direction + size + rationale)
</verification>

<success_criteria>
- 10 alert rules defined and evaluatable by AlertManager
- 30-minute cooldown prevents notification flooding
- Alert rules are runtime configurable (enable/disable, threshold adjustment) via API
- All alerts dispatch to both Slack and email per user decision
- DailyReportGenerator produces 7 sections matching spec (Market Snapshot, Regime, Agent Views, Signals, Portfolio, Risk, Actions)
- Actions section has concrete trade recommendations ("Increase DI1 short by 20 contracts")
- to_markdown() produces formatted markdown, to_html() produces professional HTML with embedded charts
- send_email() delivers full HTML report, send_slack() delivers condensed summary with link
- GET /api/v1/reports/daily/latest returns complete report data
- POST /api/v1/reports/daily/send triggers delivery
- 4 monitoring API endpoints operational
</success_criteria>

<output>
After completion, create `.planning/phases/18-dagster-orchestration-monitoring-reporting/18-04-SUMMARY.md`
</output>
