---
phase: 15-new-trading-strategies
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - src/strategies/sov_01_cds_curve.py
  - src/strategies/sov_02_em_relative_value.py
  - src/strategies/sov_03_rating_migration.py
  - src/strategies/cross_01_regime_allocation.py
  - src/strategies/cross_02_risk_appetite.py
  - tests/test_strategies/test_sov_cross_new.py
autonomous: true
requirements: [SVST-01, SVST-02, SVST-03, CAST-01, CAST-02]

must_haves:
  truths:
    - "SOV-01 generates StrategySignal trading Brazil CDS 1Y/5Y/10Y slope and level based on fiscal agent output and z-scores"
    - "SOV-02 generates StrategySignal from cross-section regression of CDS vs fundamentals for 10 EM peers, trading Brazil residual"
    - "SOV-03 generates StrategySignal from logistic model for upgrade/downgrade probability based on fiscal, growth, external, political factors"
    - "CROSS-01 generates StrategySignal with 4-state regime classification (Goldilocks, Reflation, Stagflation, Deflation) and regime-dependent allocation trades"
    - "CROSS-02 generates StrategySignal from proprietary risk appetite composite index using market-based indicators only"
    - "Cross-asset strategies produce both regime/risk-appetite scores AND explicit trade recommendations"
    - "Regime interaction modulates sizing, not override -- regime-misaligned strategies get reduced sizing but are never hard-suppressed"
    - "All 5 strategies return empty list when data is missing"
  artifacts:
    - path: "src/strategies/sov_01_cds_curve.py"
      provides: "SOV-01 CDS Curve Trading strategy"
      contains: "@StrategyRegistry.register"
    - path: "src/strategies/sov_02_em_relative_value.py"
      provides: "SOV-02 EM Sovereign Relative Value strategy"
      contains: "@StrategyRegistry.register"
    - path: "src/strategies/sov_03_rating_migration.py"
      provides: "SOV-03 Rating Migration Anticipation strategy"
      contains: "@StrategyRegistry.register"
    - path: "src/strategies/cross_01_regime_allocation.py"
      provides: "CROSS-01 Macro Regime Allocation strategy"
      contains: "@StrategyRegistry.register"
    - path: "src/strategies/cross_02_risk_appetite.py"
      provides: "CROSS-02 Global Risk Appetite strategy"
      contains: "@StrategyRegistry.register"
    - path: "tests/test_strategies/test_sov_cross_new.py"
      provides: "Unit tests for SOV-01/02/03 and CROSS-01/02"
      min_lines: 140
  key_links:
    - from: "src/strategies/cross_01_regime_allocation.py"
      to: "PointInTimeDataLoader"
      via: "get_macro_series, get_market_data for regime classification inputs"
      pattern: "self\\.data_loader\\."
    - from: "src/strategies/cross_02_risk_appetite.py"
      to: "PointInTimeDataLoader"
      via: "get_market_data for VIX, credit spreads, FX vol"
      pattern: "self\\.data_loader\\.get_market_data"
---

<objective>
Implement 5 strategies: SOV-01 (CDS Curve Trading), SOV-02 (EM Relative Value), SOV-03 (Rating Migration), CROSS-01 (Macro Regime Allocation), and CROSS-02 (Global Risk Appetite). Sovereign strategies trade Brazil credit risk, while cross-asset strategies classify regimes and produce explicit trade recommendations across asset classes.

Purpose: Complete the 16-strategy expansion by adding sovereign credit trading and cross-asset regime-driven allocation -- the two most strategic categories that drive top-down macro positioning.

Output: 5 strategy files + 1 test file.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/14-backtesting-engine-v2-strategy-framework/14-01-SUMMARY.md
@.planning/phases/15-new-trading-strategies/15-CONTEXT.md

# Key existing files:
@src/strategies/base.py
@src/strategies/registry.py
@src/strategies/sov_br_01_fiscal_risk.py
@src/strategies/__init__.py
@src/agents/data_loader.py
@src/agents/cross_asset/models.py
@src/core/enums.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement SOV-01 CDS Curve, SOV-02 EM Relative Value, and SOV-03 Rating Migration strategies</name>
  <files>
    src/strategies/sov_01_cds_curve.py
    src/strategies/sov_02_em_relative_value.py
    src/strategies/sov_03_rating_migration.py
  </files>
  <action>
Create 3 sovereign credit strategy files following existing sov_br_01_fiscal_risk.py pattern.

**SOV-01: CDS Curve Trading** (`sov_01_cds_curve.py`):
- Register with `@StrategyRegistry.register("SOV_01", asset_class=AssetClass.SOVEREIGN_CREDIT, instruments=["CDS_BR"])`
- Trade Brazil CDS 1Y/5Y/10Y slope and level:
  1. Load Brazil CDS data from macro_series:
     - `data_loader.get_macro_series("BR_CDS_5Y", as_of_date, lookback_days=1260)` for 5Y CDS level and history.
     - Also try "BR_CDS_1Y" and "BR_CDS_10Y". If multiple tenors unavailable, use 5Y only.
  2. **Level signal**: Z-score of current 5Y CDS vs 252-day history. High z = credit stress.
  3. **Slope signal**: If 1Y and 5Y available, slope = CDS_5Y - CDS_1Y. Z-score vs history. Inverted slope (1Y > 5Y) = acute near-term stress.
  4. **Fiscal input**: Load fiscal indicators as supplementary signal:
     - `data_loader.get_latest_macro_value("BR_GROSS_DEBT_PCT_GDP", as_of_date)`. If > 80% = bearish, if < 70% = neutral.
     - Fiscal factor = (debt_pct - 75) / 10 clamped to [-1, 1].
  5. Composite: 0.50 * level_z + 0.30 * slope_z + 0.20 * fiscal_factor.
- Direction: composite > 0 (credit stress elevated) => expect mean reversion if z < 3, so SHORT CDS (sell protection). If z > 3, follow trend = LONG CDS (buy protection for tail hedge).
- Entry threshold: |composite_z| >= 1.25
- Stop-loss: 15% of CDS level (credit moves can be large)
- Take-profit: 10% of CDS level
- holding_period_days: 21

**SOV-02: EM Sovereign Relative Value** (`sov_02_em_relative_value.py`):
- Register with `@StrategyRegistry.register("SOV_02", asset_class=AssetClass.SOVEREIGN_CREDIT, instruments=["CDS_BR"])`
- Cross-section regression of CDS vs fundamentals for EM peers:
  1. Define 10 EM peers with hardcoded fundamental scores (updated periodically):
     - Peers: Brazil, Mexico, Colombia, Chile, Peru, South Africa, Turkey, Indonesia, India, Russia (or substitute if sanctioned — use Poland).
     - For each peer, define a fundamentals dict with: `debt_to_gdp`, `current_account_pct`, `inflation_yoy`, `growth_yoy`, `political_stability_score` (0-100). These are hardcoded/semi-static values representing medium-term fundamentals (updated quarterly-ish in the code).
  2. Load Brazil CDS: `data_loader.get_macro_series("BR_CDS_5Y", ...)`.
  3. **Cross-section model**: Run OLS regression of CDS_level ~ debt_to_gdp + current_account + inflation + growth + political. Use the 10 peers' fundamentals and their approximate CDS levels (hardcoded or loaded if available).
  4. Brazil **residual** = actual_BR_CDS - model_predicted_BR_CDS. Positive residual = Brazil CDS is expensive relative to fundamentals.
  5. Z-score the residual vs 252-day rolling history.
- Direction: residual_z > 0 (Brazil CDS expensive) => SHORT CDS (sell protection, expect mean reversion). residual_z < 0 => LONG CDS.
- Entry threshold: |residual_z| >= 1.5
- Since peer data is semi-static, this strategy focuses on Brazil CDS dynamics vs its predicted fair value.
- Stop-loss: 20% of CDS level
- Take-profit: 15% of CDS level
- holding_period_days: 28

**SOV-03: Rating Migration Anticipation** (`sov_03_rating_migration.py`):
- Register with `@StrategyRegistry.register("SOV_03", asset_class=AssetClass.SOVEREIGN_CREDIT, instruments=["CDS_BR", "DI_PRE"])`
- Logistic model for upgrade/downgrade probability:
  1. Define 4 input factors:
     a. **Fiscal factor**: debt_pct_gdp from `get_latest_macro_value("BR_GROSS_DEBT_PCT_GDP", ...)`. Transform: (debt - 80) / 10, clamped [-2, 2]. Higher = worse.
     b. **Growth factor**: GDP growth from `get_latest_macro_value("BR_GDP_GROWTH_YOY", ...)` or IBC-Br proxy. Transform: -(gdp - 2.0) / 1.5. Negative because high growth is good for rating.
     c. **External factor**: current account or trade balance. Use FX flow net as proxy: `get_latest_macro_value("BR_TRADE_BALANCE", ...)` or flow data. Transform: -(trade_balance_z) (surplus is positive for rating).
     d. **Political/institutional factor**: Use CDS level change momentum as proxy for market-perceived institutional risk. 63-day CDS change z-score.
  2. **Logistic probability**: p_downgrade = 1 / (1 + exp(-(w1*fiscal + w2*growth + w3*external + w4*political)))
     - Weights: w_fiscal=0.35, w_growth=0.25, w_external=0.20, w_political=0.20.
     - p_upgrade = 1 - p_downgrade (simplified binary model).
  3. **Signal**: If p_downgrade > 0.65 => LONG CDS (buy protection, anticipating downgrade). If p_downgrade < 0.35 (p_upgrade > 0.65) => SHORT CDS (sell protection, anticipating upgrade). Between 0.35-0.65 => no signal.
  4. Z-score = logit(p_downgrade) - logit(0.5) normalized by historical std.
- Entry threshold: |z| >= 1.0 (equivalent to p outside 0.35-0.65 range)
- Stop-loss: 20% of CDS level
- Take-profit: 15%
- holding_period_days: 28 (rating changes are slow)
  </action>
  <verify>
    python -c "
from src.strategies.sov_01_cds_curve import Sov01CdsCurveStrategy
from src.strategies.sov_02_em_relative_value import Sov02EmRelativeValueStrategy
from src.strategies.sov_03_rating_migration import Sov03RatingMigrationStrategy
from src.strategies.registry import StrategyRegistry
for s in ['SOV_01', 'SOV_02', 'SOV_03']:
    assert s in StrategyRegistry.list_all(), f'{s} not registered'
print('SOV-01, SOV-02, SOV-03 registered successfully')
"
  </verify>
  <done>SOV-01, SOV-02, SOV-03 strategy classes exist with generate_signals; SOV-01 trades CDS curve level+slope+fiscal; SOV-02 uses cross-section regression residual; SOV-03 uses logistic downgrade probability</done>
</task>

<task type="auto">
  <name>Task 2: Implement CROSS-01 Regime Allocation, CROSS-02 Risk Appetite, tests, and update __init__.py</name>
  <files>
    src/strategies/cross_01_regime_allocation.py
    src/strategies/cross_02_risk_appetite.py
    src/strategies/__init__.py
    tests/test_strategies/test_sov_cross_new.py
  </files>
  <action>
**CROSS-01: Macro Regime Allocation** (`cross_01_regime_allocation.py`):
- Register with `@StrategyRegistry.register("CROSS_01", asset_class=AssetClass.CROSS_ASSET, instruments=["DI_PRE", "USDBRL", "IBOV_FUT", "NTN_B_REAL"])`
- 4-state regime classification with regime-dependent allocation:
  1. **Regime classification inputs** (all from data_loader):
     a. Growth: GDP proxy from IBC-Br or `get_latest_macro_value("BR_GDP_GROWTH_YOY", ...)`. Growth_z = z-score vs 252-day history.
     b. Inflation: `get_latest_macro_value("BR_IPCA_12M", ...)`. Inflation_z = z-score vs history.
     c. Financial conditions: DI short-end rate level. `get_curve("DI_PRE", ...)` 1Y rate. Rate_z = z-score.
     d. Risk appetite: USDBRL vol (21-day). Vol_z = z-score.
  2. **Regime classification rules** (rule-based, Phase 16 adds HMM on top):
     - **Goldilocks**: growth_z > 0 AND inflation_z < 0.5 (growth up, inflation contained)
     - **Reflation**: growth_z > 0 AND inflation_z > 0.5 (growth up, inflation rising)
     - **Stagflation**: growth_z < 0 AND inflation_z > 0.5 (growth down, inflation up)
     - **Deflation**: growth_z < 0 AND inflation_z < -0.5 (growth down, inflation falling)
     - Default to nearest regime if no clear classification.
  3. **Regime-dependent allocation map** (produces explicit trades per locked decision):
     - **Goldilocks**: LONG equities (IBOV), LONG DI (receive), SHORT USDBRL, LONG NTN-B
     - **Reflation**: LONG equities, SHORT DI (pay), LONG USDBRL, SHORT NTN-B
     - **Stagflation**: SHORT equities, SHORT DI (pay), LONG USDBRL, LONG CDS (not traded directly, so skip)
     - **Deflation**: NEUTRAL equities, LONG DI (receive), SHORT USDBRL, LONG NTN-B
  4. **Signal generation**: For each instrument in the allocation map, generate a StrategySignal with:
     - Direction from allocation map
     - z_score = max(|growth_z|, |inflation_z|) as regime conviction
     - Sizing modulated by regime conviction: stronger signals when regime classification is more extreme
  5. Store regime classification in metadata: `{"regime": "Goldilocks", "growth_z": ..., "inflation_z": ..., "regime_confidence": ...}`
- Per locked decision: regime modulates sizing, never hard-suppresses. Strategies not aligned with regime get 0.5x sizing multiplier stored in metadata for downstream consumers.
- Entry threshold: |regime_z| >= 0.5 (regimes should almost always produce a signal)
- Stop-loss: 3% per position
- Take-profit: 5% per position
- holding_period_days: 21

**CROSS-02: Global Risk Appetite** (`cross_02_risk_appetite.py`):
- Register with `@StrategyRegistry.register("CROSS_02", asset_class=AssetClass.CROSS_ASSET, instruments=["DI_PRE", "USDBRL", "IBOV_FUT"])`
- Proprietary composite risk appetite index from market-based indicators only (locked decision: no positioning/flow data):
  1. **Index components** (all loaded via data_loader):
     a. **VIX** (25%): `get_market_data("^VIX", ...)`. Z-score vs 252-day. High VIX = risk-off. Invert: component = -vix_z.
     b. **Credit spreads** (20%): BR CDS 5Y: `get_macro_series("BR_CDS_5Y", ...)`. Z-score. High CDS = risk-off. Invert: component = -cds_z.
     c. **FX implied vol** (15%): Use USDBRL realized vol (21-day) as proxy for implied vol. Z-score. High vol = risk-off. Invert: component = -vol_z.
     d. **Equity-bond correlation** (15%): Compute 63-day rolling correlation between equity returns (IBOVESPA) and DI rate changes. Positive correlation (stocks and rates move together) = risk-on environment. Component = correlation_z.
     e. **Funding spreads** (15%): DI short-end minus Selic. Tight = risk-on, wide = risk-off. Component = -spread_z.
     f. **Equity momentum** (10%): IBOVESPA 63-day return z-score. Positive = risk-on. Component = momentum_z.
  2. **Composite index**: weighted average of components = risk_appetite_score in [-3, +3] range typically.
  3. **Trade recommendations** (per locked decision: produce explicit trades):
     - risk_appetite > 1.0: Risk-on => LONG equities, SHORT USDBRL (long BRL), LONG DI (receive rates)
     - risk_appetite < -1.0: Risk-off => SHORT equities, LONG USDBRL, SHORT DI
     - Between -1.0 and 1.0: NEUTRAL, no signal
  4. Generate StrategySignal for each recommended instrument.
  5. Store index components in metadata: `{"risk_appetite": ..., "vix_z": ..., "cds_z": ..., ...}`
- Entry threshold: |risk_appetite| >= 1.0
- Stop-loss: 3%
- Take-profit: 4%
- holding_period_days: 14

**Update `src/strategies/__init__.py`**:
- Import all 5 new strategy classes
- Add to ALL_STRATEGIES dict: "SOV_01", "SOV_02", "SOV_03", "CROSS_01", "CROSS_02"
- Add to __all__ list
- At this point ALL_STRATEGIES should have 24 entries (8 existing + 16 new)

**Tests** (`tests/test_strategies/test_sov_cross_new.py`):
- Use mock PointInTimeDataLoader with MagicMock
- **SOV-01 tests (3 tests)**:
  - Test registration with AssetClass.SOVEREIGN_CREDIT
  - Test CDS level z-score produces signal with correct direction
  - Test missing CDS data returns empty list
- **SOV-02 tests (3 tests)**:
  - Test registration
  - Test positive residual (CDS expensive) => SHORT direction
  - Test missing BR_CDS_5Y returns empty list
- **SOV-03 tests (3 tests)**:
  - Test registration
  - Test high fiscal stress + low growth => p_downgrade > 0.65 => LONG CDS (buy protection)
  - Test favorable conditions => p_downgrade < 0.35 => SHORT CDS
- **CROSS-01 tests (4 tests)**:
  - Test registration with AssetClass.CROSS_ASSET
  - Test Goldilocks regime classification (growth up, inflation low)
  - Test Stagflation regime => SHORT equities, SHORT DI
  - Test regime metadata stored in signal
- **CROSS-02 tests (4 tests)**:
  - Test registration
  - Test high risk appetite (low VIX, low CDS, strong equity momentum) => risk-on trades
  - Test low risk appetite => risk-off trades
  - Test NEUTRAL when risk appetite between -1 and 1
- At least 17 tests total
  </action>
  <verify>
    python -c "
from src.strategies.registry import StrategyRegistry
all_strats = StrategyRegistry.list_all()
assert len(all_strats) >= 24, f'Expected 24+ strategies, got {len(all_strats)}'
for s in ['SOV_01', 'SOV_02', 'SOV_03', 'CROSS_01', 'CROSS_02']:
    assert s in all_strats, f'{s} not registered'
print(f'All sovereign and cross-asset strategies registered. Total: {len(all_strats)}')
" && python -m pytest tests/test_strategies/test_sov_cross_new.py -v --tb=short 2>&1 | tail -25
  </verify>
  <done>All 5 strategies registered, __init__.py has 24 total entries, CROSS-01 classifies 4 regimes with explicit trades, CROSS-02 produces risk appetite composite with market-only inputs, and >=17 tests pass</done>
</task>

</tasks>

<verification>
1. `python -c "from src.strategies.registry import StrategyRegistry; strats = StrategyRegistry.list_all(); print(f'Total: {len(strats)}'); print(strats)"` shows 24 strategies total
2. `python -c "from src.core.enums import AssetClass; from src.strategies.registry import StrategyRegistry; print(StrategyRegistry.list_by_asset_class(AssetClass.SOVEREIGN_CREDIT))"` returns SOV_BR_01 + SOV_01 + SOV_02 + SOV_03
3. `python -c "from src.core.enums import AssetClass; from src.strategies.registry import StrategyRegistry; print(StrategyRegistry.list_by_asset_class(AssetClass.CROSS_ASSET))"` returns CROSS_01 + CROSS_02
4. `python -m pytest tests/test_strategies/test_sov_cross_new.py -v` — all tests pass
5. CROSS-01 contains regime classification enum/dict and allocation map
6. CROSS-02 contains only market-based indicators (no flow/positioning data)
</verification>

<success_criteria>
- 5 new strategy files exist and are importable
- SOV-01 trades CDS curve level + slope + fiscal factor
- SOV-02 uses cross-section regression of 10 EM peers, trades Brazil residual
- SOV-03 uses logistic model with 4 factors for rating migration probability
- CROSS-01 classifies 4 regimes and produces regime-dependent allocation trades (not just scores)
- CROSS-02 builds risk appetite composite from market-only indicators and produces explicit trades
- Cross-asset strategies modulate sizing, never hard-suppress (locked decision)
- All strategies return empty on missing data
- Total strategies in registry = 24 (8 existing + 16 new)
- All tests pass (>=17)
- __init__.py updated with all 16 new strategies
</success_criteria>

<output>
After completion, create `.planning/phases/15-new-trading-strategies/15-04-SUMMARY.md`
</output>
