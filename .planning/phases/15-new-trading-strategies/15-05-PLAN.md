---
phase: 15-new-trading-strategies
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - src/backtesting/engine.py
  - tests/test_backtesting_signal_adapter.py
autonomous: true
requirements:
  - FXST-01
  - FXST-02
  - FXST-03
  - FXST-04
  - RTST-01
  - RTST-02
  - RTST-03
  - RTST-04
  - INST-01
  - INST-02
  - CPST-01
  - SVST-01
  - SVST-02
  - SVST-03
  - CAST-01
  - CAST-02
gap_closure: true

must_haves:
  truths:
    - "BacktestEngine.run() handles list[StrategySignal] returns from new v3 strategies by converting them to dict[str, float] target weights"
    - "BacktestEngine.run() continues to handle dict[str, float] and list[StrategyPosition] returns from existing v2 strategies without regression"
    - "Integration tests confirm that backtesting a v3 strategy with mock data produces non-zero total_trades and a valid tearsheet"
  artifacts:
    - path: "src/backtesting/engine.py"
      provides: "_adapt_signals_to_weights method that converts list[StrategySignal] | list[StrategyPosition] | dict[str, float] to dict[str, float]"
      contains: "_adapt_signals_to_weights"
    - path: "tests/test_backtesting_signal_adapter.py"
      provides: "Integration tests for signal adapter and non-zero-trade backtesting"
      min_lines: 120
  key_links:
    - from: "src/backtesting/engine.py"
      to: "src/strategies/base.py"
      via: "StrategySignal.instruments, StrategySignal.suggested_size, StrategySignal.direction"
      pattern: "StrategySignal"
    - from: "src/backtesting/engine.py"
      to: "src/strategies/base.py"
      via: "StrategyPosition.instrument, StrategyPosition.weight"
      pattern: "StrategyPosition"
    - from: "tests/test_backtesting_signal_adapter.py"
      to: "src/backtesting/engine.py"
      via: "BacktestEngine.run() with mock v3 strategy"
      pattern: "BacktestEngine.*run"
---

<objective>
Fix the BacktestEngine signal type mismatch that causes all 16 new v3 strategies to produce 0-trade tearsheets.

Purpose: New strategies return `list[StrategySignal]` from `generate_signals()`, but `BacktestEngine.run()` calls `.keys()` on the return value (expecting `dict[str, float]`). The engine's `try/except` silently swallows the `AttributeError` every step, producing tearsheets with 0 trades. This blocks success criteria 4 and 5 of Phase 15.

Output: A signal adapter in BacktestEngine that handles all three return types (`dict[str, float]`, `list[StrategyPosition]`, `list[StrategySignal]`) plus integration tests proving non-zero trades.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-new-trading-strategies/15-VERIFICATION.md

Key files:
@src/backtesting/engine.py
@src/backtesting/portfolio.py
@src/strategies/base.py (StrategySignal, StrategyPosition dataclasses)
@src/core/enums.py (SignalDirection enum: LONG, SHORT, NEUTRAL)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add _adapt_signals_to_weights adapter to BacktestEngine</name>
  <files>src/backtesting/engine.py</files>
  <action>
Add a private method `_adapt_signals_to_weights` to BacktestEngine that detects the return type of `generate_signals()` and converts it to `dict[str, float]` target weights for `Portfolio.rebalance()`.

The method must handle three return types:

1. **`dict[str, float]`** (existing StrategyProtocol contract, used by mock test strategies): Return as-is. Detection: `isinstance(result, dict)`.

2. **`list[StrategyPosition]`** (v2.0 strategies like RATES_BR_01): Convert by extracting `{position.instrument: position.weight}` for each position. Detection: `isinstance(result, list)` and first element has `.instrument` and `.weight` attributes.

3. **`list[StrategySignal]`** (v3.0 strategies like FX_02): Convert by extracting instrument -> signed size. For each signal:
   - For each instrument in `signal.instruments`:
     - weight = `signal.suggested_size`
     - If `signal.direction == SignalDirection.SHORT`: weight = `-weight`
     - If `signal.direction == SignalDirection.NEUTRAL`: weight = `0.0`
   - If multiple signals target the same instrument, sum the weights
   - Detection: `isinstance(result, list)` and first element has `.instruments` and `.suggested_size` attributes.

4. **Empty list `[]`**: Return empty `dict` `{}`.

Then modify `BacktestEngine.run()` at line 110-113 to call the adapter:

```python
raw_signals = strategy.generate_signals(as_of_date)
target_weights = self._adapt_signals_to_weights(raw_signals)
if not target_weights:
    # No signal for this date -- record equity and continue
    portfolio.equity_curve.append((as_of_date, portfolio.total_equity))
    continue
prices = self._get_prices(as_of_date, list(target_weights.keys()))
```

Also update the `StrategyProtocol` type hint docstring to note that the engine accepts multiple return types (but keep the Protocol's signature as `dict[str, float]` for backward compat -- the adapter handles the actual polymorphism).

Import StrategySignal and StrategyPosition at the top of engine.py:
```python
from src.strategies.base import StrategySignal, StrategyPosition
```

Do NOT change the `try/except` structure in `run()` -- it still provides resilience. The adapter ensures the normal path works; the except block handles genuine data errors.
  </action>
  <verify>
Run existing backtesting tests to confirm no regression:
```bash
python -m pytest tests/test_backtesting.py tests/test_backtesting_v2.py -v --tb=short
```
All existing tests must pass unchanged.
  </verify>
  <done>
`_adapt_signals_to_weights` method exists in BacktestEngine, handles dict/list[StrategyPosition]/list[StrategySignal]/empty-list, and all existing backtesting tests still pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add integration tests for signal adapter and non-zero-trade backtesting</name>
  <files>tests/test_backtesting_signal_adapter.py</files>
  <action>
Create `tests/test_backtesting_signal_adapter.py` with comprehensive tests:

**Unit tests for `_adapt_signals_to_weights`:**

1. `test_adapt_dict_passthrough` -- `dict[str, float]` input returns unchanged.
2. `test_adapt_strategy_position_list` -- `list[StrategyPosition]` converts to `{instrument: weight}`.
3. `test_adapt_strategy_signal_list_long` -- `list[StrategySignal]` with LONG direction converts to `{instrument: +suggested_size}`.
4. `test_adapt_strategy_signal_list_short` -- `list[StrategySignal]` with SHORT direction converts to `{instrument: -suggested_size}`.
5. `test_adapt_strategy_signal_list_neutral` -- NEUTRAL signal produces weight 0.0.
6. `test_adapt_strategy_signal_multi_instrument` -- A signal with `instruments=["DI_PRE_365", "DI_PRE_730"]` produces entries for both.
7. `test_adapt_empty_list` -- Empty list returns `{}`.
8. `test_adapt_none_returns_empty` -- If generate_signals returns None (edge case), adapter returns `{}`.

**Integration tests for non-zero trades:**

9. `test_v3_strategy_backtest_produces_trades` -- Create a mock v3 strategy that returns `list[StrategySignal]` with alternating LONG/SHORT on USDBRL. Use a mock loader that returns synthetic price data. Run `BacktestEngine.run()` over 3 months of monthly rebalancing. Assert `result.total_trades > 0`.

10. `test_v2_strategy_backtest_produces_trades` -- Same but with a mock strategy returning `list[StrategyPosition]`. Assert `result.total_trades > 0`.

11. `test_v3_strategy_tearsheet_has_valid_metrics` -- Run the v3 mock backtest and assert `result.sharpe_ratio` is a finite float, `result.max_drawdown <= 0`, `result.equity_curve` has entries.

12. `test_portfolio_backtest_mixed_v2_v3` -- Run `BacktestEngine.run_portfolio()` with one v2-style mock strategy and one v3-style mock strategy. Assert portfolio_result has `total_trades > 0`.

For StrategySignal creation in tests, use:
```python
from datetime import datetime
from src.strategies.base import StrategySignal, StrategyPosition
from src.core.enums import AssetClass, SignalDirection, SignalStrength

StrategySignal(
    strategy_id="TEST_V3",
    timestamp=datetime(2024, 1, 31),
    direction=SignalDirection.LONG,
    strength=SignalStrength.MODERATE,
    confidence=0.7,
    z_score=1.2,
    raw_value=1.2,
    suggested_size=0.3,
    asset_class=AssetClass.FX,
    instruments=["USDBRL"],
    entry_level=5.0,
    stop_loss=4.8,
    take_profit=5.3,
)
```

For the mock loader, reuse the pattern from `test_backtesting_v2.py`: MagicMock with `get_market_data` returning a DataFrame with `close` column of synthetic prices.
  </action>
  <verify>
Run the new test file:
```bash
python -m pytest tests/test_backtesting_signal_adapter.py -v --tb=short
```
All 12 tests must pass. Specifically verify:
- `test_v3_strategy_backtest_produces_trades` -- `total_trades > 0`
- `test_v3_strategy_tearsheet_has_valid_metrics` -- finite Sharpe, negative max_drawdown
  </verify>
  <done>
12+ tests pass in `test_backtesting_signal_adapter.py`, confirming the adapter handles all signal types and backtests produce non-zero trades with valid metrics. Success criteria 4 and 5 of Phase 15 are now achievable.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Run ALL backtesting tests together to confirm no regression:
```bash
python -m pytest tests/test_backtesting.py tests/test_backtesting_v2.py tests/test_backtesting_signal_adapter.py -v --tb=short
```

2. Run all strategy tests to confirm no side effects:
```bash
python -m pytest tests/test_strategies/ -v --tb=short
```

3. Verify the adapter handles the exact scenario from the VERIFICATION report:
   - A strategy returning `list[StrategySignal]` no longer causes `.keys()` AttributeError
   - BacktestEngine.run() produces a BacktestResult with total_trades > 0
</verification>

<success_criteria>
1. `_adapt_signals_to_weights` exists in BacktestEngine and handles dict, list[StrategyPosition], list[StrategySignal], and empty returns
2. All existing backtesting tests pass (no regression)
3. New integration tests prove total_trades > 0 for v3 strategy backtests
4. New integration tests prove valid tearsheet metrics (finite Sharpe, negative max_drawdown)
5. run_portfolio works with mixed v2/v3 strategies
</success_criteria>

<output>
After completion, create `.planning/phases/15-new-trading-strategies/15-05-SUMMARY.md`
</output>
